{"data":{"site":{"siteMetadata":{"title":"RayLog"}}},"pageContext":{"posts":[{"html":"<h1>About C++ Language based C</h1>\n<p><strong>C++</strong>, 기본적으로 필자가 이 언어를 학습하는 목적은 크게 두 가지로 나눌 수 있다.</p>\n<ol>\n<li>OpenCV, Tensorflow와 같은 관심있는 Tool이 모두 C++로 짜여져 있다는 점.</li>\n<li>컴퓨터 시스템을 학습하면서 '객체지향'을 추구하는 'C'계열 언어를 학습하고 싶다는 점.</li>\n</ol>\n<p>이 두 가지 이유와 더불어 학과 커리큘럼에 존재하지 않기 때문에 학습을 결심하게 되었다.</p>\n<p>그래서 이번 학습을 통해 <strong>프로그래밍에 대한 기본적인 개념</strong>부터 다시 한 번 학습하는 것과 <strong>객체지향 프로그래밍(OOP)에 대한 전반적인 이해</strong>를 목표로 할 것이다. 다른 이들에게도 도움이 될 수 있도록 기본기 위주로 이야기하고자 한다(추후에는 자료구조, 알고리즘, 함수지향에 대한 게시글도 작성할 예정이다).</p>\n<blockquote>\n<p>참고로 <strong>'C++ 기본 개념'</strong>이라는 타이틀의 게시글은 C언어를 어느정도 알고 있다고 생각하고 진행하려고 한다. 만약 C언어에 대한 기본적인 지식이 없다면 다소 어려울 수 있다. 이 점을 참고하고 함께 학습하도록 하자.</p>\n</blockquote>\n<h3>들어가면서</h3>\n<p>이름에서도 알 수 있는 것처럼 C++은 <strong>C언어의 연장선</strong>이라고 생각하면 되겠다. 그래도 연장선이라고 하기에 C언어로 된 프로그램이 많이 존재하기 때문에 <strong>'파생된 것'</strong>으로 이해하면 좋다.</p>\n<p>앞서 언급한 두 언어는 유사하고, 파생된 것이기 때문에 <strong>C++ 컴파일러는 C언어로 작성된 대부분의 프로그램을 컴파일 할 수 있다.</strong> 이를 통합해 C컴파일러라고 부르기도 한다. 그러나 C++은 C가 지니지 않는 문법적 특성도 제법 지니고 있다.</p>\n<blockquote>\n<p>이 중에서 일부는 객체지향적 특성의 반영을 위해 C의 문법 구조가 자연스럽게 발전한 형태로 존재하는 것도 있음을 참고하자.</p>\n</blockquote>\n<p>그래서 이번 장에서는 이러한 <strong>기본적인 Cpp의 특성</strong>을 몇 가지 살펴보고자한다.</p>\n<p>우리는 지금까지 어떤 언어를 학습하고자 할 때 가장 처음 외치는 문자열이 있다. <strong>\"Hello, World!\"</strong>가 그것이다.</p>\n<p>그렇다면 C++에서는 C언어의 \"Hello, World!\"와는 무엇이 다를까? 아래 예제를 보고 차이를 찾아보도록 하자.</p>\n<p>{% highlight C %}</p>\n<h1>include &#x3C;stdio.h></h1>\n<p>int main(){\nprintf(\"Hello, World!\");\nreturn 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nstd::cout &#x3C;&#x3C; \"Hello, Woruld!\" &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이제 언어의 차이가 느껴지는가? 그럼 발견한 차이점을 기반으로 C언어와 다른 3가지 Cpp의 문법적 특성을 살펴보자.</p>\n<h4>1. 헤더파일의 선언 부분</h4>\n<p>구문에서 이해가 안가는 부분이 많겠지만 천천히 <strong>전처리</strong>부터 살펴보자. 우선 C와 C++에서 선언한 헤더파일의 내용은 <strong>'표준 입출력'</strong>에 대한 것이다.</p>\n<p>C에서의 표준 입출력(printf, scanf 등)을 사용하기 위해 <strong>'stdio.h'</strong>를 선언했다면 Cpp에서의 표준 입출력(std::cout, std::cin 등)을 사용하기 위해 <strong>'iostram'</strong>을 선언해야 한다. 그렇다면 여기서 다음과 같은 의문이 들 것이다.</p>\n<blockquote>\n<p>\"C++에서는 헤더파일 선언 시에 확장자(.h) 입력이 필요없나요?\"</p>\n</blockquote>\n<p>여기에 대한 <strong>답은 '필요있다!'</strong>이다. 분명 <strong>'iostram'</strong>에는 확장자가 없지만, 그것은 C++에서 표준 헤더 파일의 선언이기 때문에 <strong>생략된 것</strong>이다.</p>\n<blockquote>\n<p>또한, 그것이 가능한 이유는 c++에서는 표준이 도입되기 전과 후를 구분하기 위함이다. 과거의 헤더파일에는 <strong>'iostram.h'</strong>과 같이 <strong>확장자 선언이 있다</strong>는 점이 그 예이다.</p>\n</blockquote>\n<h4>2. 출력 부분</h4>\n<p>다음은 출력이다. <strong>C</strong>에서의 \"Hello, World\" 출력은 <code class=\"language-text\">printf(&quot;Hello, World!&quot;);</code>이고, <strong>C++</strong>의 출력은 <code class=\"language-text\">std::cout &lt;&lt; &quot;Hello, World!;&quot; &lt;&lt; endl;</code>로 표현되었다.</p>\n<blockquote>\n<p>그렇다면 'std'는 무엇일까?</p>\n</blockquote>\n<p><strong>정답은 Namespace</strong>라고 부르는 <strong>'이름의 충돌문제를 막기 위한 C++의 문법 중 하나'</strong>이다.</p>\n<blockquote>\n<p>Namespace: 프로그램이 대형화가 되면서 여러 회사들이 한 프로젝트에 참여하는 경우가 발생한다. 이럴 때 A사와 B사가 각자 업무를 나누고 일을 진행한다. 그러다 서로의 작업을 merge를 한다고 했을 때, A사와 B사가 구현한 함수의 이름이 같다면 십중팔구 둘 중 하나는 함수의 이름을 변경해야 하는 문제가 생긴다.</p>\n<p>큰 프로젝트에서 함수 이름 하나 바꾸는 게 말처럼 간단한 것일까? 생각만해도 화가나는 상황이다. 그래서 C++에서는 namespace라는 것을 제공해 이 문제를 해결한다. std::cout은 cout이 속한 namespace가 std라는 것이다(std는 standard의 약어이다).</p>\n</blockquote>\n<p>다음은 cout에 대한 이야기다. cout은 <strong>C의 out(출력)</strong>이다(cout은 '코웃'이 아니라는 걸 알아두자). 또한, 이 문법은 위에서 사용한 것처럼 <code class=\"language-text\">std::cout &lt;&lt; &quot;출력 내용&quot;;</code> 으로 사용된다.</p>\n<p>그렇다면 선언된 변수(Variable) 출력의 경우에는 어떨까? 아래의 예제를 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nint var = 10;</p>\n<p>std::cout &#x3C;&#x3C; var &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이처럼 사용된다. 이 부분에서 또 다음과 같은 생각을 할 수 있다. \"오.. 맙소사! 출력 포맷 지정을 하지 않아도 된다니!\" 다소 호들갑을 떨었지만, 새로운 문법 형태이니 놀라도 좋다.</p>\n<blockquote>\n<p>어떻게 이런 형태로 사용하는 것이 가능한가에 대해서는 다음에 설명하겠다.</p>\n</blockquote>\n<p>그 다음으로 궁금한 'std::endl;'에 대해서 살펴보자.</p>\n<h4>3. 개행 부분</h4>\n<p>우리가 학습한 <strong>'C'</strong>에서는 일반적으로 <strong>'입력은 자동으로 개행되지만, 출력은 '\\n'과 같이 개행문자를 사용해야 한다'</strong>고 알고 있다. 그래서 <strong>C++</strong>에서는 출력의 마지막에 <code class=\"language-text\">&#39;\\n&#39;</code>을 대신해 <code class=\"language-text\">std::endl</code>을 표준으로 제공한다(물론 '\\n '도 사용할 수 있다).</p>\n<blockquote>\n<p>endl은 <strong>'end' 'l(line)'</strong>이라는 의미를 지니고 있다. 또한 아직까지 <code class=\"language-text\">&lt;&lt;</code> 연산자가 무얼하는 것인가에 대해서는 학습하지 않았다. 이에 대한 궁금증은 다음에 해소하자.</p>\n</blockquote>\n<p>지금까지의 내용을 정리하자면 다음과 같다.</p>\n<ul>\n<li><strong>표준 헤더 파일</strong>의 경우에는 선언 시 <strong>확장자를 생략</strong>해도 좋다.</li>\n<li><strong>출력</strong>은 <code class=\"language-text\">std::cout&lt;&lt;&#39;출력 내용&#39;;</code> 과 같이 사용하면 된다. 또한 <strong>std는 namespace</strong>이다.</li>\n<li><strong>개행</strong>은 <code class=\"language-text\">&lt;&lt;std::endl</code>이 수행해준다.</li>\n</ul>\n<h5>의문점</h5>\n<ul>\n<li><code class=\"language-text\">&lt;&lt;</code> 연산자는 뭐지?</li>\n<li><strong>namespace</strong>는 뭐지?</li>\n<li>왜 출력 포맷을 지정하지 않아도 출력이 되는 거지?</li>\n</ul>\n<p>이 의문점은 다음의 설명과 이후의 게시글을 보면서 자연스럽게 풀어가도록 하자.</p>\n<p>다음 Cpp의 특성을 살펴 볼 코드는 아래와 같다.</p>\n<p>{% highlight C %}</p>\n<h1>include &#x3C;stdio.h></h1>\n<p>int main (){\nint val1, val2, result =0;</p>\n<p>printf(\"첫 번째 숫자 입력: \");\nscanf(\"%d\", &#x26;val1);</p>\n<p>printf(\"두 번째 숫자 입력: \");\nscanf(\"%d\", &#x26;val2);</p>\n<p>result = val1 + val2;\nprintf(\"덧셈 결과: %d\\n\", result);</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nint val1 = 0;</p>\n<p>std::cout &#x3C;&#x3C; \"첫 번재 숫자 입력: \";\nstd::cin >> val1;</p>\n<p>int val2 = 0;\nstd::cout &#x3C;&#x3C; \"두 번재 숫자 입력: \";\nstd::cin >> val2;</p>\n<p>int result = val1 + val2;\nstd::cout &#x3C;&#x3C; \"덧셈 결과: \" &#x3C;&#x3C; result &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이전의 예제와 마찬가지로 위 코드를 통해서 우리는 C언어와 다른 다음의 3가지 차이점을 간파할 수 있다.</p>\n<h4>1. 지역 변수 선언 부분</h4>\n<p>우선 <strong>변수의 선언부</strong>를 살펴보자. 기존 <strong>C</strong>에서는 <strong>절차 지향적</strong>인 개념에 맞게 선언은 가장 위에서 진행되었다. 그러나 Cpp을 비롯한 JAVA같은 <strong>객체지향적 언어</strong>에서는 사용되기 전에만 선언될 경우에는 위와 같이 중간에 선언하여도 인정된다(요즘 나오는 C 컴파일러들 중 몇 개에서는 중간에 선언이 가능하다).</p>\n<h4>2. 입력 부분</h4>\n<p><code class=\"language-text\">std::cin &gt;&gt; &#39;입력 변수&#39;;</code>의 형태로 사용하며 이 또한 <strong>표준 입력</strong>이라는 것을 알 수 있다. 또한, 출력에서와 마찬가지로 <strong>입력 포맷이 필요하지 않다</strong>는 것을 알 수 있다.</p>\n<h4>3. 문자열과 변수 출력 부분</h4>\n<p>이번에는 <strong>'문자열과 변수의 출력'</strong>에 대한 부분을 보자. 일반적으로 <strong>C</strong>에서는 아래와 같이,</p>\n<p>{% highlight C %}</p>\n<p>result = val1 + val2;\nprintf(\"덧셈 결과: %d\\n\", result);</p>\n<p>{% endhighlight %}</p>\n<p>JAVA에서는 아래와 같이</p>\n<p>{% highlight JAVA %}</p>\n<p>result = val1 + val2;\nSystem.out.print(\"덧셈 결과\" + result);</p>\n<p>{% endhighlight %}</p>\n<p>사용되었다. 그러나 Cpp에서는</p>\n<p>{% highlight Cpp %}</p>\n<p>int result = val1 + val2;\nstd::cout &#x3C;&#x3C; \"덧셈 결과: \" &#x3C;&#x3C; result &#x3C;&#x3C; std::endl;</p>\n<p>{% endhighlight %}</p>\n<p>와 같이 사용하며 C와 같이 하나의 문자열로 취급되는 것이 아닌 <strong>문자열과 따로 취급</strong>된다는 것을 알 수 있다.</p>","id":"9d8fb1dd-474b-566a-abc2-53b530d8d9d9","timeToRead":5,"frontmatter":{"date":"July 03, 2017","path":"/blog/2017-07-03-c++-study-1","tags":"study","title":"Cpp 기본 개념_1"}}],"tag":"study","pagesSum":1,"page":1}}