{"data":{"site":{"siteMetadata":{"title":"RayLog","siteUrl":"https://rayleighko.github.io"}},"markdownRemark":{"html":"<h1>Inline Function</h1>\n<p><strong>Inline Function</strong>은 무엇일까? 쓰여진 그대로 해석해보면 안쪽을 뜻하는 in과 프로그램의 선을 뜻하는 line의 합성이이다. 따라서 이는 <strong>'프로그램 코드 라인 안의 함수'</strong>라고 이해할 수 있을 것이다.</p>\n<p><strong>Inline Function</strong>을 설명하기 전에 그와 유사한 C언어의 <strong>Macro Function</strong>을 짚고 넘어가자. Macro Function의 <strong>장점</strong>은 일반적인 함수에 비해 <strong>실행속도가 빠르다</strong>는 것이 있다. <strong>단점</strong>으로는 <strong>복잡한 함수를 정의하기에 한계가 있다</strong>는 것이다. 복습 삼아 Macro Function을 하나 정의해보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<h1>define SQUARE(x) ((x)*(x)) // Macro Function</h1>\n<p>int main ()\n{\nstd::cout &#x3C;&#x3C; SQUARE(5) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위의 코드는 전처리 과정을 거치면 아래의 코드와 같은 모양이 된다(여기서 중요한 포인트는 function body가 Function call을 대신했다는 점이다).</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; ((5)*(5))) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제와 같이 Function body가 Function call을 완전히 대체했을 때 <strong>\"함수가 인라인화 되었다\"</strong>라고 표현한다. 그런데 우리는 <strong>macro function</strong>의 장점과 단점을 잘 알고 있으니, 다음과 같은 생각을 하지 않을 수 없다.</p>\n<blockquote>\n<p>\"Macro Function은 정의하기가 복잡하니, 장점은 살리면서 일반 함수처럼 정의가 가능하면 좋겠는데?\"</p>\n</blockquote>\n<p>그러면 Cpp에서는 어떻게 이러한 기능을 가지는 <strong>Inline Function</strong>를 제공하는지 살표보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>inline int SQUARE(int x)\n{\nreturn x*x;\n}</p>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; SQUARE(5) &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; SQUARE(12) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>별로 특별한 것은 없어 보인다. 이제 항상 Inline을 사용하면 편할 것 같다. 그렇지만 모든 것에는 일장일단이 있듯이 <strong>Inline Function</strong>도 만능은 아니다. <strong>Macro Function을</strong> 이용한 Function Inline(첫 번째 예제)은 전처리기에 의해서 처리되지만, <strong>키워드 Inline</strong>을 이용한 Function Inline(두 번째 예제)은 <strong>Compiler</strong>에 의해서 처리가 된다.</p>\n<p>따라서 <strong>Compiler</strong>는 <strong>Function Inline</strong>이 오히려 성능에 해가 된다고 판단할 경우, Inline 키워드를 <strong>무시</strong>해버리기도 한다.</p>\n<blockquote>\n<p>또한, 컴파일러는 필요한 경우 일부 함수를 임의로 Inline 처리하기도 한다.</p>\n</blockquote>\n<p>더불어 Inline Function는 Macro Function의 장점을 완전히 대체하지 못했다. Macro Function의 경우는 type에 의존적이지 않은 함수가 되지만 Inline Function의 경우에는 자료형에 따라 다르게 정의해야 한다.</p>\n<p>물론 <strong>Function Overloading</strong>을 통해서 이 문제를 해결할 수 있으나 한 번만 정의하면 되는 매크로 함수의 장점을 버리는 결과로 이어지게 된다.</p>\n<blockquote>\n<p>이러한 것을 보완하기 위해서 이후에 배울 '템플릿(Template)'이라는 것을 이용하면 <strong>Macro Function</strong>과 마찬가지로 <strong>type</strong>에 의존적이지 않은 함수가 완성된다. 아래와 같이 말이다.</p>\n</blockquote>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>template <typename T>\ninline T SQUARE(int x)\n{\nreturn x*x;\n}</p>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; SQUARE(5.5) &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; SQUARE(12) &#x3C;&#x3C; std::endl;\nreturn 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>실제로 위 코드를 실행해보면, 데이터의 손실이 발생하지 않음을 알 수 있다.</p>","frontmatter":{"date":"July 05, 2017","path":"/blog/2017-07-05-c++-study-4","tags":"cpp","title":"Cpp 기본 개념_4"}}},"pageContext":{"refPath":"/blog/2017-07-05-c++-study-4","prev":{"frontmatter":{"title":"Cpp 기본 개념_1","path":"/blog/2017-07-03-c++-study-1"}},"next":{"frontmatter":{"title":"Cpp 기본 개념_3","path":"/blog/2017-07-05-c++-study-3"}}}}