{"data":{"site":{"siteMetadata":{"title":"RayLog","siteUrl":"https://rayleighko.github.io"}},"markdownRemark":{"html":"<h1>Next 입문하기</h1>\n<p>우선 나는 이 글을 쓰기 전에 <a href=\"https://nextjs.org/\">NextJS</a>에서 제공하는 Quick Start를 따라 간단한 <a href=\"https://github.com/rayleighko/react-nextjs\">예제</a>를 구현한 경험이 있다. 하지만, NextJS를 사용하는 법은 알았지만, 억지로 쓰자면 쓸 수 있었지만 왜 써야하고 무엇을 위해 존재하는지를 알지 못했기 때문에 이번 기회를 통해 제대로 NextJS를 이해하고 입문하고자 했다.</p>\n<p>더불어 지금 내가 보고있는 코드가 NextJS를 기반으로 이루어진 코드이기 때문에 이를 이해하기 위해서는 필수불가결하게 NextJS를 이해해야만 했다.</p>\n<p><a href=\"https://velopert.com/3293\">참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기</a></p>\n<p><a href=\"https://jaroinside.tistory.com/24\">참고자료 2 - 11. 서버 사이드 렌더링, 클라이언트 사이드 렌더링</a></p>\n<p><a href=\"https://nextjs.org/learn/basics/getting-started\">참고자료 3 - NextJS Getting Started</a></p>\n<h2>왜 NextJS인가?</h2>\n<p>우선적으로 무언가가 존재하는 이유를 알기 위해서는 그 기술이 왜 만들어졌는지를 이해하면 학습에 큰 도움이 될 것이다. 그렇다면 Next.JS는 왜 만들어진 걸까?</p>\n<p>가장 큰 이유는 리액트에서 SSR(Server Side Rendering)을 하기 위함이라고 할 수 있을 것이다. 리액트에서의 SSR이라는 것을 이해하기 위해서는 기존 웹페이지에서 렌더링하던 방식을 알아야 한다. 우리는 먼저 웹페이지를 구동하는 방식에 대한 이해부터 시작하자.</p>\n<p>우선적으로 웹페이지가 존재하기 위해서는 어떠한 웹 페이지에 접속할 때, 그 페이지를 사용자 화면에 그려주기 위해 렌더링이라는 작업이 필요하다. 그래서 웹페이지를 구동하는 방식은 \"언제, 어떻게 렌더링을 할 것인가?\"에 대한 답이기도 하다.</p>\n<h3>전통적인 웹페이지 구동 방식</h3>\n<p>요청 시마다 새로고침과 함께 서버에 새로운 페이지에 대한 요청을 하는 방식이다. 이때 View가 어떻게 보여질지 또한 서버에서 해석하여 보내주기 때문에 이를 '서버 사이드 렌더링'이라고 이야기한다. 더불어 이는 물건을 쟁여두지않고 필요할 때마다 사러가는 것과 같은 맥락이다. </p>\n<p>하지만 기술의 발전으로 웹에서 제공하는 정보량이 많아지고, 이에 따라 여러 문제점이 발견되면서 전통적인 웹페이지 구동 방식과는 다른 SPA(Single Page Application)라는 기법이 등장하게 되었다.</p>\n<h3>SPA 구동 방식</h3>\n<p>SPA는 이름 그대로 처음에 하나의 빈 페이지만 서버측에 제공하고, View에 대해서는 Client에서 JS를 통해 렌더링하는 방식을 택했다. 이를 CSR(Client Side Rendering), 혹은 '클라이언트 사이드 렌더링'이라고 이야기한다. CSR은 물건을 사러 갈 알바를 고용하고 필요할 때마다 물건을 배송받는 것과 같다.</p>\n<p>SSR과 CSR을 비교하여 설명하는 것은 처음에는 이해가 안될 수도 있지만, 간단히 View를 렌더링하는 위치가 서버냐 클라이언트냐에 따라 서버 사이드 혹은 클라이언트 사이드 렌더링이라고 이야기한다는 것을 알고 넘어가도록 하자.</p>\n<blockquote>\n<p>여기서 주의할 점은 우리가 살펴 볼 SSR과 CSR은 전통적인 웹페이지 구동방식, SPA 구동 방식을 의미하는 것이 아닌 전통적인 웹페이지 구동방식에서는 SSR을 사용하고, SPA 구동 방식에서는 CSR을 사용한다는 것이다.</p>\n</blockquote>\n<p>그리고 이제부터 SSR과 CSR의 가장 큰 차이인 '초기 View 로딩 속도', 'SEO'에 대해 살펴보고 보다 확실하게 NextJS를 사용해보도록 하자.</p>\n<h3>SSR과 CSR의 차이</h3>\n<p>먼저 SSR과 CSR의 가장 큰 차이 중 하나인 '초기 View 로딩 속도'를 비교해보도록 하자.</p>\n<p>SSR의 경우에는 View를 서버에서 렌더링해 가져오기 때문에, 첫 로딩이 매우 짧다. 물론, JS 파일을 모두 다운로드하고 적용하기 전까지는 각각의 기능이 동작하지 않겠지만, 사용자의 입장에서는 매우 빠른 속도로 로딩이 됐다고 생각할 수 있는 것이다.</p>\n<p>반면에 CSR은 서버에서 View를 렌더링하지 않고, 먼저 HTML을 다운로드하고, JS 파일이나 서비스에 필요한 리소스를 다운로드한 후 브라우저에서 렌더링 해 보여주기 때문에 SSR보다는 초기 View를 보기까지의 시간이 길다. 하지만, 보여진 기능 모두 보임과 동시에 동작 가능하다.</p>\n<p>물론, 이 두 차이점은 개인의 취향 혹은 서비스의 UX에 따라 달라질 것이기 때문에 어떤 것이 옳다고 이야기할 수 없을 것이다. 그렇기 때문에 두 번째 큰 차이점인 SEO 문제에 대해 살펴봐야 어떤 것을 선택할지를 판단할 수 있을 것이다.</p>\n<h3>SEO 문제</h3>\n<p>SEO는 Search Engine Optimization의 약자로 검색 엔진 최적화를 의미한다. 즉, SEO 문제는 검색 엔진 최적화 문제를 말하고 검색 엔진의 크롤러들이 웹 페이지의 JS를 해석해 노출시키기 때문에 크롤링을 할 수 없는 시점에서는 검색 엔진에 노출시키지 않는 것이고, 이는 노출 횟수가 줄어듦을 의미한다.</p>\n<p>따라서 CSR은 View를 생성하기 위해서는 JS가 필요하고, View를 생성하기 전까지는 검색 엔진 크롤러의 데이터 수집이 제한적이기 때문에 상대적으로 SEO가 잘되지 않아 사용자 유입이 적고, SSR은 View를 서버에서 렌더링해 제공하기 때문에 상대적으로 SEO에 유리해져 사용자 유입이 많을 것이다.</p>\n<p>정리하면 SSR은 초기 로딩 속도가 빠르고 SEO에 유리하지만, View 변경 시 서버에 계속적으로 요청해야 하므로 서버에 부담이 크다. 그리고 CSR은 초기 로딩 속도가 느리고 SEO에 대한 문제가 있지만, 초기 로딩 후에는 View를 서버에 요청하는 것이 아닌 Client에서 직접 렌더링하기 때문에 매우 빠르다는 장점이 있다.</p>\n<p>또한, 최근에는 이 두 가지 방법을 적절하게 융합한 방법들도 나오고 있다. 즉, 첫 번째 페이지 로딩에서는 서버 사이드 렌더링을 사용하고, 그 후에 모든 페이지 로드에는 클라이언트 사이드 렌더링을 활용하는 방안이 그것이다.</p>\n<h2>다시 본론으로..</h2>\n<p>우리는 NextJS의 탄생 배경을 이해하기 위해 앞선 것처럼 SSR과 CSR을 알아봤다. 그래서 우리는 NextJS를 리액트에서의 SSR을 위한 '도구'라는 것까지 이해했다. 그럼에도 불구하고 다른 도구가 아닌 NextJS를 사용해야만 하는지에 대해서는 이해하지 못했다. 그래서 우선은 NextJS에서 제공하는 <a href=\"https://nextjs.org/learn/\">문서</a>를 살펴보기로 했다.</p>\n<p>문서에 따르면, 최근에 각광받는 Single Page(단일) JavaScript applications에 대한 이야기와 이를 구현하는 것에 대한 어려움을 이야기한다. 더불어 아직도 적절한 어플리케이션을 만들기 위해서는 높은 러닝 커브(client-side routing, page layout 등)를 감수해야 하고, 이는 빠른 페이지 로드를 위해 사용하는 SSR을 적용하기 위한 어려움으로 이어질 수 있다고 이야기한다.</p>\n<p>그래서 NextJS 팀은 사용자 설정이 가능하지만 간단한 무언가를 원했고, 이것을 PHP의 그것과 같이 라우팅에 대해서 걱정할 필요없으며 기본적으로 응용 프로그램이 서버에 렌더링되게 만들고자 생각했다고 한다. 그래서 탄생한 것이 NextJS이다.</p>\n<p>이제 NextJS의 탄생 배경을 어렴풋이 알게 되었다. 그렇다면, 본격적으로 문서를 통해 NextJS로 무엇을 할 수 있을지를 살펴보자. 왜냐면 우리는 NextJS를 '잘' 사용해야 하기 때문이다.</p>\n<ul>\n<li>Server-rendered by default</li>\n<li>Automatic code splitting for faster page loads</li>\n<li>Simple client-side routing (page based)</li>\n<li>Webpack-based dev environment which supports <a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">Hot Module Replacement</a>(HMR)</li>\n<li>Able to implement with Express or any other Node.js HTTP server</li>\n<li>Customizable with your own Babel and Webpack configurations</li>\n</ul>\n<p>위의 내용을 한글로 살펴보면 다음과 같이 이해할 수 있을 것이다.</p>\n<ul>\n<li>기본적으로 서버 렌더링</li>\n<li>보다 빠른 페이지 로드를 위한 자동 코드 스플리팅</li>\n<li>간단한 클라이언트 사이드 라우팅(page 기반)</li>\n<li><a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">Hot Module Replacement</a>(HMR)을 지원하는 웹팩 기반 개발 환경</li>\n<li>익스프레스 혹은 어떤 Node.js HTTP server로 구현이 가능</li>\n<li>바벨과 웹펙 설정으로 사용자 정의 가능</li>\n</ul>\n<p>이제야 NextJS를 왜 사용하고, 언제 사용하면 좋을지를 알게 되었다. 하지만, 아직까지 코드 스플리팅이 무엇인지, HMR이 무엇인지 이것들이 실제 코드에서 어떻게 구현되고 어떤 도움이 되는지를 알지 못한다. 따라서 다음에는 본격적으로 NextJS를 사용하기 전에 익숙하지 않은 키워드들을 정리해보도록 하자.</p>","frontmatter":{"date":"March 05, 2019","path":"/blog/2019-03-05-weplanet_project_1","tags":"study js weplanet","title":"WePlanet Intern - project NextJS1"}}},"pageContext":{"refPath":"/blog/2019-03-05-weplanet_project_1","prev":{"frontmatter":{"title":"WePlanet Intern - project NextJS2","path":"/blog/2019-03-05-weplanet_project_2"}},"next":{"frontmatter":{"title":"WePlanet Intern - study ES3(스코프, 호이스팅)","path":"/blog/2019-03-05-weplanet_study_2"}}}}