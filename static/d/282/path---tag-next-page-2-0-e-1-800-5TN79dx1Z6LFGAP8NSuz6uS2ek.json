{"data":{"site":{"siteMetadata":{"title":"RayLog"}}},"pageContext":{"posts":[{"html":"<h2>투표 기능 구현</h2>\n<h3>현재 상황</h3>","id":"182539df-1b23-551f-8f3d-0648f45578f2","timeToRead":1,"frontmatter":{"date":"March 20, 2019","path":"/blog/2019-03-20-weplanet_project_06","tags":"next","title":"WePlanet Intern - project NextJS_06"}},{"html":"<h2>ViewMore(더보기) 동작 구현</h2>\n<h3>현재 상황</h3>\n<ol>\n<li>API 서버에는 대략 80개 이상의 Comments(댓글 및 답글)에 대한 정보가 담겨있다.  </li>\n<li>이때 API 서버는 20개의 Array 정보를 ApiRoute이라는 추상화된 액션 함수를 통해 하나의 액션 함수(getComments)를 만들고, 이를 프론트 엔드에 Axios로 전달한다. 이때 전달되는 데이터의 형태는 다음과 같이 제공된다(댓글과 답글은 형식 구분없이 스타일만 다르게 제공).  </li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"list\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> not <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> // 모든 comments는 id를 갖는다.\n      <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 내용\n      <span class=\"token property\">\"parent_id\"</span><span class=\"token operator\">:</span> number or <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> // 댓글은 <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> 답글은 number\n      <span class=\"token property\">\"created_at\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 만들어진 시기\n      <span class=\"token property\">\"author_name\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 작성자\n      <span class=\"token property\">\"author_image\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 작성자 프로필 사진\n      <span class=\"token property\">\"total_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 답글의 갯수<span class=\"token punctuation\">,</span> 답글의 경우는 해당 데이터가 존재하지 않음.\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      ...\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"total_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 해당 게시글의 댓글 및 답글의 수\n    <span class=\"token property\">\"parent_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 해당 게시글의 댓글 수\n    <span class=\"token property\">\"limit\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 한 번에 전달되는 데이터의 수(default<span class=\"token operator\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> last_created_at(첫 번째로 전달받을 comments의 생성 일자<span class=\"token punctuation\">)</span>임.</code></pre></div>\n<ol start=\"3\">\n<li>프론트 엔드는 액션 함수를 통해 받은 데이터를 Array.prototype.map으로 뿌려준다.  </li>\n<li>이런 상황에서 유저는 viewMore(더보기) 버튼을 눌렀다.  </li>\n<li>현재 우리는 viewMore 버튼이 클릭되면 현재를 뷰를 기준으로 다음 20개의 Comments 정보를 유저의 뷰에 전달하고 싶다.  </li>\n</ol>\n<h3>가정 및 의문</h3>\n<ol>\n<li>props를 통해 받은 20개의 Array를 props.comment.list라고 칭하고, 이 props.comment.list에 concat을 통해 다음 20개의 Array를 이어 나가는 게 맞나?</li>\n<li>props를 통해 받은 20개의 Array를 하나의 로컬 Array</li>\n<li>props를 통해 받은 20개의 Array를 하나의 로컬 Array로 만들고, 다음 20개의 Array를 다른 로컬 Array로 만들고 둘을 cancat해 렌더하는 게 맞을까?</li>\n</ol>\n<h3>해결 과정</h3>\n<ol>\n<li>우선 가정 및 의문을 해결하기 위해 <a href=\"https://stackoverflow.com/questions/41616376/concat-vs-push-adding-new-array-in-react-best-practice\">참고자료</a>를 읽음. 결론: 리액트 컴포넌트의 상태(state)는 직접 변경(setState가 아닌 직접적인 대입(=, push, 등)하면 안된다(불변성 문제). (<a href=\"https://reactjs.org/docs/react-component.html#state\">docs</a> 참고)</li>\n<li>고민하던 와중에 API 서버에서 던져주는 데이터의 구조가 바뀌었다(DOM이 리랜더링하더라도 사용자가 현재 보고 있는 페이지의 구조가 변하면 안되기 때문에 기존의 방식(20개씩 받아 concat하려고 했던 방식)이 아닌 create_at대신 page를 받아 page * limit을 사용자가 보는 comments의 View로 뿌려주도록 하고자 한다). </li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"list\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> not <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> // 모든 comments는 id를 갖는다.\n      <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 내용\n      <span class=\"token property\">\"parent_id\"</span><span class=\"token operator\">:</span> number or <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> // 댓글은 <span class=\"token null\">null</span><span class=\"token punctuation\">,</span> 답글은 number\n      <span class=\"token property\">\"created_at\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 만들어진 시기\n      <span class=\"token property\">\"author_name\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 작성자\n      <span class=\"token property\">\"author_image\"</span><span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> // 작성자 프로필 사진\n      <span class=\"token property\">\"total_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 답글의 갯수<span class=\"token punctuation\">,</span> 답글의 경우는 해당 데이터가 존재하지 않음.\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      ...\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"total_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 해당 게시글의 댓글 및 답글의 수\n    <span class=\"token property\">\"parent_count\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 해당 게시글의 댓글 수\n    <span class=\"token property\">\"limit\"</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> // 한 번에 전달되는 데이터의 수(default<span class=\"token operator\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> page(<span class=\"token number\">1</span>부터 시작<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>개의 페이지는 total_count까지 limit의 배수만큼 증가<span class=\"token punctuation\">,</span> Ex. page가 <span class=\"token number\">3</span>이고<span class=\"token punctuation\">,</span> limit이 <span class=\"token number\">20</span>이면 총 <span class=\"token number\">60</span>개의 comments를 보여줌<span class=\"token punctuation\">)</span>임.</code></pre></div>\n<ol start=\"3\">\n<li>concat이 아닌, props로 넘겨 받는 데이터를 state로 변환(직접적이지 않게)해 list를 만들고 이걸 map해서 page가 증가함에 따라 mapping하자!</li>\n<li>중간에 props의 list로 map해서 state는 바뀌는데, 이에 따라 View가 변하지 않아서 한참을 삽질했지만, 결국 해결!</li>\n</ol>","id":"c388db04-ccf5-5ed5-9904-a72593cd1583","timeToRead":2,"frontmatter":{"date":"March 12, 2019","path":"/blog/2019-03-12-weplanet_project_05","tags":"next","title":"WePlanet Intern - project NextJS_05"}},{"html":"<h1>대댓글 만들기</h1>\n<p>이번에는 NextJS를 활용한 프로젝트에서 대댓글 만들기를 진행했다. 대댓글이라 하면 해당 게시글의 댓글에 달리는 답글을 말한다. 이런 대댓글을 만들기 전에는 NextJS 프로젝트가 생소할 뿐더러 Form을 Redux-Form을 이용하고 있기 때문에, 써본 적도 없는 Redux-Form을 이용한 데이터 관리를 잘 해낼 수 있을지 의문이었다.</p>\n<p>그래서인지 처음에는 구현 방향을 잃고 어떻게 하면 좋을지를 계속 고민했다. 하물며 이런 고민은 이번만이 아닐 것 같아 이렇게 글을 통해 공유하고자 한다.</p>\n<p>우선 나에게 주어진 상황은 다음과 같았다.</p>\n<ol>\n<li>NextJS 기반 프로젝트</li>\n<li>Redux-Form을 활용한 Form처리</li>\n<li>Redux-Form의 Field를 이용한 컴포넌트 단위 이벤트 처리(?)</li>\n<li>이미 구현되어 있는 댓글 기능</li>\n<li>퍼블리셔가 구현해놓은 정적 웹사이트</li>\n</ol>\n<p>사실 준비물은 모두 갖춰진 상황이었다. 더불어 끝나고 보니 이미 설계가 되어있었기 때문에 나는 그 속에서 기능만 구현하면 되는 상황이었다. 하지만 처음 프로젝트를 받았을 당시에는 이런 상황에 대한 이해도 없었기 때문에 어떻게 구현해야 할까 고민이었다. 그래서 이러한 고민을 순서대로 이 문서에 공유해보도록 하겠다.</p>\n<h2>자, 이제 시작이야 뭐부터 하지?</h2>\n<p>단순히 \"대댓글을 만들어라!\"라는 요구사항만 나에게 주어졌기 때문에 이걸 어떻게 구현할지는 내 주관에 따라 진행할 수 있었다. 우선적으로 Redux의 action을 이용해 API 서버에 request를 보내고, 그 결과로 response를 받는다. 그렇기 때문에  action 함수를 import해서 비동기적으로 사용해야 할 것이다.</p>\n<blockquote>\n<p>만약 비동기가 아닌 동기로 request를 보내거나 respense를 받는다면, 반환 시점을 명확하게 알 수 없어 데이터에 대한 신뢰도가 떨어진다. 아니, 떨어지는 수준이 아니라 신뢰할 수 없다고 할 수 있다.</p>\n</blockquote>\n<p>또한, 대댓글의 state는 해당 페이지에서만 가지고 있어도 된다. 따라서 redux를 통해 global하게 관리하지 않아도 될 것이다. 더불어 퍼블리셔가 있기 때문에 HTML과 CSS에 대한 고민은 하지 않아도 되는 상황이고, 이미 구현되어 있는 댓글과 다른 페이지들을 참고할 수 있었기 때문에 상대적으로 상황이 좋다고 판단했다.</p>\n<p>다음과 같은 진행 상황을 통해 문제를 해결했다.</p>\n<ol>\n<li>Swagger UI를 통해 API 서버에서 넘어오는 값 확인</li>\n<li>넘겨받은 값을 활용해 브라우저의 View를 구현하기로 결심</li>\n<li>댓글이 어떤 형태로 View에 뿌려지는 지를 보고 어떻게 추가할지 결정(댓글은 props의 map으로 뿌려주고 있었음)</li>\n</ol>\n<p>머리 속으로 어느정도 윤곽이 잡히자 천천히 문제를 해결해 나갔다. 하지만, 예상했던 것과 달리 원하는 결과를 출력할 수 없었는데, 그 이유는 Redux-Form을 이용해 액션 함수로 Request를 전달해야 하는데 그 과정이 익숙하지 않았기 때문이었다. 물론 이 문제말고도 팀 내에서도 결정되지 않은 댓글과 답글의 순서 및 형태(스타일 코드는 있었지만, 그걸 사용해 어떻게 뿌려줄지에 대한 의논이 필요했음), API 서버로 전달할 Request의 형식(어떻게 뿌려줄지를 결정하고, 이것을 효율적으로 구현하기 위해(브라우저에서는 연산을 최소한으로) Request와 Response의 형태를 결정해야 했음) 등이 구현에 문제가 되었지만 결론적으로 단시간의 토론을 통해 해결할 수 있었음.</p>\n<p>마찬가지로 다음과 같은 어려움을 겪기도 했다.</p>\n<ol>\n<li>props를 통해 response를 받아오는 상황에서 props를 state에 넣어 state를 변경해가며 브라우저의 View를 계속적으로 렌더링해야 했음.</li>\n<li>더불어 Props를 이용하지 않고, 대입된 state를 활용하고 이를 setState를 활용해 브라우저의 View를 렌더링해줘야 했음(직접 props를 변경할 수 없기 때문)</li>\n<li>Redux-Form의 textarea의 input 값과 이를 전달하기 위해 props로 제공하는 onSubmit 인터페이스에 대한 스터디가 필요했음</li>\n<li>'더보기' 기능이 필요한데, 이 더보기는 API 서버에서 전달받은 limit만큼 댓글과 답글을 기존의 댓글과 답글 배열에 붙여주는 작업이 필요했음</li>\n<li>또한, state를 limit만큼 mapping하기 때문에 답글을 추가할 때 리스트의 처음(더보기 바로 위에 있는 댓글 혹은 답글) 값이 댓글일 경우 그 댓글의 답글을 입력해 등록하면 짤리는 현상이 있었음. 예를 들어 현재는 80개의 댓글과 답글을 보여주는데, 마지막 댓글에 답글을 달면 81개의 댓글과 답글이 존재하지만, 여전히 80개의 정보를 보여주고 있기 때문에 이를 해결해야 했음. -> 리스트의 처음이 댓글이고, 이 댓글의 답글을 작성할 경우 더보기 기능을 실행(80개씩 보여주다가 81개째가 되면 100개를 보여줌, 물론 100개를 보여준다고 했지만, 100개는 최댓값이고 그냥 81개가 보여짐)</li>\n</ol>","id":"d598b4a7-fdae-5943-b9ec-eccc50f85cdc","timeToRead":2,"frontmatter":{"date":"March 08, 2019","path":"/blog/2019-03-08-weplanet_project_04","tags":"next","title":"WePlanet Intern - project NextJS_04"}},{"html":"<h1>NextJS 실습하기 - 기본 예제 따라하기</h1>\n<p>먼저 NextJS에서 제공하는 기본 튜토리얼을 따라 NextJS를 이해하도록 하자. 기본 튜토리얼은 NextJS의 문서에서 Learn을 통해 진행할 수 있으며, GitHub 로그인을 통한 연동이 가능하기 때문에 어렵지않게 진행할 수 있을 것이다.</p>\n<p><a href=\"https://nextjs.org/learn/basics/getting-started/\">NextJS 기본 튜토리얼</a>에서 로그인 후 실습을 진행하도록 하자. 실습 진행은 각자의 몫이기 때문에 여기에 별도의 글을 작성하지는 않고, 그저 후기를 작성하도록 할 것이다.</p>\n<blockquote>\n<p>후기: NextJS의 튜토리얼은 단순히 NextJS를 이해하는 것을 넘어 SSR 그 자체를 이해할 수 있는 튜토리얼이었다. 물론 앞으로도 NextJS의 문서를 많이 살펴봐야겠지만, 이번에 진행한 튜토리얼을 통해 얻은 지식 혹은 의문의 해결을 바탕으로 React에서의 SSR에 대해 보다 깊이 이해할 수 있었다.</p>\n<p>또한, SSR을 이해함과 동시에 React의 심화 기술(HOC, Hooks 등)에 대한 관심이 생겼고, 이를 공부하는 과정에서 얻은 인사이트는 웹 프론트 엔드 엔지니어로 한걸음 더 성장할 수 있는 동력이 되었다고 말할 수 있을 것이다.</p>\n<p>아무튼 문서에 나오는 것처럼 꽤 괜찮은 튜토리얼이었다.</p>\n</blockquote>\n<p><a href=\"https://nextjs.org/learn\">참고자료 1 - NextJS Learn</a></p>\n<p><a href=\"https://reactjs.org/docs/higher-order-components.html\">참고자료 2 - React HOC</a></p>\n<p><a href=\"https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component\">참고자료 3 - 리액트(React) 이해 4 - Higher Order Component(HOC)로 컴포넌트 재사용 하기</a> </p>\n<p>이번에 실습을 진행하며 다음과 같은 키워드에 주목했고, 이 키워드를 공부하며 한걸음 더 성장할 수 있었다. 그 키워드는 다음과 같다.</p>\n<h2>Navigate Between Pages - HOC(Higher-order component)</h2>\n<p>Link에 대한 이야기를 하기 전에 고차원 컴포넌트라고 부를 수 있는 HOC에 대해 알아보도록 하자. HOC는 컴포넌트 로직을 재사용하기 위한 React의 응용(고급) 기술이다. 이 기술은 하나의 React API가 아닌 하나의 패턴으로 사용된다. 조금 더 설명하면, HOC는 컴포넌트를 가져와 다음과 같이 다시 반환하는 기술(패턴)이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> EnhancedComponent <span class=\"token operator\">=</span> <span class=\"token function\">higherOrderComponent</span><span class=\"token punctuation\">(</span>WrappedComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이는 일반적으로 함수를 반환하는 <a href=\"https://en.wikipedia.org/wiki/Higher-order_function\">HOF</a>와 유사하지만, 함수 대신 컴포넌트를 반환한다고 할 수 있다. 이렇게 함으로써 HOC는 리앧ㄱ트 컴포넌트를 인자로 받아서 모종의 처리를 한 후 새로운 리액트 컴포넌트를 리턴하는 컴포넌트라고 할 수 있다.</p>\n<p>HOC는 다음과 같이 활용할 수 있다(<a href=\"https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component\">참고자료2의 내용</a>)</p>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\"><strong>Container 컴포넌트와 Presentational 컴포넌트</strong></a> <strong>분리</strong>: 비지니스 로직을 담당하는 컴포넌트(Container 컴포넌트)와 디스플레이를 담당하는 컴포넌트(Presentational 컴포넌트)를 분리하여 사용 할 때, 컨테이너 컴포넌트를 HOC로 만들어서 사용 할 수 있다.  </li>\n<li><strong>로딩 중 화면 표시</strong>: 보통 SPA(Single Page App)에서 화면이 로딩 중일 때, Skeleton 화면을 보여주고, 로딩이 완료되면 데이터를 보여줄 때 사용 할 수 있다.</li>\n<li><strong>유저 인증 로직 처리</strong>: 컴포넌트 내에서 권한 체크나 로그인 상태를 체크하기 보다는 인증 로직을 HOC로 분리하면 컴포넌트 재사용성도 높일 수 있고, 컴포넌트에서 역할 분리도 쉽게 할 수 있다.</li>\n<li><strong>에러 메세지 표시</strong>: 컴포넌트 내에서 분기문(if/else 등)을 통해 처리 할 수도 있지만, 분기문을 HOC로 만들어 처리 하면 컴포넌트를 더욱 깔끔하게 사용 할 수 있다.</li>\n</ul>\n<h2>Navigate Between Pages - Link</h2>\n<blockquote>\n<p>Link is Just a Higher Order Component (HOC)</p>\n<p>Actually, the style prop on <code class=\"language-text\">next/link</code> has no effect. That's because <code class=\"language-text\">next/link</code>is just a <a href=\"https://facebook.github.io/react/docs/higher-order-components.html\">higher order component</a> which only accepts the \"href\" and some similar props. If you need to style it, you need to do it to the underlying component.</p>\n</blockquote>\n<p>NextJS의 Link는 HOC이다. 위와 같은 문서의 내용에서도 알 수 있듯이 Link는 단순히 HOC이기 때문에 이미 지정된 props에 대해서만 반응한다. 그래서 <code class=\"language-text\">&lt;a&gt; 태그</code>와 같은 일종의 테그로 인식해 사전에 지정된 props가 아닌 style 등의 props를 전달한다면 Link에서 그 결과를 기대하기는 힘들다.</p>\n<h2>Create Dynamic Pages - Passing Data via Query Strings</h2>\n<p>Link에서는 문자열 매개변수(string parameter)를 통해 데이터를 전달한다. NextJS에서는 다음과 같이 질의 문자열(query strings)을 통해 어떤 데이터던지 전달할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">PostLink</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>Link href<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token string\">`/post?title=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>props<span class=\"token punctuation\">.</span>title<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>a<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>a<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Link<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>반대로 데이터를 받는 입장은 다음과 같이 <code class=\"language-text\">withRouter</code> 메서드를 사용해서 값을 전달받는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>withRouter<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'next/router'</span>\n<span class=\"token keyword\">import</span> Layout <span class=\"token keyword\">from</span> <span class=\"token string\">'../components/MyLayout.js'</span>\n\n<span class=\"token keyword\">const</span> Page <span class=\"token operator\">=</span> <span class=\"token function\">withRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Layout<span class=\"token operator\">></span>\n       <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>query<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n       <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span>This is the blog post content<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Layout<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Page</code></pre></div>\n<p>위 코드는 서로 문서에서 다음과 같은 동작을 주고받고 있다고 한다.</p>\n<blockquote>\n<ul>\n<li>We import and use the \"withRouter\" function from \"next/router\" this will inject the Next.js router as a property</li>\n<li>In this case, we are using the router's “query” object, which has the query string params.</li>\n<li>Therefore, we get the title with <code class=\"language-text\">props.router.query.title</code>.</li>\n</ul>\n</blockquote>\n<p>이처럼 NextJS에서는 <code class=\"language-text\">Link</code>와 <code class=\"language-text\">withRouter</code> 통해 클라이언트 측 라우팅을 진행하고, 질의(query) 객체를 이용해 매개변수를 주고받는다. </p>\n<h2>Clean URLs with Route Masking - Route Masking</h2>\n<p>Route Masking은 사용자의 입장에서 URL을 보다 깔끔하게(Clean) 받을 수 있는 기법이다. 두 URL을 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>localhost<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span><span class=\"token operator\">/</span>post<span class=\"token operator\">?</span>title<span class=\"token operator\">=</span>Hello<span class=\"token operator\">%</span><span class=\"token number\">20</span>Next<span class=\"token punctuation\">.</span>js</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>localhost<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span><span class=\"token operator\">/</span>p<span class=\"token operator\">/</span>hello<span class=\"token operator\">-</span>nextjs</code></pre></div>\n<p>두 URL은 같은 곳을 라우팅하고 있지만, 서로 다른 모습을 가진다. 이렇게 변화한 것은 Route Masking을 통해 앞선 Link의 예제가 다음과 같이 수정되어 제공됐기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">PostLink</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>Link <span class=\"token keyword\">as</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token string\">`/p/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>props<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">}</span> href<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token string\">`/post?title=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>props<span class=\"token punctuation\">.</span>title<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>a<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>a<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Link<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">as</code> 키워드를 통해 href의 질의 문자열(query string)의 별명을 지어준 것이라고 이해하면 되겠다.</p>\n<h2>Server Side Support for Clean URLs - Create our Custom Route</h2>\n<p>여기서부터 본격적으로 서버 측(Server Side)에 대한 설명이 시작된다. 우선적으로 이번 파트에서 주목한 키워드는 다음 3가지이다.</p>\n<ul>\n<li>next({ dev }).prepare(): App의 이벤트 리스너</li>\n<li>next({ dev }).render(): App의 렌더링</li>\n<li>next({ dev }).getRequestHandler(): 리퀘스트 핸들러</li>\n</ul>\n<p>위 3가지 키워드는 보통  <code class=\"language-text\">const app = next({ dev })</code>을 통해 사용된다. 위 함수 중 prepare의 내용은 <a href=\"https://github.com/zeit/next.js/blob/fb08e8a1fc452ed4d9d7bda747964cd5c4a7e661/packages/next/server/next-dev-server.js#L54\">여기</a>를 살펴보자. 잠깐 살펴보면 이전 버전과의 호환성을 위해 <a href=\"https://github.com/zeit/next.js/blob/e52508fbf655872085d10904f77eaf35846a0ea2/packages/next-server/server/next-server.ts#L142\">next-server.ts의 prepare</a>을 상속받아 사용되고, NextJS를 사용하기 위한 이벤트 리스너의 개념이라고 볼 수 있다. 일명 '사전 준비'를 위해 사용되며 <code class=\"language-text\">then</code>과 <code class=\"language-text\">catch</code>를 이용할 수 있고, then에서 http server의 동작을 수행할 수 있고, catch를 통해 에러를 받을 수 있다.</p>\n<p>다른 메서드는 다음에 NextJS의 코드를 까보도록 하자.</p>\n<h2>Fetching Data for Pages - getInitialProps</h2>\n<p>NextJS에서는 getInitialProps라는 비동기 함수를 통해 페이지의 데이터를 가져올 수 있다. 즉, 렌더링된 정적 페이지의 데이터를 가져오기 위해 사용되는 것이다. 이렇게 얻어진 데이터는 당연히 서버와 통신(axios)할 수도 있으니 아마도 가장 많이 사용될 함수라고 생각했다.</p>\n<p>이는 다음과 같이 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Layout <span class=\"token keyword\">from</span> <span class=\"token string\">'../components/MyLayout.js'</span>\n<span class=\"token keyword\">import</span> fetch <span class=\"token keyword\">from</span> <span class=\"token string\">'isomorphic-unfetch'</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Post</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Layout<span class=\"token operator\">></span>\n       <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n       <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/&lt;[/]?p>/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n       <span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">.</span>image<span class=\"token punctuation\">.</span>medium<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Layout<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span>\n\nPost<span class=\"token punctuation\">.</span>getInitialProps <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span>query\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`https://api.tvmaze.com/shows/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> show <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Fetched show: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>show<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> show <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Export into a Static HTML App</h2>\n<p>-> No Need to Always Build</p>\n<p>한 번 빌드를 해놓으면 그 안의 내용(contents)만 달라질 경우 따로 빌드할 필요가 없기 때문. 따라서 전체 빌드를 진행하는 것이 아니라 'export'를 이용해 내용을 내보내는 것이다. 하지만, 내용만 달라지는 게 아니라 앱 자체가 바뀌는 경우에는 따로 빌드를 해줘야 함.</p>\n<h2>Lazy Loading Modules</h2>\n<blockquote>\n<p>Next.js does automatic code splitting and it is based on the pages in your app. For example, if one of your modules is used at-least in half of your pages, then it moves into the main JavaScript bundle. If not, that module stays inside the page's bundle.</p>\n</blockquote>\n<p>기본적으로 SPA는 싱글 페이지이기 때문에 모든 모듈이 하나로 합쳐진다. 그래서 이를 해결하기 위해 '코드 스플리팅'이라는 작업을 진행한다는 것을 앞선 문서에서 살펴보았을 것이다. 하지만, 이 코드 스플리팅은 기본적으로 사용자가 정의하지 않기 때문에 SPA를 처음 만들거나 코드 스플리팅을 의식하지 않는다면 코드를 적절하게 나누지 못해 모듈의 크기가 커짐에 따라 페이지의 로딩 속도가 느려질 수 있다.</p>\n<p>그래서 NextJS에서는 <a href=\"https://github.com/zeit/next.js#dynamic-import\">'동적 불러오기(dynamic import)</a>'를 통해 크기가 큰 모듈에 대해 따로 번들링을 시킬 수 있다.</p>\n<blockquote>\n<p>이때 동적 불러오기를 통해 불려진 모듈을 '게으르게 로드된 모듈(Lazy loaded module)'이라고 부른다. </p>\n</blockquote>\n<p>물론 기본적인 설정만 가지고도 자동 코드 스플리팅이 되지만, NextJS가 똑똑하게 스플리팅을 하지 않기 때문에 사용자의 dynamic import를 활용한 코드 스플리팅이 필요하다고 생각한다. </p>\n<blockquote>\n<p>기본적으로 NextJS가 모듈을 스플리팅하는 기준은 절반 이상의 페이지에서 사용되는 모듈은 app.js, main.js 혹은 common.js의 번들 파일로 스플리팅되고, 한 페이지 정도의 작은 규모로 사용되는 모듈은 해당 페이지의 번들 파일로 스플리팅한다.</p>\n</blockquote>\n<p>그래서 다음의 코드를 보고 둘의 차이를 확인해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> firebase <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'firebase'</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    firebase<span class=\"token punctuation\">.</span><span class=\"token function\">initializeApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      databaseURL<span class=\"token punctuation\">:</span> <span class=\"token string\">'https://hacker-news.firebaseio.com'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// we skip the \"already exists\" message which is</span>\n    <span class=\"token comment\">// not an actual error when we're hot-reloading</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token regex\">/already exists/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Firebase initialization error'</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> firebase<span class=\"token punctuation\">.</span><span class=\"token function\">database</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token string\">'v0'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const firebase = require('firebase')</span>\n    <span class=\"token keyword\">const</span> firebase <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'firebase'</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    firebase<span class=\"token punctuation\">.</span><span class=\"token function\">initializeApp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      databaseURL<span class=\"token punctuation\">:</span> <span class=\"token string\">'https://hacker-news.firebaseio.com'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// we skip the \"already exists\" message which is</span>\n    <span class=\"token comment\">// not an actual error when we're hot-reloading</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token regex\">/already exists/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Firebase initialization error'</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> firebase<span class=\"token punctuation\">.</span><span class=\"token function\">database</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token string\">'v0'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 두 코드는 db를 로드하기 위해 사용되는데, 코드 상으로는 이 둘의 실행 결과가 크게 다를 것 없는 것처럼 보인다. 하지만, 하단의 모듈과 같이 동적으로 불러오기(import)를 하면, 해당 모듈이 필요할 때만 불러와서 사용할 수 있다. </p>\n<p>그렇기 때문에 페이지의 로딩 속도를 개선할 수 있는 것이다. 추가적으로 하단의 경우는 번들링될 때 <code class=\"language-text\">chunks/firebase-[a-random-string].js</code>의 형태로 저장되기 때문에 청크된 모듈이 필요해질 때마다 불려간다고 이해하면 될 것이다.</p>\n<p>하지만, 이 예제는 Lazy loading을 위한 완벽한 사례는 아니라고 설명한다. 다음의 설명을 보자.</p>\n<blockquote>\n<p>Frankly, this example is not the perfect use case for lazy loading. That is simply because,</p>\n<ul>\n<li>You need the <code class=\"language-text\">firebase</code> module in all of the pages.</li>\n<li>Lazy loaded firebase module reduces the size of the main JavaScript bundle <code class=\"language-text\">app.js</code>,\nbut it doesn't affect the initial page loading time since the page is server rendered.</li>\n<li>Loading of the main JavaScript bundle doesn't block the initial HTML rendering</li>\n</ul>\n</blockquote>\n<p>그 이유를 정리하면, 게으르게 로드된 firebase 모듈(Lazy loaded firebase module)은 app.js의 크기를 줄이긴 했지만, 이 동작이 초기 페이지 로딩에 영향을 주는 것이 아니고 줄어든 app.js가 더 빨리 로드되기 때문에 빠른 상호작용을 제공하는 것이라고 이야기한다. 그렇기 때문에 게으른 로딩을 위한 사례는 아니라고 이야기하는 것이다.</p>\n<p>어찌됐든, 이것은 완벽하지는 않지만, 괘 괜찮은 예제임에 틀림없으니 지금은 이정도만 이해하고 넘어가도록 하자.</p>\n<h2>Lazy Loading Components</h2>\n<p>앞선 Lazy Loading Modules의 사례와 마찬가지로 이번에는 꽤 큰 모듈이 아닌 꽤 큰 컴포넌트를 불러오는 것에 대한 이야기이다. 이번 예제는 HOC가 적용된 예제이기 때문에 HOC가 익숙하지 않다면 상대적으로 어렵게 느낄 수 있다. 그렇기 때문에 최대한 HOC에 대한 내용은 배제하고 Lazy Loading Components 개념에 대해 알아보도록 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">import</span> MyLayout <span class=\"token keyword\">from</span> <span class=\"token string\">'../components/MyLayout'</span>\n<span class=\"token keyword\">import</span> marked <span class=\"token keyword\">from</span> <span class=\"token string\">'marked'</span>\n<span class=\"token keyword\">import</span> Highlight <span class=\"token keyword\">from</span> <span class=\"token string\">'react-highlight'</span>\n\nmarked<span class=\"token punctuation\">.</span><span class=\"token function\">setOptions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  gfm<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  tables<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  breaks<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">WithPost</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PostPage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">render</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>MyLayout<span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>options<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>Highlight innerHTML<span class=\"token operator\">></span>\n              <span class=\"token punctuation\">{</span><span class=\"token function\">marked</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n            <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Highlight<span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>MyLayout<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드에서 다음과 같이 선언부를 수정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//import Highlight from 'react-highlight'</span>\n<span class=\"token keyword\">import</span> dynamic <span class=\"token keyword\">from</span> <span class=\"token string\">'next/dynamic'</span>\n\n<span class=\"token keyword\">const</span> Highlight <span class=\"token operator\">=</span> <span class=\"token function\">dynamic</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react-highlight'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이것은 NextJS의 dynamic을 이용한 import 방식으로, 이렇게 하면 <code class=\"language-text\">react-highlight</code>가 별도의 파일(chunks/react-hightlight-[a-random-string].js)로 번들링된다.</p>\n<p>하지만, 이것에는 문제가 있다. 원하지 않을 때(코드를 하이라이팅 하지 않는 상황)에도 로드되는 것이 그 원인인데, 이를 해결하기 위해서는 HOC를 통해 조건 검사를 하고, 조건에 맞을 때에만 하이라이트를 시켜줘야 한다. 그래서 다음과 같이 HOC를 구성하면 이를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">import</span> MyLayout <span class=\"token keyword\">from</span> <span class=\"token string\">'../components/MyLayout'</span>\n<span class=\"token keyword\">import</span> marked <span class=\"token keyword\">from</span> <span class=\"token string\">'marked'</span>\n<span class=\"token keyword\">import</span> Highlight <span class=\"token keyword\">from</span> <span class=\"token string\">'react-highlight'</span>\n\nmarked<span class=\"token punctuation\">.</span><span class=\"token function\">setOptions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  gfm<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  tables<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  breaks<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">WithPost</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PostPage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">renderMarkdown</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// If a code snippet contains in the markdown content</span>\n            <span class=\"token comment\">// then use Highlight component</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token regex\">/~~~/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n                        <span class=\"token operator\">&lt;</span>Highlight innerHTML<span class=\"token operator\">></span>\n                            <span class=\"token punctuation\">{</span><span class=\"token function\">marked</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n                        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Highlight<span class=\"token operator\">></span>\n                    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n                <span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\">// If not, simply render the generated HTML from markdown</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                <span class=\"token operator\">&lt;</span>div\n                    dangerouslySetInnerHTML<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>__html<span class=\"token punctuation\">:</span> <span class=\"token function\">marked</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n                <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">render</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                <span class=\"token operator\">&lt;</span>MyLayout<span class=\"token operator\">></span>\n                    <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>options<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n                    <span class=\"token punctuation\">{</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">renderMarkdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n                <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>MyLayout<span class=\"token operator\">></span>\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이처럼 정규표현식 검사 코드<code class=\"language-text\">/~~~/.test(options.content</code>를 활용해 하이라이트 여부를 지정해주면 앞선 문제가 해결된다. 앞서 언급한 것처럼 이제 애플리케이션이 필요할 때에만 클라이언트에서 react-hightlight를 다운로드하고, 로드하는 동안 로딩 컴포넌트가 표시된다.</p>\n<p>지금까지 설명한 Lazy loading dynamic components는 고성능 애플리케이션에서 꽤 중요한 역할을 한다. 필요할 때마다 컴포넌트를 로드하고, 그 결과 페이지가 다운로드 하는 JS의 양이 줄어들고 애플리케이션을 더 빨리 로드할 수 있으며, 보다 나은 사용자 경험을 제공할 수 있는 것이다.</p>\n<p>더불어 NextJS는 동적 컴포넌트에 대해서도 SSR을 제공하기 때문에 동적 컴포넌트로 인한 자원 손실은 우려하지 않아도 되기 때문에 앞선 HOC의 활용 가능한 사례처럼 이용할 수 있을 것이다.</p>\n<p>지금까지 NextJS 문서의 아주 기본적인 내용을 알아보았다. 지금까지 설명한 것은 정말로 NextJS에서 제공하는 가장 기본적이고 핵심적인 내용이기 때문에 NextJS에 입문하고자 한다면 위의 내용을 포함한 기본적인 메커니즘을 이해하는 것이 효율적일 것이다.</p>\n<p>그러면 다음에는 NextJS를 활용한 실습을 통해 보다 NextJS에 빠져보는 시간을 갖도록 하겠다.</p>","id":"1033fd30-a10d-5e39-a521-ccba0798772a","timeToRead":10,"frontmatter":{"date":"March 06, 2019","path":"/blog/2019-03-06-weplanet_project_03","tags":"next","title":"WePlanet Intern - project NextJS_03"}},{"html":"<h1>(아마도)NextJS를 사용하기 위한 사전 지식</h1>\n<p>앞선 내용에서 NextJS를 왜 사용하는지, 언제 사용하면 좋을지를 살펴봤다. 하지만, 아직까지 NextJS에서 제공하는 기능을 전부 이해하지 못했기 때문에 이번에는 NextJS에서 제공하는 기능을 하나하나 살펴보도록 하자.</p>\n<p><a href=\"https://velopert.com/3293\">참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기</a></p>\n<p><a href=\"https://nextjs.org/learn/basics/getting-started\">참고자료 2 - NextJS Getting Started</a></p>\n<p><a href=\"https://velog.io/@velopert/react-code-splitting\">참고자료 3 - 리액트 프로젝트 코드 스플리팅 정복하기</a></p>\n<p><a href=\"http://happycodebox.blogspot.com/2017/03/title_4.html\">참고자료 4 - Webpack2 에서 React HMR(Hot Module Replacement) 설정하기</a></p>\n<p><a href=\"https://webpack.js.org/concepts/\">참고자료 5 - Webpack Concepts</a></p>\n<p><a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">참고자료 6 - Hot Module Replacement</a></p>\n<p>우선 앞선 글에서 적은 NextJS가 제공하는 기능을 가져오자.</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token list punctuation\">*</span> Server-rendered by default  \n<span class=\"token list punctuation\">*</span> Automatic code splitting for faster page loads\n<span class=\"token list punctuation\">*</span> Simple client-side routing (page based)\n<span class=\"token list punctuation\">*</span> Webpack-based dev environment which supports <span class=\"token url\">[Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/)</span>(HMR)\n<span class=\"token list punctuation\">*</span> Able to implement with Express or any other Node.js HTTP server\n<span class=\"token list punctuation\">*</span> Customizable with your own Babel and Webpack configurations</code></pre></div>\n<p>위의 내용을 한글로 보고 싶다면 이전 글을 참고하도록 하자. 그렇다면 가장 첫 번째, 우리가 익히 알고 있던 'Server-rendered by default'에 대해 살펴보자. 말그대로 \"NextJS는 서버 사이드 렌더링을 기본적으로 제공한다\"라고 할 수 있을 것이다. 이제는 당연한 이야기지만, NextJS는 리액트기반의 SPA에서 SSR을 하기 위한 도구이기 때문에 이 부분은 이견없이 넘어갈 수 있었다.</p>\n<p>하지만 다음 문장에 명시된 'Automatic code splitting for faster page loads'에서 'code splitting'이라는 익숙하지 않은 단어가 등장했다. 그 해답은 <a href=\"https://velopert.com/3293\">참고자료 1</a>에서 어렴풋이 찾을 수 있었다.</p>\n<h2>코드 스플리팅(Code Splitting)</h2>\n<p>코드 스플리팅(나누기)이란 일반적인 SPA는 어플리케이션이 Single Page로 구성되어 있기 때문에 예를 들어 A라는 페이지를 보고 싶었을 뿐인데도 페이지를 로딩하면서 사용자가 원하지도 않는 B라는 페이지에 대한 정보도 함께 딸려온다. 이때 코드 스플리팅을 이용하면 새 페이지를 불러오지 않으면서 유동적으로 문제를 해결할 수 있다.</p>\n<p>조금 더 디테일하게 설명하자면, 우리가 JS로 애플리케이션을 개발하면, 웹 브라우저의 입장에서는 기본적으로 하나의 파일에 모든 로직이 들어가게 된다. 그렇기 때문에 프로젝트의 규모가 커지면 JS의 용량도 커질 것이고 이와 마찬가지로 페이지 로드를 처리하기 위한 작업도 느려질 것이다. 하지만 코드 스플리팅을 하게 되면, 지금 당장 필요한 코드가 아니라면 다른 파일로 분리시켜서, 필요할 때 로드할 수 있다. 따라서 코드 스플리팅을 하게 되면 페이지의 로딩 속도를 개선할 수 있을 것이다.</p>\n<p>여기까지 적고 난 다음 드는 생각은 지금까지의 모든 내용이 귀결된다는 것이었다. 우리는 지금까지 SSR과 CSR에 대해 살펴보았고, SPA에서는 기본적으로 CSR을 체택하지만, NextJS를 통해 쉽게 SSR도 가능하다. 또한, NextJS를 쓰면 SSR의 단점이었던 View를 로드하는 시간을 코드 스플리팅으로 극복할 수 있다는 것이 그것이다.</p>\n<p>이제 어느정도 코드 스플리팅에 대해 이해할 수 있었다. 이론적인 이해는 여기까지 진행하도록 하고, 이번 글 이후에 실습을 통해 코드 스플리팅에 대해 더 자세히 알아보도록 하자.</p>\n<p>다음 문장인 'Simple client-side routing (page based)'는 말 그대로 페이지 기반 간단한 클라이언트 측 라우팅을 제공한다는 것이다. 이는 NextJS를 써보지 않고 들었을 때는 이해하기 어려울 수 있다. 하지만, 입문자의 입장에서 간단하게 이해하면 NextJS는 기본적으로 pages라는 디렉터리에 각각의 페이지를 저장하고 각각의 페이지를 기반으로 클라이언트에서 (react-router를 이용하는 등) 별도의 라우팅 설정 없이 간단하게 라우팅을 제공한다고 이해하면 된다. 즉, 파일만 만들어도 자동으로 라우팅된다!</p>\n<p>다음으로 넘어가서, 'Webpack-based dev environment which supports [Hot Module Replacement(HMR)'을 이해해보자. HMR을 지원하는 웹팩 기반의 개발 환경을 제공한다는 의미로 해석할 수 있을 것이다. 하지만 HMR에 대한 기본적인 이해가 없다면 이 문장이 가지는 진정한 의미를 파악하기는 어려울 것이다. 그래서 이번에는 HMR에 대해 살펴보도록 하자.</p>\n<h3>HMR(Hot Module Replacement)</h3>\n<p>우선 HMR을 이해하기 위해서는 Webpack을 이해해야 한다. 일반적으로 Webpack은 JS 애플리케이션을 위한 정적 모듈 번들러이다. 백 엔드에서는 OS가 별도의 모듈 시스템을 제공하지만, 프론트 엔드 환경에서는 별도의 모듈 시스템이 없기 때문에 Webpack을 통해 모든 assets(HTML, CSS, JS, 이미지, … 등)을 하나 이상의 번들(bundle.js) 파일로 통합하고, 그 과정에서 Webpack은 import나 require를 이용해 프로젝트의 의존성 관리를 하기도 한다.</p>\n<p><a href=\"https://webpack.js.org/concepts/\">Webpack Concepts</a>에 따르면, Webpack은 다음과 같은 Core Concepts(핵심 개념)을 가지고 있다.</p>\n<ul>\n<li><a href=\"https://webpack.js.org/concepts/#entry\">Entry</a></li>\n<li><a href=\"https://webpack.js.org/concepts/#output\">Output</a></li>\n<li><a href=\"https://webpack.js.org/concepts/#loaders\">Loaders</a></li>\n<li><a href=\"https://webpack.js.org/concepts/#plugins\">Plugins</a></li>\n<li><a href=\"https://webpack.js.org/concepts/#mode\">Mode</a></li>\n<li><a href=\"https://webpack.js.org/concepts/#browser-compatibility\">Browser Compatibility</a></li>\n</ul>\n<p>우리는 Webpack을 다룰 일이 거의 없고, 지금 당장 필요하지 않기 때문에 여기서는 짧게 설명하고, 다음에 기회가 되면 다른 글을 통해 살펴보도록 하자. 우선 <strong>Entry</strong>는 Webpack이 번들링을 위해 애플리케이션을 읽어들일 첫 번째 시작점을 의미한다. 다음으로 <strong>OutPut</strong>은 번들링이 끝난 후 결과물을 저장할 경로와 파일 이름에 대한 설정을 의미하고, <strong>Loaders</strong>는 정적 파일을 번들링하기 위한 Webpack의 다양한 로더에 대한 설정을 입력할 수 있다. 다음으로 <strong>Plugins</strong>는 Webpack의 확장 기능을 의미한다. 즉, 원하는 <a href=\"https://webpack.js.org/plugins/\">Plugin</a>을 추가하면 해당 Plugin을 사용할 수 있다. <strong>Mode</strong>는 production, development, none으로 설정 가능하며, 각각 의미 그대로 프로젝트의 배포 상태를 의미한다. 마지막으로 <strong>Browser Compatibility</strong>는 Webpack이 ES5와 호환되는 모든 브라우저를 지원한다는 것을 의미한다.</p>\n<p>핵심 개념을 살펴보았지만, 우리가 원한 HMR에 대한 설명은 어디에서도 찾을 수 없었다. 그래서 나는 Webpack에서 제공하는 <a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">Hot Module Replacement</a>를 살펴봐야 했고, 그제서야 HMR을 이해할 수 있었다.</p>\n<p>HMR은 '(뜨거울 정도로)빠른 모듈 교체'라고 이해해도 좋을 것이다. 왜냐하면 HMR은 애플리케이션이 동작하는 동안 모듈을 더하고, 지우는 작업을 풀 리로드하지 않고 진행한다. 이렇게 하면 다음과 같은 몇 가지 방법으로 개발 속도를 높일 수 있다.</p>\n<ul>\n<li>Retain application state which is lost during a full reload.</li>\n<li>Save valuable development time by only updating what's changed.</li>\n<li>Modifications made to CSS/JS in the source code results in an instant browser update which is almost comparable to changing styles directly in the browser's dev tools.</li>\n</ul>\n<p>이를 한글로 번역하면 다음과 같다.</p>\n<ul>\n<li>풀 리로드되는 동안 손실되는 애플리케이션 상태를 유지한다.</li>\n<li>변경된 내용만 업데이트하여 개발 시간을 절약한다.</li>\n<li>소스 코드에서 CSS/JS를 수정하면, 브라우저의 개발(dev) 도구에서 직접 스타일을 변경하는 것과 거의 유사한 브라우저 업데이트가 이루어진다. (즉, 코드의 변경과 함께 브라우저의 스타일이 실시간으로 변경된다.)</li>\n</ul>\n<p>즉, HMR을 통해 개발 속도를 향상시킬 수 있는 것이다. 이로써 HMR을 왜, 언제 사용해야 하는지도 알았다. 이제 다음 문장인 'Able to implement with Express or any other Node.js HTTP server'에 대해서 살펴볼 수 있겠다. 이는 간단하게 'Express 혹은 다른 Node.js HTTP 서버의 지원이 가능하다'는 의미이다. 즉, NextJS는 Express나 NginX 등 어떤 Node.js HTTP 서버 환경에서든 동작한다고 이해하고 넘어가도록 하자.</p>\n<p>마지막으로 'Customizable with your own Babel and Webpack configurations'은 NextJS가 바벨과 웹펙 설정으로 NextJS의 설정을 사용자 임의대로 변경할 수 있다고 이해하면 될 것이다. 이에 대해서는 직접적으로 사용해보지 않았기 때문에 확실하게 이해했다고 보기는 어렵지만, 지금은 그렇게 깊은 단계까지 이해할 필요는 없다고 생각하고 넘어가도록 하자.</p>\n<p>여기까지 NextJS를 사용하기 위한 사전 준비가 끝났다. 이제 우리는 NextJS를 왜, 언제, 어떻게 사용하면 좋을지를 이론적으로 이해할 수 있었다. 이제부터는 이론적인 내용은 차치하고, 실습 위주로 문서를 작성해보도록 하자.</p>","id":"f542e23e-7205-52b5-82f8-a7f9386e2f18","timeToRead":5,"frontmatter":{"date":"March 05, 2019","path":"/blog/2019-03-05-weplanet_project_02","tags":"next","title":"WePlanet Intern - project NextJS_02"}},{"html":"<h1>Next 입문하기</h1>\n<p>우선 나는 이 글을 쓰기 전에 <a href=\"https://nextjs.org/\">NextJS</a>에서 제공하는 Quick Start를 따라 간단한 <a href=\"https://github.com/rayleighko/react-nextjs\">예제</a>를 구현한 경험이 있다. 하지만, NextJS를 사용하는 법은 알았지만, 억지로 쓰자면 쓸 수 있었지만 왜 써야하고 무엇을 위해 존재하는지를 알지 못했기 때문에 이번 기회를 통해 제대로 NextJS를 이해하고 입문하고자 했다.</p>\n<p>더불어 지금 내가 보고있는 코드가 NextJS를 기반으로 이루어진 코드이기 때문에 이를 이해하기 위해서는 필수불가결하게 NextJS를 이해해야만 했다.</p>\n<p><a href=\"https://velopert.com/3293\">참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기</a></p>\n<p><a href=\"https://jaroinside.tistory.com/24\">참고자료 2 - 11. 서버 사이드 렌더링, 클라이언트 사이드 렌더링</a></p>\n<p><a href=\"https://nextjs.org/learn/basics/getting-started\">참고자료 3 - NextJS Getting Started</a></p>\n<h2>왜 NextJS인가?</h2>\n<p>우선적으로 무언가가 존재하는 이유를 알기 위해서는 그 기술이 왜 만들어졌는지를 이해하면 학습에 큰 도움이 될 것이다. 그렇다면 Next.JS는 왜 만들어진 걸까?</p>\n<p>가장 큰 이유는 리액트에서 SSR(Server Side Rendering)을 하기 위함이라고 할 수 있을 것이다. 리액트에서의 SSR이라는 것을 이해하기 위해서는 기존 웹페이지에서 렌더링하던 방식을 알아야 한다. 우리는 먼저 웹페이지를 구동하는 방식에 대한 이해부터 시작하자.</p>\n<p>우선적으로 웹페이지가 존재하기 위해서는 어떠한 웹 페이지에 접속할 때, 그 페이지를 사용자 화면에 그려주기 위해 렌더링이라는 작업이 필요하다. 그래서 웹페이지를 구동하는 방식은 \"언제, 어떻게 렌더링을 할 것인가?\"에 대한 답이기도 하다.</p>\n<h3>전통적인 웹페이지 구동 방식</h3>\n<p>요청 시마다 새로고침과 함께 서버에 새로운 페이지에 대한 요청을 하는 방식이다. 이때 View가 어떻게 보여질지 또한 서버에서 해석하여 보내주기 때문에 이를 '서버 사이드 렌더링'이라고 이야기한다. 더불어 이는 물건을 쟁여두지않고 필요할 때마다 사러가는 것과 같은 맥락이다. </p>\n<p>하지만 기술의 발전으로 웹에서 제공하는 정보량이 많아지고, 이에 따라 여러 문제점이 발견되면서 전통적인 웹페이지 구동 방식과는 다른 SPA(Single Page Application)라는 기법이 등장하게 되었다.</p>\n<h3>SPA 구동 방식</h3>\n<p>SPA는 이름 그대로 처음에 하나의 빈 페이지만 서버측에 제공하고, View에 대해서는 Client에서 JS를 통해 렌더링하는 방식을 택했다. 이를 CSR(Client Side Rendering), 혹은 '클라이언트 사이드 렌더링'이라고 이야기한다. CSR은 물건을 사러 갈 알바를 고용하고 필요할 때마다 물건을 배송받는 것과 같다.</p>\n<p>SSR과 CSR을 비교하여 설명하는 것은 처음에는 이해가 안될 수도 있지만, 간단히 View를 렌더링하는 위치가 서버냐 클라이언트냐에 따라 서버 사이드 혹은 클라이언트 사이드 렌더링이라고 이야기한다는 것을 알고 넘어가도록 하자.</p>\n<blockquote>\n<p>여기서 주의할 점은 우리가 살펴 볼 SSR과 CSR은 전통적인 웹페이지 구동방식, SPA 구동 방식을 의미하는 것이 아닌 전통적인 웹페이지 구동방식에서는 SSR을 사용하고, SPA 구동 방식에서는 CSR을 사용한다는 것이다.</p>\n</blockquote>\n<p>그리고 이제부터 SSR과 CSR의 가장 큰 차이인 '초기 View 로딩 속도', 'SEO'에 대해 살펴보고 보다 확실하게 NextJS를 사용해보도록 하자.</p>\n<h3>SSR과 CSR의 차이</h3>\n<p>먼저 SSR과 CSR의 가장 큰 차이 중 하나인 '초기 View 로딩 속도'를 비교해보도록 하자.</p>\n<p>SSR의 경우에는 View를 서버에서 렌더링해 가져오기 때문에, 첫 로딩이 매우 짧다. 물론, JS 파일을 모두 다운로드하고 적용하기 전까지는 각각의 기능이 동작하지 않겠지만, 사용자의 입장에서는 매우 빠른 속도로 로딩이 됐다고 생각할 수 있는 것이다.</p>\n<p>반면에 CSR은 서버에서 View를 렌더링하지 않고, 먼저 HTML을 다운로드하고, JS 파일이나 서비스에 필요한 리소스를 다운로드한 후 브라우저에서 렌더링 해 보여주기 때문에 SSR보다는 초기 View를 보기까지의 시간이 길다. 하지만, 보여진 기능 모두 보임과 동시에 동작 가능하다.</p>\n<p>물론, 이 두 차이점은 개인의 취향 혹은 서비스의 UX에 따라 달라질 것이기 때문에 어떤 것이 옳다고 이야기할 수 없을 것이다. 그렇기 때문에 두 번째 큰 차이점인 SEO 문제에 대해 살펴봐야 어떤 것을 선택할지를 판단할 수 있을 것이다.</p>\n<h3>SEO 문제</h3>\n<p>SEO는 Search Engine Optimization의 약자로 검색 엔진 최적화를 의미한다. 즉, SEO 문제는 검색 엔진 최적화 문제를 말하고 검색 엔진의 크롤러들이 웹 페이지의 JS를 해석해 노출시키기 때문에 크롤링을 할 수 없는 시점에서는 검색 엔진에 노출시키지 않는 것이고, 이는 노출 횟수가 줄어듦을 의미한다.</p>\n<p>따라서 CSR은 View를 생성하기 위해서는 JS가 필요하고, View를 생성하기 전까지는 검색 엔진 크롤러의 데이터 수집이 제한적이기 때문에 상대적으로 SEO가 잘되지 않아 사용자 유입이 적고, SSR은 View를 서버에서 렌더링해 제공하기 때문에 상대적으로 SEO에 유리해져 사용자 유입이 많을 것이다.</p>\n<p>정리하면 SSR은 초기 로딩 속도가 빠르고 SEO에 유리하지만, View 변경 시 서버에 계속적으로 요청해야 하므로 서버에 부담이 크다. 그리고 CSR은 초기 로딩 속도가 느리고 SEO에 대한 문제가 있지만, 초기 로딩 후에는 View를 서버에 요청하는 것이 아닌 Client에서 직접 렌더링하기 때문에 매우 빠르다는 장점이 있다.</p>\n<p>또한, 최근에는 이 두 가지 방법을 적절하게 융합한 방법들도 나오고 있다. 즉, 첫 번째 페이지 로딩에서는 서버 사이드 렌더링을 사용하고, 그 후에 모든 페이지 로드에는 클라이언트 사이드 렌더링을 활용하는 방안이 그것이다.</p>\n<h2>다시 본론으로..</h2>\n<p>우리는 NextJS의 탄생 배경을 이해하기 위해 앞선 것처럼 SSR과 CSR을 알아봤다. 그래서 우리는 NextJS를 리액트에서의 SSR을 위한 '도구'라는 것까지 이해했다. 그럼에도 불구하고 다른 도구가 아닌 NextJS를 사용해야만 하는지에 대해서는 이해하지 못했다. 그래서 우선은 NextJS에서 제공하는 <a href=\"https://nextjs.org/learn/\">문서</a>를 살펴보기로 했다.</p>\n<p>문서에 따르면, 최근에 각광받는 Single Page(단일) JavaScript applications에 대한 이야기와 이를 구현하는 것에 대한 어려움을 이야기한다. 더불어 아직도 적절한 어플리케이션을 만들기 위해서는 높은 러닝 커브(client-side routing, page layout 등)를 감수해야 하고, 이는 빠른 페이지 로드를 위해 사용하는 SSR을 적용하기 위한 어려움으로 이어질 수 있다고 이야기한다.</p>\n<p>그래서 NextJS 팀은 사용자 설정이 가능하지만 간단한 무언가를 원했고, 이것을 PHP의 그것과 같이 라우팅에 대해서 걱정할 필요없으며 기본적으로 응용 프로그램이 서버에 렌더링되게 만들고자 생각했다고 한다. 그래서 탄생한 것이 NextJS이다.</p>\n<p>이제 NextJS의 탄생 배경을 어렴풋이 알게 되었다. 그렇다면, 본격적으로 문서를 통해 NextJS로 무엇을 할 수 있을지를 살펴보자. 왜냐면 우리는 NextJS를 '잘' 사용해야 하기 때문이다.</p>\n<ul>\n<li>Server-rendered by default</li>\n<li>Automatic code splitting for faster page loads</li>\n<li>Simple client-side routing (page based)</li>\n<li>Webpack-based dev environment which supports <a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">Hot Module Replacement</a>(HMR)</li>\n<li>Able to implement with Express or any other Node.js HTTP server</li>\n<li>Customizable with your own Babel and Webpack configurations</li>\n</ul>\n<p>위의 내용을 한글로 살펴보면 다음과 같이 이해할 수 있을 것이다.</p>\n<ul>\n<li>기본적으로 서버 렌더링</li>\n<li>보다 빠른 페이지 로드를 위한 자동 코드 스플리팅</li>\n<li>간단한 클라이언트 사이드 라우팅(page 기반)</li>\n<li><a href=\"https://webpack.js.org/concepts/hot-module-replacement/\">Hot Module Replacement</a>(HMR)을 지원하는 웹팩 기반 개발 환경</li>\n<li>익스프레스 혹은 어떤 Node.js HTTP server로 구현이 가능</li>\n<li>바벨과 웹펙 설정으로 사용자 정의 가능</li>\n</ul>\n<p>이제야 NextJS를 왜 사용하고, 언제 사용하면 좋을지를 알게 되었다. 하지만, 아직까지 코드 스플리팅이 무엇인지, HMR이 무엇인지 이것들이 실제 코드에서 어떻게 구현되고 어떤 도움이 되는지를 알지 못한다. 따라서 다음에는 본격적으로 NextJS를 사용하기 전에 익숙하지 않은 키워드들을 정리해보도록 하자.</p>","id":"ac986a03-7255-5bf6-8c12-65e2b279cc53","timeToRead":4,"frontmatter":{"date":"March 04, 2019","path":"/blog/2019-03-05-weplanet_project_01","tags":"next","title":"WePlanet Intern - project NextJS_01"}}],"tag":"next","pagesSum":2,"page":2}}