{"data":{"site":{"siteMetadata":{"title":"RayLog"}}},"pageContext":{"posts":[{"html":"<h2>Namespace</h2>\n<!--more-->\n<p>직역하면 <strong>'이름공간'</strong>인 Namespace는 C만을 학습해왔던 이들에게는 다소 생소한 개념이다. 그래도 어렵지않으니 <strong>'별도로 이름을 붙여놓은 공간'</strong>으로 이해하고 특정 영역에 이름을 붙여주기 위한 <strong>문법적 요소</strong>라고 이해하면 되겠다. 그럼에도 아직 생소할테니 다음의 탄생 배경을 보며 이해하도록 하자.</p>\n<hr>\n<p>Namespace의 등장 이전에 A와 B사가 협업을 한다면 사전에 함수, 변수 이름을 모두 정해서 충돌을 예방해야 했다. 그러나 이 부분에서 문제가 발생하게 된다. 그것은 새롭게 추가된 함수나 변수의 경우, 자칫 실수를 해버려 충돌이 나게 될 수도 있기 때문에 프로젝트에 치명적인 장애를 끼치게 된다.</p>\n<p>이는 생각만 해도 아찔하지 않은가. 함수 명 하나 때문에 프로젝트 전체를 수정하는 경우가 생길수도 있으니 말이다. 그래서 이를 해결하고자 Cpp의 표준에서는 <strong>'Namespace'</strong>라는 문법을 정의해서 이러한 문제에 대한 근본적인 해결책을 제시한다.</p>\n<p>간단한 예로 한 동에 철수라는 애가 두 명 산다고 생각해보자. 이 둘을 구분하는 방법은 무수히 많지만 <strong>'201호에 사는 철수'</strong>와 <strong>'202호에 사는 철수'</strong>로 구분해보자. 이때 사용된 201호와 202호가 바로 Namespace의 기본 원리이다.</p>\n<p>'그렇다면 Cpp에서는 어떤 식으로 철수를 부를까?'</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>void Callcs()\n{\nstd::cout &#x3C;&#x3C; \"201호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}\nvoid Callcs()\n{\nstd::cout &#x3C;&#x3C; \"202호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}</p>\n<p>int main()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Apt201();\nreturn 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>별다른 설명이 없이도 위의 예제는 이름과 매개변수 형이 동일하기 때문에 문제가 된다고 파악할 수 있다. 이런 상황에서 아래와 같이 201호의 Namespace를 만들고, 이 안에 함수를 정의하거나 변수를 선언한다면,</p>\n<p>{% highlight Cpp %}</p>\n<p>namespace Apt201 //201호의 Namespace 이름\n{\n// Namespace 내부\n}</p>\n<p>{% endhighlight %}</p>\n<p>마찬가지로 202호의 Namespace를 다음과 같이 만든다면,</p>\n<p>{% highlight Cpp %}</p>\n<p>namespace Apt201 //201호의 Namespace 이름\n{\n// Namespace 내부\n}</p>\n<p>{% endhighlight %}</p>\n<p>충돌은 발생하지 않는다. 이제 실제로 Namespcace가 사용되는 것을 예제로 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>namespace Apt201\n{\nvoid Callcs()\n{\nstd::cout &#x3C;&#x3C; \"201호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}\n}</p>\n<p>namespace Apt202\n{\nvoid Callcs()\n{\nstd::cout &#x3C;&#x3C; \"202호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}\n}</p>\n<p>int main()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Apt201::Callcs();\nApt202::Callcs();\nreturn 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>이 구문을 보고 깊이 깨닫게 된 것이 있을 것이다. 바로 연산자 <code class=\"language-text\">::</code> 을 의미하는 <strong>'Scope resolution Operator(범위지정 연산자)'</strong>을 말이다. 앞선 게시글에서 언급했듯이 std::cout이라는 문장은 std라는 Namespace에 정의된 cout이라는 함수를 사용하는 것이라고 이해하고 넘어가자.</p>\n<p>그렇다면 다음으로 넘어가서, 우리가 익히 아는 것처럼 프로젝트에서 Function declaration과 definition를 분리하는 것은 일반적인 형태이다. 이 경우, <strong>'Function Declaration(함수의 선언)'</strong>은 헤더파일에 저장하고, <strong>'Function Definition(함수의 정의)'</strong>는 소스페일에 저장한다. 따라서 아래의 예제를 통해 Namespace 기반에서 함수의 선언과 정의를 구분하는 방법을 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>namespace Apt201\n{\nvoid Callcs();\n}</p>\n<p>namespace Apt202\n{\nvoid Callcs();\n}</p>\n<p>int main ()\n{\nApt201::Callcs();\nApt202::Callcs();\nreturn 0;\n}</p>\n<p>void Apt201::Callcs(void)\n{\nstd::cout &#x3C;&#x3C; \"201호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}</p>\n<p>void Apt202::Callcs(void)\n{\nstd::cout &#x3C;&#x3C; \"202호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}</p>\n<p>{% endhighlight %}</p>\n<p>참고로, 동일한 Namespace에 정의된 함수를 호출할 때에는 Namespace를 명시할 필요가 없다. 아래의 예제를 살펴보도록 하자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>namespace Apt201\n{\nvoid Callcs();\n}</p>\n<p>namespace Apt201\n{\nvoid Byecs();\n}</p>\n<p>namespace Apt202\n{\nvoid Callcs();\n}</p>\n<p>int main ()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Apt201::Callcs();\nApt202::Callcs();\nreturn 0;</code></pre></div>\n<p>}</p>\n<p>void Apt201::Callcs()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">std::cout &lt;&lt; &quot;201호에 사는 철수 부르기&quot; &lt;&lt; stdendl;\nByecs();\t\t\t//동일한 Namespace의 함수 호출\nApt202::Callcs();\t//다른 Namespace의 함수 호출</code></pre></div>\n<p>}</p>\n<p>void Apt201::Byecs()\n{\nstd::cout &#x3C;&#x3C; \"철수한테 인사하기\" &#x3C;&#x3C; endl;\n}</p>\n<p>void Apt202::Callcs()\n{\nstd::cout &#x3C;&#x3C; \"202호에 사는 철수 부르기\" &#x3C;&#x3C; stdendl;\n}</p>\n<p>{% endhighlight %}</p>\n<p>위의 예제를 통해서 Namespace와 관련된 몇 가지 특성을 이해했을 것이다. 그렇다면 Namespace의 마지막 특징인 Overlap(중첩)에 대해 살펴보자.</p>\n<p>Namespace의 Overlap은 하나의 Namespace안에 다른 Namespace가 삽입될 수 있다는 것이다. 아래와 같이 말이다.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>namespace Parent\n{\nint num = 2;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">namespace SubOne\n{\n\tint num = 3;\n}\n\nnamespace SubTwo\n{\n\tint num = 4;\n}</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제에 대해서는 어렵지않게 이해했으리라 생각된다. 총 3개의 num이 존재하는데, 각각 선언된 Namespace가 다르기 때문에 충돌이 발생하지 않았다. 그렇다면 각각의 변수 num의 접근해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">std::cout &lt;&lt; Parent::num &lt;&lt; std::endl\nstd::cout &lt;&lt; Parent::SubOne::num &lt;&lt; std::endl;\nstd::cout &lt;&lt; Parent::SubTwo::num &lt;&lt; std::endl;</code></pre></div>\n<p>이는 순서대로 2, 3, 4가 출력된다. 이정도면 Namespace의 문법적 규칙을 거의 파악했을 것이다.</p>\n<p>앞서 이야기한 std::cout, std::cin, std::endl을 사용해 콘솔의 입출력을 진행했다. 우리는 이것에 대해 자세히는 모르지만 조금은 알 수 있다. <code class=\"language-text\">::</code> 연산자의 의미를 알게되었기 때문이다. 아래와 같이 이야기할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">std::cout : namespace std에 선언된 cout\nstd::cin : namespace std에 선언된 cin\nstd::endl : namespace std에 선언된 endl</code></pre></div>\n<p>따라서 다음과 같이 Namespace의 구성을 머리 속에 그려볼 수 있다. 아직까지 cout, cin, endl의 문법 구성은 모르지만 말이다.</p>\n<p>{% highlight Cpp %}</p>\n<p>namespace std\n{\ncout . . . .\ncin . . . .\nenl . . . .\n}</p>\n<p>{% endhighlight %}</p>\n<p>때문에 헤더파일 <code class=\"language-text\">&lt;iostream&gt;</code>에 선언되어 있는 'cout', 'cin' 그리고 'endl'은 'namespace std' 안에 선언되어 있다는 결론을 내릴 수 있다. 이렇듯 Cpp에서는 충돌을 막기 위해, Cpp표준에서 제공하는 다양한 요소들은 'namespace std' 안에 선언되어 있다.</p>\n<p>그런데 이쯤되면 이런 생각을 하게 될 것이다. <strong>\"좋은 건 알겠는데 너무 번거롭지 않나?\"</strong>라고 말이다. Cpp에서는 그런 사용자들의 needs를 알고 이런 귀찮음을 해소하기 위해 <code class=\"language-text\">using</code>이라는 키워드를 제공한다. 다음 예제를 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>namespace Simple\n{\nvoid SimpleFunc()\n{\nstd::cout &#x3C;&#x3C; \"Simple Function!\" &#x3C;&#x3C; endl;\nstd::cout &#x3C;&#x3C; \"In Namespace Simple!\" &#x3C;&#x3C; endl;\n}\n}</p>\n<p>int main()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">using Simple::SimpleFunc;\nSimpleFunc();\nreturn 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제에서 사용된 using이라는 키워드는 'SimpleFunc()를 Namespace Simple에서 찾아라!'라는 일종의 선언이다.</p>\n<p>이때, SimpleFunc의 자리는 function이 될 수도 있고, variable이 될 수도 있다. 그리고 위 예제에서는 using이 main function 내에 존재하는데, 이러한 경우 local variable decalation과 마찬가지로 선언된 이후부터 효력을 발휘하며, 선언된 지역(local)을 벗어나면, declaration의 효력은 잃게된다. 따라서 프로그램 전체 영역에 효력을 미치게 하려면 global variable과 마찬가지로 function 밖에서 declaration을 해야 한다.</p>\n<p>또한, 여기서 생각해볼 것은 하나의 Namespace를 사용하는데 그 안에 속한 함수나 변수가 너무 많을 때는 번거롭게 일일이 선언해야하냐는 것이다. 이에 대해서는 아래와 같이 사용하면 되겠다.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>using namespace std;</p>\n<p>int main()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int num = 20;\ncout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;World!&quot; &lt;&lt; endl;\ncout &lt;&lt; num &lt;&lt; &#39; &#39; &lt;&lt; &#39;A&#39;;\ncout &lt;&lt; &#39; &#39; &lt;&lt; 3.14 &lt;&lt; endl;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>이와 같이 사용하면 <strong>편하다는 장점</strong>이 있다. 그러나 잠깐 생각해본다면 이렇게 사용하는 경우에는 충돌이 날 가능성이 높아진다. 따라서, <strong>무조건 편한 것을 사용하기 보다는 혼용하는 것이 바람직하다.</strong></p>\n<p>마지막으로 살펴볼 내용은 Namespace의 별칭 지정이다. 이것은 중첩과 관련되어 여러번 중첩이 된 경우에 사용할 수 있다. 가령 다음과 같이 과도하게 사용되었을 경우에는</p>\n<p>{% highlight Cpp %}</p>\n<p>namespace AAA\n{\nnamespace BBB\n{\nnamespace CCC\n{\nint num1;\nint num2;\n}\n}\n}</p>\n<p>{% endhighlight %}</p>\n<p>다음과 같은 방법으로 변수 num1과 num2를 호출한다면 매우 불편할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">AAA::BBB::CCC::num1 = 20;\nAAA::BBB::CCC::num2 = 30;</code></pre></div>\n<p>그래서 이러한 경우에는 다음과 같이 별칭을 줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">namespace ABC=AAA::BBB::CCC;</code></pre></div>\n<p>이처럼 별칭을 주고 아래처럼 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ABC::num1 = 20;\nABC::num2 = 30;</code></pre></div>\n<p>간단한 팁으로 연산자 <code class=\"language-text\">::</code> 의 또 다른 기능을 살펴보도록 하자.</p>\n<p>local variable의 이름이 global variable과 같을 경우, global variable은 local variable에 의해 가려진다는 특징은 익히 알고있을 것이다.</p>\n<p>그렇다면 이렇게 가려진 상황에서 전역변수에 접근하려면 어떻게 해야할까? 거기에 대한 답은 'Scope resolution Operator'가 해줄 것이다. 아래의 예제를 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int var=100; // global variable</p>\n<p>int SimpleFunc()\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int val = 20;\t// local variable\nvar += 3;\t\t// local variable의 값 3 증가\n::var += 7;\t// global variable의 값 7 증가</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>","id":"6707529b-bfef-5775-af22-7259b8b5938e","timeToRead":6,"frontmatter":{"date":"July 10, 2017","path":"/blog/","tags":"cpp","title":"Cpp 기본 개념_5"}},{"html":"<h2>새로운 자료형 bool</h2>\n<!--more-->\n<p>bool은 C언어에는 존재하지 않고,(C99 이후에는 존재하지만 Cpp와는 다른 형태로 사용된다. &#x3C;의미는 같으나 사용 방식이 차이가 있음) Cpp에만 존재하는 자료형이다.</p>\n<p>간략하게 설명했지만 아직도 몇몇 C컴파일러에서는 bool형태를 지원하지 않으니 bool은 Cpp의 자료형이라고 생각하면 된다. bool 자료형에 대한 설명 이전에 '참'과 '거짓'을 의미하는 true와 false를 이해해보자.</p>\n<hr>\n<p>C에서와 마찬가지로 '0'은 거짓을 의미하는 숫자이다. 그리고 '0'을 제외한 모든 정수는 '참'을 의미하는 숫자로 정의하고 있다. 따라서 기존의 C에서 참과 거짓을 나타내려면 아래와 같이 사전에 작업을 해줘야한다.</p>\n<p>{% highlight Cpp %}</p>\n<h1>define TRUE 1</h1>\n<h1>define FALSE 0</h1>\n<p>{% endhighlight %}</p>\n<p>이러한 참과 거짓의 표현방법은 Cpp에서도 여전히 사용된다. 그러나 Cpp에서는 사전에 키워드 true와 false를 정의하고 있기 때문에 굳이 상수선언을 이용할 필요가 없다. 다음의 예제처럼 키워드 true와 false를 사용할 수 있다.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>using namespace std;</p>\n<p>int main()\n{\nint num = 10;\nint i = 0;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cout &lt;&lt; &quot;true: &quot; &lt;&lt; true &lt;&lt; endl;\ncout &lt;&lt; &quot;false: &quot; &lt;&lt; false &lt;&lt; endl;\n\nwhile(true)\n{\n\tcout &lt;&lt; i++ &lt;&lt; &#39; &#39;;\n    if(i &gt; num)\n    {\n    \tbreak;\n    }\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;sizeof 1: &quot; &lt;&lt; sizeof(1) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof 0: &quot; &lt;&lt; sizeof(0) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof true: &quot; &lt;&lt; sizeof(true) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof false: &quot; &lt;&lt; sizeof(false) &lt;&lt; endl;\n    return 0;\n}</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제의 결과를 보면 알테지만 true와 false이 1과 0을 의미하는 것이 아니다. 이 둘은 참과 거짓을 표현하기 위한 1바이트 크기의 데이터일 뿐이다.</p>\n<p>다만, true와 false가 정의되기 이전에는 참을 표현하기 위해 숫자 1을, 거짓을 표혀하기 위해 숫자 0을 사용했기 때문에, 이 둘을 출력하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환되도록 정의되어 있을 뿐이다.</p>\n<p>그래서 위의 예제에서도 true와 flase를 출력하는 경우에 각각 1과 0이 출력되었으며, 다음과 같이 정수가 와야할 위치에 true와 ㄹalse가 오는 경우에도 1과 0으로 변환이 된다.</p>\n<p>{% highlight Cpp %}</p>\n<p>int num1 = true; // num1에는 1이 저장된다.\nint num2 = false; // num2에는 0이 저장된다.\nint num3 = treu+false; // num3에는 1+0이 저장된다.</p>\n<p>{% endhighlight %}</p>\n<p>따라서 true와 false를 굳이 숫자에 연결시켜서 이해하려 들지 않길 바란다. true와 ㄹalse는 그 자체를 '참'과 '거짓'을 나타내는 목적으로 정의된 데이터로 인식하는 것이 바람직하기 때문이다.</p>\n<p>true와 false는 그 자체로 참과 거짓을 의미하는 데이터이기 때문에 이들 데이터의 저장을 위한 자료형이 별도로 정의되어 있는 것이 당연할 것이다. true와 flase를 가리켜 bool형 데이터라고 한다. 그리고 bool은 int, double과 마찬가지로 기본자료형의 하나이기 때문에 다음과 같이 bool형 변수를 선언하는 것이 가능하다.</p>\n<blockquote>\n<p>bool isTrue=true;\nbool isFalse=false;</p>\n</blockquote>\n<p>또한 bool형은 함수의 반환형으로도 사용할 수 있고, 선언된 bool형 변수에 값을 저장할 수도 있다.</p>","id":"81fc4b95-81ac-5211-9fdc-9d3fd97d390a","timeToRead":2,"frontmatter":{"date":"July 10, 2017","path":"/blog/","tags":"cpp","title":"Cpp 기본 개념_6"}},{"html":"<h1>Function Overloading</h1>\n<p>필자는 C를 처음 접할 당시에는 정말 재미가 없었다. 그런데 어느 순간 재미있기 시작했는데, 그 순간이 바로 <strong>함수</strong>를 배우고 난 이후였다.<br>\nn\n그래서 나름 <strong>function</strong>에 대해서 대해서 애정이 있는데, 일반적인 <strong>C</strong>에서는 다음과 같이 동일한 이름의 함수가 정의되는 것을 허용하지 않는다.</p>\n<p>{% highlight Cpp %}</p>\n<p>int Func(int num)\n{\nnum++;\nreturn num;\n}</p>\n<p>int Func(int a, int b)\n{\nreturn a+b;\n}</p>\n<p>{% endhighlight %}</p>\n<p>그런데 개발자들은 허용되지 않는 위의 두 함수를 보고 의문을 품었다. 그들은 <strong>Parameter</strong>나 <strong>Return type</strong>이 서로 다르다면 동일한 이름의 함수를 사용하는 것이 가능하다고 생각하게 되었고, 이를 C++에 적용했다.</p>\n<p>{% highlight Cpp %}</p>\n<p>int main()\n{\nFunc(20); //Func(int num) 함수의 호출\nFunc(20, 30); //Func(int a, int b) 함수의 호출</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위의 주석에서도 알 수 있듯이 <strong>Function Call</strong> 시 전달되는 인자를 통해서 호출하고자 하는 함수의 구분이 가능하다. 그렇기 때문에 Parameter의 선언형태가 다르다면, <strong>동일한 이름</strong>의 함수를 정의할 수 있다는 것이 이해될 것이다.</p>\n<p>실제로 C++에서는 이를 허용하며 이를 <strong>함수 오버로딩(Function Overloading)</strong>이라 부른다. 또한, 다음과 같은 의문이 들 수도 있다.</p>\n<blockquote>\n<p>이런 방법이 예전부터 논의되어 왔을텐데 왜 <strong>C++</strong>은 <strong>Function Overloading</strong>을 허용하고, <strong>C</strong>는 허용하지 않는 것일까? 여기에 대한 <strong>답은 함수를 찾는 방법이 서로 다르기 때문</strong>이라고 할 수 있다.</p>\n</blockquote>\n<p><strong>C++</strong>은 호출할 함수를 찾을 때 <strong>'Function name'</strong>과 <strong>'Parameter 선언(Declaration)'</strong>의 두 가지 정보를 동시에 활용한다. 반면에 <strong>C</strong>는 <strong>'Function name'</strong>만을 이용해서 호출대상을 찾는다.</p>\n<p>때문에 C에서는 함수의 Overloading이 불가능하며, 이를 문법적으로 허용하지 않는다. 또한, <strong>Function Overloading</strong>이 가능한 것은 <strong>Paramerter Declaration이 다르거나 Returntype이 다른 경우에만 사용</strong>할 수 있다.</p>","id":"9118883c-39d7-5cf3-8cb4-8b37eab5ce7b","timeToRead":1,"frontmatter":{"date":"July 05, 2017","path":"/blog/2017-07-05-c++-study-2","tags":"cpp","title":"Cpp 기본 개념_2"}},{"html":"<h1>Parameter`s Default value</h1>\n<p>앞서 <strong>Function Overloading</strong>에 관해 설명했다. 그런데 Cpp에서의 함수에는 <strong>'Default'</strong>라는 우리도 흔히 접해 본 값을 설정할 수 있다. 혹시 몰라 설명하자면 여기서의 default는 <strong>'기본적으로 설정되어 있는 값'</strong>을 의미한다(일단은 이 정도만 이해해도 괜찮다).</p>\n<hr>\n<p>Cpp에서는 <strong>Function Parameter</strong>를 아래와 같이 선언하는 것이 가능하다.</p>\n<p>{% highlight Cpp %}</p>\n<p>int FuncOne(int num=7)\n{\nreturn num + 1;\n}</p>\n<p>int funcTwo(int num1=5, int num2=7)\n{\nreturn num1+num2;\n}</p>\n<p>{% endhighlight %}</p>\n<p>여기서 <strong>funcOne의 Parameter Declaration</strong>은 다음과 같은 의미를 지닌다.</p>\n<blockquote>\n<p>\"Function Call 시 Parameter를 전달하지 않으면 7이 전달된 것으로 간주한다.\"</p>\n</blockquote>\n<p>따라서 Function call 시 <code class=\"language-text\">FuncOne();</code>과<code class=\"language-text\">FuncOne(7);</code>, 두 함수 호출문은 동일한 의미를 지닌다.</p>\n<p>또한, FuncTwo의 Parameter 선언은 다음과 같은 의미를 지닌다.</p>\n<blockquote>\n<p>\"Function call 시 Parameter를 전달하지 않으면 num1에 5가, num2에 7이 전달된 것으로 간주하겠다.\"</p>\n</blockquote>\n<p>따라서 <code class=\"language-text\">funcTwo();</code>와 <code class=\"language-text\">funcTwo(5, 7);</code>, 두 함수 호출문은 같다.</p>\n<p>그럼 실제 예제를 통해 자세히 알아보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>int Adder(int num1=1, int num2=2)\n{\nreturn num1 + num2;\n}</p>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; Adder() &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; Adder(5) &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; Adder(3,5) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제를 통해 아래와 같은 사실을 추가로 확인할 수 있다.</p>\n<blockquote>\n<p>\"Parameter에 Default value가 설정되어 있으면, <strong>Declaration된 Parameter의 수</strong>보다 <strong>적은 수</strong>의 Parameter전달이 가능하다(예를 들어, <strong>Parameter</strong>이 3개 정의되어 있으면 2개의 <strong>Default value</strong>를 설정할 수 있다).</p>\n<p>그리고 전달되는 Parameter는 <strong>왼쪽부터</strong> 채워져 나가고, 부족분은 <strong>Default value</strong>로 채워진다.\"</p>\n</blockquote>\n<p><code class=\"language-text\">이와 더불어 **Default value**은 **Function Declaration** 부분에만 표현하면 된다는 것도 알 수 있다(물론, 별도의 **Declaration**이 필요한 경우이다).</code><br>\n<code class=\"language-text\">또한, 부분적으로 **Default value**를 설정하고 싶을 때(예를 들어 3개의 Parameter 중에 2개의 Parameter에만 값(Value)을 전달하고 싶을 때)는 **오른쪽**에서부터 채워야한다는 것을 유의해야한다. 그 이유는 아래에 설명할 **&#39;Default value의 유의미성&#39;**을 위해서이다.</code></p>\n<blockquote>\n<p><strong>Default value의 유의미성</strong>: 가령, <code class=\"language-text\">int Func(int num1=12, int num2, int num3){ ... }</code>라는 함수에 20, 30이라는 Parameter를 전달한다고 가정해보자.</p>\n<p>이때 Default value가 의미를 지니기 위해선 num2와 num3에 <strong>Parameter</strong>를 전달해야 하는데 <strong>Parameter</strong>는 앞에서부터 채워지기 때문에 불가능해 결과적으로 <strong>num1에 20이, num2에 30이 전달</strong>된다. 그래서 무의미한 Default value를 방지하고자 오른쪽에서부터 Default value를 채워야한다는 것이다.</p>\n</blockquote>","id":"ff799f00-1e06-5b2f-b45a-e26600162b96","timeToRead":2,"frontmatter":{"date":"July 05, 2017","path":"/blog/2017-07-05-c++-study-3","tags":"cpp","title":"Cpp 기본 개념_3"}},{"html":"<h1>Inline Function</h1>\n<p><strong>Inline Function</strong>은 무엇일까? 쓰여진 그대로 해석해보면 안쪽을 뜻하는 in과 프로그램의 선을 뜻하는 line의 합성이이다. 따라서 이는 <strong>'프로그램 코드 라인 안의 함수'</strong>라고 이해할 수 있을 것이다.</p>\n<p><strong>Inline Function</strong>을 설명하기 전에 그와 유사한 C언어의 <strong>Macro Function</strong>을 짚고 넘어가자. Macro Function의 <strong>장점</strong>은 일반적인 함수에 비해 <strong>실행속도가 빠르다</strong>는 것이 있다. <strong>단점</strong>으로는 <strong>복잡한 함수를 정의하기에 한계가 있다</strong>는 것이다. 복습 삼아 Macro Function을 하나 정의해보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<h1>define SQUARE(x) ((x)*(x)) // Macro Function</h1>\n<p>int main ()\n{\nstd::cout &#x3C;&#x3C; SQUARE(5) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위의 코드는 전처리 과정을 거치면 아래의 코드와 같은 모양이 된다(여기서 중요한 포인트는 function body가 Function call을 대신했다는 점이다).</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; ((5)*(5))) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>위 예제와 같이 Function body가 Function call을 완전히 대체했을 때 <strong>\"함수가 인라인화 되었다\"</strong>라고 표현한다. 그런데 우리는 <strong>macro function</strong>의 장점과 단점을 잘 알고 있으니, 다음과 같은 생각을 하지 않을 수 없다.</p>\n<blockquote>\n<p>\"Macro Function은 정의하기가 복잡하니, 장점은 살리면서 일반 함수처럼 정의가 가능하면 좋겠는데?\"</p>\n</blockquote>\n<p>그러면 Cpp에서는 어떻게 이러한 기능을 가지는 <strong>Inline Function</strong>를 제공하는지 살표보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>inline int SQUARE(int x)\n{\nreturn x*x;\n}</p>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; SQUARE(5) &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; SQUARE(12) &#x3C;&#x3C; std::endl;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return 0;</code></pre></div>\n<p>}</p>\n<p>{% endhighlight %}</p>\n<p>별로 특별한 것은 없어 보인다. 이제 항상 Inline을 사용하면 편할 것 같다. 그렇지만 모든 것에는 일장일단이 있듯이 <strong>Inline Function</strong>도 만능은 아니다. <strong>Macro Function을</strong> 이용한 Function Inline(첫 번째 예제)은 전처리기에 의해서 처리되지만, <strong>키워드 Inline</strong>을 이용한 Function Inline(두 번째 예제)은 <strong>Compiler</strong>에 의해서 처리가 된다.</p>\n<p>따라서 <strong>Compiler</strong>는 <strong>Function Inline</strong>이 오히려 성능에 해가 된다고 판단할 경우, Inline 키워드를 <strong>무시</strong>해버리기도 한다.</p>\n<blockquote>\n<p>또한, 컴파일러는 필요한 경우 일부 함수를 임의로 Inline 처리하기도 한다.</p>\n</blockquote>\n<p>더불어 Inline Function는 Macro Function의 장점을 완전히 대체하지 못했다. Macro Function의 경우는 type에 의존적이지 않은 함수가 되지만 Inline Function의 경우에는 자료형에 따라 다르게 정의해야 한다.</p>\n<p>물론 <strong>Function Overloading</strong>을 통해서 이 문제를 해결할 수 있으나 한 번만 정의하면 되는 매크로 함수의 장점을 버리는 결과로 이어지게 된다.</p>\n<blockquote>\n<p>이러한 것을 보완하기 위해서 이후에 배울 '템플릿(Template)'이라는 것을 이용하면 <strong>Macro Function</strong>과 마찬가지로 <strong>type</strong>에 의존적이지 않은 함수가 완성된다. 아래와 같이 말이다.</p>\n</blockquote>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostram></h1>\n<p>template <typename T>\ninline T SQUARE(int x)\n{\nreturn x*x;\n}</p>\n<p>int main (void)\n{\nstd::cout &#x3C;&#x3C; SQUARE(5.5) &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; SQUARE(12) &#x3C;&#x3C; std::endl;\nreturn 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>실제로 위 코드를 실행해보면, 데이터의 손실이 발생하지 않음을 알 수 있다.</p>","id":"eb0fcd63-45d3-563a-bc2a-65cca2a7081d","timeToRead":2,"frontmatter":{"date":"July 05, 2017","path":"/blog/2017-07-05-c++-study-4","tags":"cpp","title":"Cpp 기본 개념_4"}},{"html":"<h1>About C++ Language based C</h1>\n<p><strong>C++</strong>, 기본적으로 필자가 이 언어를 학습하는 목적은 크게 두 가지로 나눌 수 있다.</p>\n<ol>\n<li>OpenCV, Tensorflow와 같은 관심있는 Tool이 모두 C++로 짜여져 있다는 점.</li>\n<li>컴퓨터 시스템을 학습하면서 '객체지향'을 추구하는 'C'계열 언어를 학습하고 싶다는 점.</li>\n</ol>\n<p>이 두 가지 이유와 더불어 학과 커리큘럼에 존재하지 않기 때문에 학습을 결심하게 되었다.</p>\n<p>그래서 이번 학습을 통해 <strong>프로그래밍에 대한 기본적인 개념</strong>부터 다시 한 번 학습하는 것과 <strong>객체지향 프로그래밍(OOP)에 대한 전반적인 이해</strong>를 목표로 할 것이다. 다른 이들에게도 도움이 될 수 있도록 기본기 위주로 이야기하고자 한다(추후에는 자료구조, 알고리즘, 함수지향에 대한 게시글도 작성할 예정이다).</p>\n<blockquote>\n<p>참고로 <strong>'C++ 기본 개념'</strong>이라는 타이틀의 게시글은 C언어를 어느정도 알고 있다고 생각하고 진행하려고 한다. 만약 C언어에 대한 기본적인 지식이 없다면 다소 어려울 수 있다. 이 점을 참고하고 함께 학습하도록 하자.</p>\n</blockquote>\n<h3>들어가면서</h3>\n<p>이름에서도 알 수 있는 것처럼 C++은 <strong>C언어의 연장선</strong>이라고 생각하면 되겠다. 그래도 연장선이라고 하기에 C언어로 된 프로그램이 많이 존재하기 때문에 <strong>'파생된 것'</strong>으로 이해하면 좋다.</p>\n<p>앞서 언급한 두 언어는 유사하고, 파생된 것이기 때문에 <strong>C++ 컴파일러는 C언어로 작성된 대부분의 프로그램을 컴파일 할 수 있다.</strong> 이를 통합해 C컴파일러라고 부르기도 한다. 그러나 C++은 C가 지니지 않는 문법적 특성도 제법 지니고 있다.</p>\n<blockquote>\n<p>이 중에서 일부는 객체지향적 특성의 반영을 위해 C의 문법 구조가 자연스럽게 발전한 형태로 존재하는 것도 있음을 참고하자.</p>\n</blockquote>\n<p>그래서 이번 장에서는 이러한 <strong>기본적인 Cpp의 특성</strong>을 몇 가지 살펴보고자한다.</p>\n<p>우리는 지금까지 어떤 언어를 학습하고자 할 때 가장 처음 외치는 문자열이 있다. <strong>\"Hello, World!\"</strong>가 그것이다.</p>\n<p>그렇다면 C++에서는 C언어의 \"Hello, World!\"와는 무엇이 다를까? 아래 예제를 보고 차이를 찾아보도록 하자.</p>\n<p>{% highlight C %}</p>\n<h1>include &#x3C;stdio.h></h1>\n<p>int main(){\nprintf(\"Hello, World!\");\nreturn 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nstd::cout &#x3C;&#x3C; \"Hello, Woruld!\" &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이제 언어의 차이가 느껴지는가? 그럼 발견한 차이점을 기반으로 C언어와 다른 3가지 Cpp의 문법적 특성을 살펴보자.</p>\n<h4>1. 헤더파일의 선언 부분</h4>\n<p>구문에서 이해가 안가는 부분이 많겠지만 천천히 <strong>전처리</strong>부터 살펴보자. 우선 C와 C++에서 선언한 헤더파일의 내용은 <strong>'표준 입출력'</strong>에 대한 것이다.</p>\n<p>C에서의 표준 입출력(printf, scanf 등)을 사용하기 위해 <strong>'stdio.h'</strong>를 선언했다면 Cpp에서의 표준 입출력(std::cout, std::cin 등)을 사용하기 위해 <strong>'iostram'</strong>을 선언해야 한다. 그렇다면 여기서 다음과 같은 의문이 들 것이다.</p>\n<blockquote>\n<p>\"C++에서는 헤더파일 선언 시에 확장자(.h) 입력이 필요없나요?\"</p>\n</blockquote>\n<p>여기에 대한 <strong>답은 '필요있다!'</strong>이다. 분명 <strong>'iostram'</strong>에는 확장자가 없지만, 그것은 C++에서 표준 헤더 파일의 선언이기 때문에 <strong>생략된 것</strong>이다.</p>\n<blockquote>\n<p>또한, 그것이 가능한 이유는 c++에서는 표준이 도입되기 전과 후를 구분하기 위함이다. 과거의 헤더파일에는 <strong>'iostram.h'</strong>과 같이 <strong>확장자 선언이 있다</strong>는 점이 그 예이다.</p>\n</blockquote>\n<h4>2. 출력 부분</h4>\n<p>다음은 출력이다. <strong>C</strong>에서의 \"Hello, World\" 출력은 <code class=\"language-text\">printf(&quot;Hello, World!&quot;);</code>이고, <strong>C++</strong>의 출력은 <code class=\"language-text\">std::cout &lt;&lt; &quot;Hello, World!;&quot; &lt;&lt; endl;</code>로 표현되었다.</p>\n<blockquote>\n<p>그렇다면 'std'는 무엇일까?</p>\n</blockquote>\n<p><strong>정답은 Namespace</strong>라고 부르는 <strong>'이름의 충돌문제를 막기 위한 C++의 문법 중 하나'</strong>이다.</p>\n<blockquote>\n<p>Namespace: 프로그램이 대형화가 되면서 여러 회사들이 한 프로젝트에 참여하는 경우가 발생한다. 이럴 때 A사와 B사가 각자 업무를 나누고 일을 진행한다. 그러다 서로의 작업을 merge를 한다고 했을 때, A사와 B사가 구현한 함수의 이름이 같다면 십중팔구 둘 중 하나는 함수의 이름을 변경해야 하는 문제가 생긴다.</p>\n<p>큰 프로젝트에서 함수 이름 하나 바꾸는 게 말처럼 간단한 것일까? 생각만해도 화가나는 상황이다. 그래서 C++에서는 namespace라는 것을 제공해 이 문제를 해결한다. std::cout은 cout이 속한 namespace가 std라는 것이다(std는 standard의 약어이다).</p>\n</blockquote>\n<p>다음은 cout에 대한 이야기다. cout은 <strong>C의 out(출력)</strong>이다(cout은 '코웃'이 아니라는 걸 알아두자). 또한, 이 문법은 위에서 사용한 것처럼 <code class=\"language-text\">std::cout &lt;&lt; &quot;출력 내용&quot;;</code> 으로 사용된다.</p>\n<p>그렇다면 선언된 변수(Variable) 출력의 경우에는 어떨까? 아래의 예제를 살펴보자.</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nint var = 10;</p>\n<p>std::cout &#x3C;&#x3C; var &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이처럼 사용된다. 이 부분에서 또 다음과 같은 생각을 할 수 있다. \"오.. 맙소사! 출력 포맷 지정을 하지 않아도 된다니!\" 다소 호들갑을 떨었지만, 새로운 문법 형태이니 놀라도 좋다.</p>\n<blockquote>\n<p>어떻게 이런 형태로 사용하는 것이 가능한가에 대해서는 다음에 설명하겠다.</p>\n</blockquote>\n<p>그 다음으로 궁금한 'std::endl;'에 대해서 살펴보자.</p>\n<h4>3. 개행 부분</h4>\n<p>우리가 학습한 <strong>'C'</strong>에서는 일반적으로 <strong>'입력은 자동으로 개행되지만, 출력은 '\\n'과 같이 개행문자를 사용해야 한다'</strong>고 알고 있다. 그래서 <strong>C++</strong>에서는 출력의 마지막에 <code class=\"language-text\">&#39;\\n&#39;</code>을 대신해 <code class=\"language-text\">std::endl</code>을 표준으로 제공한다(물론 '\\n '도 사용할 수 있다).</p>\n<blockquote>\n<p>endl은 <strong>'end' 'l(line)'</strong>이라는 의미를 지니고 있다. 또한 아직까지 <code class=\"language-text\">&lt;&lt;</code> 연산자가 무얼하는 것인가에 대해서는 학습하지 않았다. 이에 대한 궁금증은 다음에 해소하자.</p>\n</blockquote>\n<p>지금까지의 내용을 정리하자면 다음과 같다.</p>\n<ul>\n<li><strong>표준 헤더 파일</strong>의 경우에는 선언 시 <strong>확장자를 생략</strong>해도 좋다.</li>\n<li><strong>출력</strong>은 <code class=\"language-text\">std::cout&lt;&lt;&#39;출력 내용&#39;;</code> 과 같이 사용하면 된다. 또한 <strong>std는 namespace</strong>이다.</li>\n<li><strong>개행</strong>은 <code class=\"language-text\">&lt;&lt;std::endl</code>이 수행해준다.</li>\n</ul>\n<h5>의문점</h5>\n<ul>\n<li><code class=\"language-text\">&lt;&lt;</code> 연산자는 뭐지?</li>\n<li><strong>namespace</strong>는 뭐지?</li>\n<li>왜 출력 포맷을 지정하지 않아도 출력이 되는 거지?</li>\n</ul>\n<p>이 의문점은 다음의 설명과 이후의 게시글을 보면서 자연스럽게 풀어가도록 하자.</p>\n<p>다음 Cpp의 특성을 살펴 볼 코드는 아래와 같다.</p>\n<p>{% highlight C %}</p>\n<h1>include &#x3C;stdio.h></h1>\n<p>int main (){\nint val1, val2, result =0;</p>\n<p>printf(\"첫 번째 숫자 입력: \");\nscanf(\"%d\", &#x26;val1);</p>\n<p>printf(\"두 번째 숫자 입력: \");\nscanf(\"%d\", &#x26;val2);</p>\n<p>result = val1 + val2;\nprintf(\"덧셈 결과: %d\\n\", result);</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>{% highlight Cpp %}</p>\n<h1>include <iostream></h1>\n<p>int main()\n{\nint val1 = 0;</p>\n<p>std::cout &#x3C;&#x3C; \"첫 번재 숫자 입력: \";\nstd::cin >> val1;</p>\n<p>int val2 = 0;\nstd::cout &#x3C;&#x3C; \"두 번재 숫자 입력: \";\nstd::cin >> val2;</p>\n<p>int result = val1 + val2;\nstd::cout &#x3C;&#x3C; \"덧셈 결과: \" &#x3C;&#x3C; result &#x3C;&#x3C; std::endl;</p>\n<p>return 0;\n}</p>\n<p>{% endhighlight %}</p>\n<p>이전의 예제와 마찬가지로 위 코드를 통해서 우리는 C언어와 다른 다음의 3가지 차이점을 간파할 수 있다.</p>\n<h4>1. 지역 변수 선언 부분</h4>\n<p>우선 <strong>변수의 선언부</strong>를 살펴보자. 기존 <strong>C</strong>에서는 <strong>절차 지향적</strong>인 개념에 맞게 선언은 가장 위에서 진행되었다. 그러나 Cpp을 비롯한 JAVA같은 <strong>객체지향적 언어</strong>에서는 사용되기 전에만 선언될 경우에는 위와 같이 중간에 선언하여도 인정된다(요즘 나오는 C 컴파일러들 중 몇 개에서는 중간에 선언이 가능하다).</p>\n<h4>2. 입력 부분</h4>\n<p><code class=\"language-text\">std::cin &gt;&gt; &#39;입력 변수&#39;;</code>의 형태로 사용하며 이 또한 <strong>표준 입력</strong>이라는 것을 알 수 있다. 또한, 출력에서와 마찬가지로 <strong>입력 포맷이 필요하지 않다</strong>는 것을 알 수 있다.</p>\n<h4>3. 문자열과 변수 출력 부분</h4>\n<p>이번에는 <strong>'문자열과 변수의 출력'</strong>에 대한 부분을 보자. 일반적으로 <strong>C</strong>에서는 아래와 같이,</p>\n<p>{% highlight C %}</p>\n<p>result = val1 + val2;\nprintf(\"덧셈 결과: %d\\n\", result);</p>\n<p>{% endhighlight %}</p>\n<p>JAVA에서는 아래와 같이</p>\n<p>{% highlight JAVA %}</p>\n<p>result = val1 + val2;\nSystem.out.print(\"덧셈 결과\" + result);</p>\n<p>{% endhighlight %}</p>\n<p>사용되었다. 그러나 Cpp에서는</p>\n<p>{% highlight Cpp %}</p>\n<p>int result = val1 + val2;\nstd::cout &#x3C;&#x3C; \"덧셈 결과: \" &#x3C;&#x3C; result &#x3C;&#x3C; std::endl;</p>\n<p>{% endhighlight %}</p>\n<p>와 같이 사용하며 C와 같이 하나의 문자열로 취급되는 것이 아닌 <strong>문자열과 따로 취급</strong>된다는 것을 알 수 있다.</p>","id":"9d8fb1dd-474b-566a-abc2-53b530d8d9d9","timeToRead":5,"frontmatter":{"date":"July 03, 2017","path":"/blog/2017-07-03-c++-study-1","tags":"cpp","title":"Cpp 기본 개념_1"}}],"tag":"cpp","pagesSum":2,"page":2}}