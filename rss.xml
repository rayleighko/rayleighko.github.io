<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RayLog]]></title><description><![CDATA[Technical blog]]></description><link>http://github.com/dylang/node-rss</link><generator>RSS for Node</generator><lastBuildDate>Mon, 25 Feb 2019 14:40:34 GMT</lastBuildDate><item><title><![CDATA[AWS 아키텍처 - Web Application Hosting 2]]></title><description><![CDATA[<h1>AWS - Architecture study: WEB APPLICATION HOSTING</h1>
<ul>
<li><a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">https://media.amazonwebservices.com/architecturecenter/AWS<em>ac</em>ra<em>web</em>01.pdf</a></li>
</ul>
<p>"AWS Architecture 중에서 가장 기초적으로 구현할 수 있는 모델은 어떤 게 있을까?"라는 고민이 있었는데, 이번 스터디를 진행하면서 그 부분을 해결할 수 있었다.</p>
<p>물론, '구현'을 목적으로 한다면, 더 작은 아키텍처를 선정했을테지만, AWS를 제대로 사용하고, 이를 활용하는 수준을 목적으로 한다면 간단하지만 각 기능이 원활하게 돌아가는 아키텍처를 선정해야 한다는 생각이 있었다. 그래서 나는 이번 스터디를 기회로 AWS 아키텍처 센터에서 제공하고, 가장 처음 만나볼 수 있는 Web Application Hosting 아키텍처를 구현해보고자 했다.</p>
<p>일단 위 PDF에 나와있는 서비스 중 내가 사용해본 서비스는 Route 53, S3, ELB, EC2, RDS가 있다. 하지만 이는 아키텍처를 고려하고 설계를 먼저 한 것이 아니라 필요에 의해서 하나하나 만들었을 뿐이었기 때문에 깊이가 부족하다고 느끼고 있어서 이번 기회에 제대로 알아보려 한다!</p>
<p>설계는 이미 끝나있으니 구현을 해야 할텐데, 구현에 앞서 우선적으로 각 서비스가 어떤 것인지를 알아보도록 하자.</p>
<h2>Amazon Route53</h2>
<p>우선 <a href="https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53란 무엇입니까?</a>를 참고하도록 하자. 해당 참조에 의하면 도메인 등록, DNS 라우팅, 상태 확인의 3가지 주요 기능을 조합하여 실행할 수 있는 서비스라는 점이다. 각각 살펴보도록 하자.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 582px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 76.46048109965635%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACtUlEQVQoz01S2U7bQBTNz/Uj+AKkSqjvfaiqPlV9opuKKhaJh6JKhS5SBQIhWoizQFnq2I4dL2OPl8RrPN7t2HHtGChHM1eW55655849rXKB+QMUReF7cZ5kk6gwUIgcx7Jsd4rSJCvywlWVwDQaVqt8gIpZxShIzvZxmdWh6VMMpAYjAmdGNICSYU3co+dPu2vvmuSKPNfTktQsRQQcx6uaNrXRt+3u9fEfHjsZYhiJtekOxp73Br9OLFX5/uLZ742PNbkoWk25MI49D3meH0bh1EF7m2csDpuMKizKVB9l4KMBSXI8P8tmtWwnK9NinsRRUV1Sqy7jMN3dOJUoVYpKBhoiB0YML4mKh6LqLc6BSij6bc+yNZW1saoqURQ1v6Iw2ds8pXFZt5HAK0CQBV4WBFkEquuEyzsHLw87VVpVrHXR75EEAQAIwuCe/GOr3emzl1C+GPE9hu8zVeS6DCeOJ1uHJ1/b5/N8IZthRjzHaYqexGlDbmQLlFp1mRXzu0HU0Q98CAAUuDipk1sTS1TGojV21WkcZ+m8zBeyzwClAb8kOGM0FElCYEeyYUQhCsWb9RHVbS5syfrQdLQ8LYbSlKYB4KDr+F/WMarXV6TOBOIq25Potg4uTXjtW7Dz6VHnYLUR05rYgu3oeV6PZJbmRV46tnO83xUoinM0O7A8S9AgGSAlT4yxCvCLI+LyCHn1A7XMKbSm4zRK5Sh3gjBLE8syDWNi2nZ+13AjstoIeazAA0lK0kXP2SwRxwPfcwTLE6AMqjMg8rwAIXSRFwZRcIvQr+H97Lxt//1cj6p2WOWbyFUNmjXBm7XX2x9eVS5gxRtRpTSThePh/VJ02nCU9ztPdg9X/3u7Nui80PJy+fHKytISQeIYdoYTuGkZszxtVprFhjkZ0tTV1dVgMKh0IYT+AafFKBmlLOFpAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="dns-routing"
        title=""
        src="/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png"
        srcset="/static/e2f6fe34c52e613cd80585054ae48a2f/30e25/dns-routing.png 163w,
/static/e2f6fe34c52e613cd80585054ae48a2f/fedab/dns-routing.png 325w,
/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png 582w"
        sizes="(max-width: 582px) 100vw, 582px"
      />
  </span>
  </a></p>
<ul>
<li>
<p>도메인 등록은 우리가 흔히 알고 있는 것처럼 .com이나 .kr 등의 도메인을 자신만의 이름로 사용할 수 있게 해주는 서비스이다. Ex. <a href="https://www.naver.com">https://www.naver.com</a></p>
</li>
<li>
<p>다음으로 DNS 라우팅은 인터넷 트래픽을 도메인의 리소스로 라우팅하는 것을 말한다. 다시 말해 사용자의 요청이나 입력 등을 등록된 도메인에 전달하는 작업을 말하는 것이다.</p>
<ul>
<li>더불어 도메인의 형태가 항상 우리가 알고있는 www~로 시작하는 것만 존재하는 것이 아니라는 것에 유의하자. 우리가 흔히 알고있는 www는 World Wide Web의 약지로, 하나의 규격이다. 가령 <a href="https://mail.google.com%EC%99%80">https://mail.google.com와</a> 같은 도메인의 사용도 가능하다는 것이다.</li>
<li>그렇다면 위와 같이 모든 도메인을 따로 등록해야 할까? 그건 아니다. 가령 구글을 예로 들자면 구글의 모든 서비스를 Route 53을 통해 하나로 라우팅하고 싶다면 도메인 입력 란에 google.com만 입력하는 것도 방법이다. 이때 이를 최상위 도메인이라고 부를 수 있으며 앞선 메일 혹은 홈 페이지를 하위 도메인으로 설정할 수도 있다.</li>
<li>DNS에 대한 자세한 내용은 <a href="https://aws.amazon.com/ko/route53/what-is-dns/">DNS란 무엇입니까?</a>을 활용하도록 하자.</li>
</ul>
</li>
<li>
<p>마지막으로 상태 확인은 통신되고 있는 리소스의 상태를 확인한다는 의미이다. 문서에 따르면 Route 53은 인터넷을 통해 웹 서버 같은 리소스로 자동화된 요청을 보내어 접근 및 사용이 가능하고, 정상 작동 중인지 확인하는 기능을 한다고 한다. 더불어 리소스를 사용할 수 없게 될 때 알림을 수신한다거나 (비정상 리소스가 아닌) 다른 곳으로 인터넷 트래픽을 라우팅할 수도 있다고 한다.</p>
</li>
</ul>
<h2>Amazon CloudFront(CF)</h2>
<p>CloudFront는 사용해보지 않았기 때문에 무척 궁금했다. 그래서 <a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html">Amazon CloudFront란?</a>을 참고하기로 했다. 문서에 따르면 "Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다."라는 설명을 볼 수 있다.</p>
<p>잉? 이런 건 EC2를 통해서 하는 게 아니었나? 가만, 다시 살펴보니 <strong>정적 및 동적 웹 콘텐츠</strong>라는 단어가 신경쓰인다. 그렇구나. 이건 내 웹 사이트의 contents에 해당하는 이야기구나! 그렇다면 소스 코드는 왜 있는 걸까? 조금 더 문서를 읽어보자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">CloudFront는 엣지 위치라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다.
CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 라우팅되므로 콘텐츠 전송 성능이 뛰어납니다.

- 콘텐츠가 이미 지연 시간이 가장 낮은 엣지에 있는 경우 CloudFront가 콘텐츠를 즉시 제공합니다.
- 콘텐츠가 엣지 로케이션에 없는 경우 CloudFront는 콘텐츠의 최종 버전에 대한 소스로 지정된 오리진(예: Amazon S3 버킷, MediaPackage 채널,
  HTTP 서버(예: 웹 서버) 등)에서 콘텐츠를 검색합니다.</code></pre></div>
<p>이 글을 통해 "엣지 로케이션이 contents에 대한 Cache 역할을 하는구나!"라고 이해할 수 있었지만, 그럼에도 왜 EC2에서 할 수 있는 작업을 굳이 CloudFront에서 하는지 몰랐다. 하지만 이런 의문은 다음 문장을 통해 해결할 수 있었다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">예를 들어, CloudFront가 아닌 일반적인 웹 서버에서 이미지를 제공한다고 가정합니다.
예를 들어 http://example.com/sunsetphoto.png URL을 사용하여 sunsetphoto.png라는 이미지를 서비스할 수 있습니다.

사용자는 이 URL로 쉽게 이동해 해당 이미지를 볼 수 있습니다. 하지만 이미지가 발견될 때까지 인터넷으로 이루어진 상호 연결된 네트워크의 복잡한 모음을
통해 네트워크에서 다른 네트워크로 요청이 라우팅되었다는 사실은 아마도 모르고 있을 것입니다.</code></pre></div>
<p>이는 리다이렉션을 통해 사용자가 콘텐츠에 접근하게 될 경우 발생하는 비용을 줄이고자 하는 목적으로 사용될 수 있음을 암시하고 있다. 앞서 이해한 Cache의 개념을 조금 확장해 사용자의 입장에서 낮은 지연 시간으로 contents를 얻고, 비용을 절약하게 된다는 것을 이해했다!!</p>
<p>이는 언뜻 보기에는 별 것 아닐 수도 있지만, 나에게 있어서는 놀라운 기술일 수밖에 없다. 앞서 언급한 '비용'에는 사용자 경험, 물리 장비, 인력 등 다양한 의미가 포함되어 있고, 이를 단번에 최적화한 기술이기 때문이다. 놀라움도 잠시 다음 문장을 통해서 이해를 다질 수 있었다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">CloudFront는 AWS 백본 네트워크를 통해 콘텐츠를 가장 효과적으로 서비스할 수 있는 엣지로 각 사용자 요청을 라우팅하여 콘텐츠 배포 속도를 높입니다.
일반적으로 CloudFront 엣지가 최종 사용자에게 가장 빨리 제공합니다.
AWS 네트워크를 사용하면 사용자의 요청이 반드시 통과해야 하는 네트워크의 수가 줄어들어 성능이 향상됩니다.
파일의 첫 바이트를 로드하는 데 걸리는 지연 시간이 줄어들고 데이터 전송 속도가 빨라집니다.

또한 파일(객체라고도 함)의 사본이 전 세계 여러 엣지 로케이션에 유지(또는 캐시)되므로 안정성과 가용성이 향상됩니다.</code></pre></div>
<p>정말 너무 환상적인 서비스군! 저렴한 비용으로 각 도시에 나의 콘를 Caching할 수 있다니.. 그럼 놀라움은 잠시 뒤로 하고 다음 서비스를 알아보자.</p>
<h2>Amazon S3</h2>
<p>흔히 우리가 Storage 기능을 한다고 알고있는 S3다. 자세한 설명을 하지 않아도 이미 이해하고 있었지만, 내가 하고 있는 이해는 경험에 의한 것이기 때문에 오늘을 기회로 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html">Amazon S3란 무엇입니까?</a>를 읽어보도록 하자.</p>
<p>아무래도 Storage 기능만을 제공하기 때문에 매우 짧다. 그래서 다음의 한 박스로 이를 이해할 수 있겠다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Simple Storage Service는 인터넷용 스토리지 서비스입니다.
이 서비스는 개발자가 더 쉽게 웹 규모 컴퓨팅 작업을 수행할 수 있도록 설계되었습니다.

Amazon S3에서 제공하는 단순한 웹 서비스 인터페이스를 사용하여 웹에서 언제 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있습니다.

또한, 개발자는 Amazon이 자체 웹 사이트의 글로벌 네트워크 운영에 사용하는 것과 같은 높은 확장성과 신뢰성을 갖춘 빠르고 경제적인 데이터 스토리지
인프라에 액세스할 수 있습니다. 이 서비스의 목적은 규모의 이점을 극대화하고 개발자들에게 이러한 이점을 제공하는 것입니다.

이 가이드는 버킷 및 객체와 같은 Amazon S3의 핵심 개념과, Amazon S3 애플리케이션 프로그래밍 인터페이스(API)를 사용하여 이러한 리소스에 대한
작업 방법을 설명합니다.</code></pre></div>
<p>S3는 Storage의 기능을 하며 버킷이라고 부르는 단위를 통해 정적 파일을 관리한다는 것을 이해했다. 더불어 콘솔을 통해 제공되는 인터페이스를 활용하거나 API를 통해 코드에서의 활용도 가능할 것이라는 것을 이해할 수 있었다. 구글 드라이브인데 개발에 활용할 수 있겠다!</p>
<h2>Elastic Load Balancing(ELB)</h2>
<p>ELB는 로드 밸런싱이라고 부르는 작업을 해주는 서비스로 이해하고 있다. 이것도 지극히 경험적인 이해이므로 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/userguide/what-is-load-balancing.html">Elastic Load Balancing란 무엇입니까?</a>를 통해서 정확하게 이해해보자.</p>
<p>일반적으로 로드 밸런싱이라 하면 트래픽을 분산하기 위해 사용한다고 이해하고 있다. 이에 대한 자세한 내용은 <a href="https://ko.wikipedia.org/wiki/%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0">부하분산</a>을 통해 알아보도록 하고 이 글에서는 ELB를 알아보도록 하자. 문서에 따른 설명은 다음과 같다. 부가적으로 트래픽을 분산한다는 의미보다는 정해진 수의 CPU나 메모리같은 컴퓨팅 자원에게 작업을 나눠 제공한다고 이해하는 것이 바람직하겠다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Elastic Load Balancing는 Amazon EC2 인스턴스, 컨테이너 및 IP 주소와 같은 여러 대상에 대해 수신 애플리케이션 또는 네트워크 트래픽을 여러
가용 영역에 배포합니다.
애플리케이션에 대한 트래픽이 시간이 지남에 따라 변경되므로 Elastic Load Balancing가 로드 밸런서를 확장하고 대다수의 워크로드에 맞게 자동으로
조정할 수 있습니다.</code></pre></div>
<p>이를 보고 동적인 부하 분산이 가능하겠다고 생각했다. 가령 어떤 날에는 1의 트래픽이, 어떤 날에는 10의 트래픽이 들어오는 서비스에서 트래픽을 처리하려면 10의 가용량을 항상 가지고 있어야 하기 때문에 1의 트래픽이 들어오는 날에는 9의 자원 낭비가 생길 수 있을 것이다. 그런데 이를 동적으로 관리한다면, 들어오는 트래픽에 따라 가용 공간을 늘려 사용할 수 있을 것이기 때문에, 심지어 위 내용에서 '자동'으로 저장할 수 있기 때문에 자원의 낭비를 최소화할 것이라 생각할 수 있었다.</p>
<p>이런 생각은 문서에서도 나타나고 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">로드 밸런서 이점

로드 밸런서는 워크로드를 가상 서버와 같은 다수의 컴퓨팅 리소스로 분산합니다. 로드 밸런서를 사용하면 애플리케이션의 가용성과 내결함성이 높아집니다.

애플리케이션에 대한 요청의 전체적인 흐름을 방해하지 않고 필요에 따라 로드 밸런서에서 컴퓨팅 리소스를 추가 및 제거할 수 있습니다.

로드 밸런서가 정상적인 대상에만 요청을 보낼 수 있도록 컴퓨팅 리소스의 상태를 모니터링하는 데 사용되는 상태 확인을 구성할 수 있습니다.
또한 컴퓨팅 리소스가 주요 작업에 집중할 수 있도록 암호화 및 복호화 작업을 로드 밸런서로 오프로드할 수 있습니다.</code></pre></div>
<h2>Amazon EC2</h2>
<p>흔히 알고 있는 EC2의 경우에도 <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2란 무엇입니까?</a>를 통해 살펴보자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Elastic Compute Cloud(Amazon EC2)는 Amazon Web Services(AWS) 클라우드에서 확장식 컴퓨팅을 제공합니다. Amazon EC2를
사용하면 하드웨어에 선투자할 필요가 없어 더 빠르게 애플리케이션을 개발하고 배포할 수 있습니다. Amazon EC2를 통해 원하는 만큼 가상 서버를 구축하고
보안 및 네트워크 구성과 스토리지 관리가 가능합니다.

또한 Amazon EC2는 요구 사항이나 갑작스러운 인기 증대 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소할 수 있어 서버 트래픽 예측 필요성이
줄어듭니다.</code></pre></div>
<p>이번 정리를 통해 얻은 큰 수확 중 하나는 기존에 당연하게 사용하던 기술의 기능을 한 번에 정리하게 됐다는 점이다. EC2만 하더라도 가상 컴퓨팅 파워를 제공하는 것 외에도 다음과 같은 디테일한 기능을 가지고 있다는 것을 처음으로 알게되었기 때문이다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon EC2의 기능
Amazon EC2는 다음의 기능을 제공합니다.

- 인스턴스: 가상 컴퓨팅 환경
- Amazon 머신 이미지(AMI): 서버에 필요한 운영체제와 여러 소프트웨어들이 적절히 구성된 상태로 제공되는 템플릿으로 인스턴스를 쉽게 만들 수 있습니다.
- 인스턴스 유형: 인스턴스를 위한 CPU, 메모리, 스토리지, 네트워킹 용량의 여러 가지 구성 제공
- 키 페어를 사용하여 인스턴스 로그인 정보 보호(AWS는 퍼블릭 키를 저장하고 사용자는 개인 키를 안전한 장소에 보관하는 방식)
- 인스턴스 스토어 볼륨: 임시 데이터를 저장하는 스토리지 볼륨으로 인스턴스 종료 시 삭제됨
- Amazon Elastic Block Store(Amazon EBS), 즉 Amazon EBS 볼륨을 사용해 영구 스토리지 볼륨에 데이터 저장
- 인스턴스와 Amazon EBS 볼륨 등의 리소스를 다른 물리적 장소에서 액세스할 수 있는 지역 및 가용 영역
- 보안 그룹을 사용해 인스턴스에 연결할 수 있는 프로토콜, 포트, 소스 IP 범위를 지정하는 방화벽 기능
- 탄력적 IP 주소(EIP): 동적 클라우드 컴퓨팅을 위한 고정 IPv4 주소
- 태그: 사용자가 생성하여 Amazon EC2 리소스에 할당할 수 있는 메타데이터
- AWS 클라우드에서는 논리적으로 격리되어 있지만, 원할 때 마다 고객의 네트워크와 간편히 연결할 수 있는 가상 네트워크, Virtual Private Clouds
  (VPC)</code></pre></div>
<p>물론 이런 기능들의 디테일을 설정하기 위해서는 보다 많은 스킬업이 필요하겠지만, '가능하다' 정도만 이해하고 넘어가는 것도 나중에 트러블 슈팅, 비용 최적화 등을 위해 큰 도움이 될 것만 같다. 정말 좋다!</p>
<p>추가적으로 따로 단락을 만들어 언급하려 했던 <a href="https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html">Amazon EC2 Auto Scaling</a>을 간단히 소개해보자면, 다음과 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon EC2 Auto Scaling를 통해 애플리케이션의 로드를 처리할 수 있는 정확한 수의 Amazon EC2 인스턴스를 보유하도록 보장할 수 있습니다.

Auto Scaling 그룹이라는 EC2 인스턴스 모음을 생성합니다. 각 Auto Scaling 그룹의 최소 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto
Scaling에서는 그룹의 크기가 이 값 아래로 내려가지 않습니다. 각 Auto Scaling 그룹의 최대 인스턴스 수를 지정할 수 있으며, Amazon EC2
Auto Scaling에서는 그룹의 크기가 이 값을 넘지 않습니다. 원하는 용량을 지정한 경우 그룹을 생성한 다음에는 언제든지 Amazon EC2

Auto Scaling에서 해당 그룹에서 이만큼의 인스턴스를 보유할 수 있습니다. 조정 정책을 지정했다면 Amazon EC2 Auto Scaling에서는 애플리케이션의
늘어나거나 줄어드는 수요에 따라 인스턴스를 시작하거나 종료할 수 있습니다.</code></pre></div>
<p>Auto Scaling은 규모가 있는 서비스에서 필수적으로 필요할 것이라 생각된다. 왜냐하면 EC2의 인스턴스가 자동으로 스케일을 조정하는 경우는 트래픽이 많지 않으면 필요없을 것이라고 생각하기 때문이다.</p>
<p>하지만 이는 다소 편향된 생각이다. Auto-Scailing을 설정하지 않으면 만약 우리 서비스의 트래픽이 급격하게 증가하는 경우에는 서버가 버티지 못할 것이기 때문이다. 스타트업의 경우라면 만에 하나 있을 '대박'의 기회를 한순간에 놓칠 수도 있을 거라고 생각한다.</p>
<p>최소한의 인스턴스 수를 유지하면서 트래픽이 급격하게 증가할 경우에는 자동적으로 스케일 업을 진행하게 구현한다면 트래픽의 갑작스러운 변화에도 신속히 대응할 수 있을 것이라고 느꼈다. 문서에서는 다음과 같은 예시를 들어 이해를 돕는다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">예를 들어, 다음 Auto Scaling 그룹의 경우 최소 인스턴스 수 1개, 희망 인스턴스 용량 2개, 최대 인스턴스 수 4개가 됩니다. 사용자가 정의한 조정
정책에 따라 인스턴스 수가 최소 및 최대 인스턴스 수 내에서 지정하는 조건에 따라 조절됩니다.</code></pre></div>
<p><a
    class="gatsby-resp-image-link"
    href="/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 310px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 72.25806451612904%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACeUlEQVQoz31Ry27aUBC9f5NVpapdV/2HfkIfiy6qfkA/oJW6atJtd1VVJQISaAATcB48QgQ2YMBP7GtsHoEQWyQkUgLX07FJF120R8fjudI5c2fuEPiDIAgwmhZtSS1NVWS522y2Wi2J2n1F1bqy2ndc+BtkNnb82cT3fM/zr3xPrBYPOK56Wq2UKzyXLmRTqfg2Rp7bLx/l5rOxfzF64HRIpo0ktL+t8q9Z/hWrfYZRFVqfoPQWKu+B7sHwBIw4mLtgJ8E9YtouU3aY/JOpcWbmyaXMw9GbYJMAMvE8cErB9w08BlskqHwIzExgpgP7MNBigcWBHgeaA7sQVrR5ctnlgX+5+kLYJmGxZ+CU4McGfCUhQzPHkPYJ0/fCRIszq8DoIdMTQAtk1toH6WOw+xQST+D0HbhFyL6A7Uew8xgaW+AcAI1D/xdYO+DyYfM0EUYLzQdkrNfUGq/WjzXhWKrkLkxxPlA9V0HOh6otlTqllHya7lbSep2Xq9luZR+pnuU8WyLXixup0xUbzabUVnVjfn2DG2MAq2hzg9G43VU1o2eYtCaIimboPSqrhmaYS8aIYejFYlEUhEajYZq9er12fn6ONsawAtiUFosnnU47WnvD6OmCIJTLJUGoo4Dc399PJpPb29urCJ7nLRYLPM7nc9/30b9cLlcRMEHDOl+XJvh1Op1kMsnzfDab5TiuUCjkcrl8Pr82B//Ag/nu7k5RFMuyer0ediGKoq7rlNK14j8I29Y0zXGcfgT0YBwMBlgFc9u2MXddFwVY2oyA16AFBwxvxh8qRqPRMALacIRYLJZKpTKZDD4nDnJ2djadTlEzjoCPimP/Bqt9zXDfGFTyAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="auto-scailing"
        title=""
        src="/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png"
        srcset="/static/7b4c8ac32129aab596d7f10b471ac0c2/85daf/auto-scailing.png 163w,
/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png 310w"
        sizes="(max-width: 310px) 100vw, 310px"
      />
  </span>
  </a></p>
<h3>Amazon RDS</h3>
<p>대망의 마지막 서비스이다! 이 설명이 끝나면 이제 구현이 가능하다! <a href="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/Welcome.html">Amazon Relational Database Service(Amazon RDS)란 무엇입니까?</a>를 살펴보면, RDS를 다음과 같이 설명하고 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Relational Database Service(Amazon RDS)는 클라우드에서 관계형 데이터베이스를 더 쉽게 설치, 운영 및 확장할 수 있는 웹
서비스입니다. 이 서비스는 산업 표준 관계형 데이터베이스를 위한 경제적이고 크기 조절이 가능한 용량을 제공하고 공통 데이터베이스 관리 작업을 관리합니다.</code></pre></div>
<p>일반적인 RDB(Relatinal Database)를 구현하기 위해선 따로 DB 서버를 두거나 하나의 서버에 해당 SQL의 DBMS를 설치해 콘솔 혹은 별도의 GUI 프로그램을 사용해야 했다. 하지만 RDS는 모든 DBMS의 UI를 하나로 통합해 제공하기 때문에 DBMS의 변경, 이주(Migation), 통합(Integration) 등에서 발생하는 정신적 스트레스, 별도의 학습 코스트를 최소화할 수 있을 것이다. 더불어 RDS는 별도의 Database 관리가 없이도 모니터링, 테이블 변경 등의 처리를 할 수 있어 이를 통해 다양한 비용을 절약할 수 있을 것이다.</p>
<p>이러한 필자의 생각은 문서 하단의 설명에서도 나온다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon RDS의 개요

관리되는 관계형 데이터베이스 서비스가 필요한 이유는 무엇일까요? Amazon RDS가 어렵거나 지루한 관계형 데이터베이스 관리 작업을 대다수 대신하기
때문입니다.

- 서버를 구입하면 CPU, 메모리, 스토리지 및 IOPS가 모두 한데 묶여 제공됩니다. Amazon RDS를 사용하면 이 모두가 따로 분할되므로 독립적으로 확장할
  수 있습니다. CPU가 더 많이 필요하거나 IOPS가 더 적게 필요하거나 스토리지가 더 많이 필요할 경우 쉽게 할당할 수 있습니다.
- Amazon RDS는 백업, 소프트웨어 패치, 자동 장애 감지 및 복구를 관리합니다.
- 관리형 서비스 환경을 제공하기 위해 Amazon RDS는 DB 인스턴스에 대해 shell 액세스를 제공하지 않으며, 고급 권한을 필요로 하는 특정 시스템
  절차와 테이블에 대한 액세스를 제한합니다.
- 필요할 때 자동화된 백업을 수행하거나 고유한 백업 스냅샷을 수동으로 만들 수 있습니다. 이러한 백업을 사용하여 데이터베이스를 복원할 수 있습니다.
  Amazon RDS 복원 프로세스는 안정적이고 효율적입니다.
- 기본 인스턴스 및 문제 발생 시 장애 조치를 수행할 수 있는 동기식 보조 인스턴스에서 가용성을 높일 수 있습니다. MySQL, MariaDB 또는 PostgreSQL 읽기 전용 복제본을 사용해 읽기 조정을 높일 수도 있습니다.
- 이미 친숙한 MySQL, MariaDB, PostgreSQL, Oracle 및 Microsoft SQL Server 같은 데이터베이스 제품을 사용할 수 있습니다.
- 데이터베이스 패키지의 보안 외에도 AWS Identity and Access Management(IAM)을 사용해 사용자 및 권한을 정의하는 방법으로 RDS 데이터베이스에 액세스할 수 있는 사용자를 제어할 수 있습니다. 데이터베이스를 가상 사설 클라우드에 넣어 데이터베이스를 보호할 수도 있습니다.</code></pre></div>
<p>RDS에는 DB 인스턴스라는 단위가 존재한다. DB 인스턴스는 RDS의 기본 빌딩 블록(최소 단위)라고 할 수 있다. 더불어 DB 인스턴스는 클라우드에 존재하기 때문에 서비스와는 완전히 격리된 데이터베이스 환경이다. 그렇기 때문에 서비스 운영의 호환성을 고려하지 않아도 된다는 장점을 가지고 있다.</p>
<p>지금은 이정도만 이해하고 넘어가도 서비스를 사용함에 문제가 없다. 하지만, 더욱 자세한 설명을 원한다면 위에 제공된 링크를 통해 더욱 깊이 학습하도록 하자.</p>
<p>이제서야 이번 아키텍처에서 사용하는 모든 서비스를 정리할 수 있었다. 하지만, 아직 아키텍처의 전반적인 설명을 하지 않았기 때문에 이를 설명할 필요도 있다고 생각하기 때문에 지금까지의 내용을 정리할 겸 사용자의 흐름에 따라 다음과 같이 요약할 수 있다.</p>
<ol>
<li>
<p>유저는 DNS 응답(requests)를 하나의 고가용성 DNS 서비스인 Amazon Route53에 보낸다. 이때 네트워크 트래픽은 AWS에서 실행되는 인프라(Infrastructure)로 라우팅된다.</p>
</li>
<li>
<p>정적, 동적, 실시간 콘텐츠는 하나의 글로벌 엣지 로케이션(일종의 Conetns Cache) 네트워크인 CloudFront에 의해 전달된다. 이때 응답(requests)은 자동적으로 가장 가까운 엣지 로케이션으로 라우팅되고, 그래서 콘텐츠는 최적의 가용성을 가지고 전달된다.</p>
</li>
<li>
<p>자원(Resources)과 정적 콘텐츠는 미션 크리티컬 및 기본 데이터 스토리지를 위해 고안된 내구성이 뛰어난 스토리지 인프라인 S3 위에 적재된(stored) 웹 어플리케이션에 의해 사용된다.</p>
</li>
<li>
<p>HTTP 응답은 우선적으로 가용 영역(AZs)에서 다수의 Amazon Elastic Compute Cloud(EC2) 인스턴스로 들어오는 애플리케이션 트래픽을 자동으로 배분하는 ELB에 의해 처리(handled)되어진다.</p>
</li>
<li>
<p>웹 서버와 애플리케이션 서버는 EC2 위에서 배포되어진다. 여기서 대부분의 조직은 AMI(Amazon Machine Image)를 선택한 다음 필요에 맞게 사용자 정의합니다. 이 사용자 정의된(custom) AMI는 앞으로의 웹 개발의 출발점이 될 것이다.</p>
</li>
<li>
<p>웹 서버와 애플리케이션 서버는 Auto Scailing 그룹 안에서 배포되어진다. 이때 Auto Scaling은 정의한 조건에 따라 자동으로 용량을 늘리거나 줄이면서 조절합니다. Auto Scailing 기능을 사용하면 성능을 유지하기 위해 요구 사항이 급증 할 때 사용중인 EC2의 인스턴스의 수가 무사히 증가하고, 요구 사항이 발생하면 자동적으로 감소하여 비용을 최소화 할 수 있습니다.</p>
</li>
<li>
<p>고가용성을 제공하기 위해 어플리케이션 데이터가 포함된 관계형 데이터베이스는 RDS의 다중 가용구역(Multi-AZ, Master-Slave) 배포 위에서 중복적으로(redundantly) 호스팅된다.</p>
</li>
</ol>
<p>드디어 실습을 위한 사전 학습이 마무리됐다. 이 글 이후에는 실습을 위한 자료를 제공해 보다 나은 학습을 진행하고자 한다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_2</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_2</guid><pubDate>Mon, 25 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;AWS - Architecture study: WEB APPLICATION HOSTING&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;https://media.amazonwebservices.com/architecturecenter/AWS&lt;em&gt;ac&lt;/em&gt;ra&lt;em&gt;web&lt;/em&gt;01.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&quot;AWS Architecture 중에서 가장 기초적으로 구현할 수 있는 모델은 어떤 게 있을까?&quot;라는 고민이 있었는데, 이번 스터디를 진행하면서 그 부분을 해결할 수 있었다.&lt;/p&gt;
&lt;p&gt;물론, &apos;구현&apos;을 목적으로 한다면, 더 작은 아키텍처를 선정했을테지만, AWS를 제대로 사용하고, 이를 활용하는 수준을 목적으로 한다면 간단하지만 각 기능이 원활하게 돌아가는 아키텍처를 선정해야 한다는 생각이 있었다. 그래서 나는 이번 스터디를 기회로 AWS 아키텍처 센터에서 제공하고, 가장 처음 만나볼 수 있는 Web Application Hosting 아키텍처를 구현해보고자 했다.&lt;/p&gt;
&lt;p&gt;일단 위 PDF에 나와있는 서비스 중 내가 사용해본 서비스는 Route 53, S3, ELB, EC2, RDS가 있다. 하지만 이는 아키텍처를 고려하고 설계를 먼저 한 것이 아니라 필요에 의해서 하나하나 만들었을 뿐이었기 때문에 깊이가 부족하다고 느끼고 있어서 이번 기회에 제대로 알아보려 한다!&lt;/p&gt;
&lt;p&gt;설계는 이미 끝나있으니 구현을 해야 할텐데, 구현에 앞서 우선적으로 각 서비스가 어떤 것인지를 알아보도록 하자.&lt;/p&gt;
&lt;h2&gt;Amazon Route53&lt;/h2&gt;
&lt;p&gt;우선 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/Welcome.html&quot;&gt;Amazon Route 53란 무엇입니까?&lt;/a&gt;를 참고하도록 하자. 해당 참조에 의하면 도메인 등록, DNS 라우팅, 상태 확인의 3가지 주요 기능을 조합하여 실행할 수 있는 서비스라는 점이다. 각각 살펴보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 582px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 76.46048109965635%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACtUlEQVQoz01S2U7bQBTNz/Uj+AKkSqjvfaiqPlV9opuKKhaJh6JKhS5SBQIhWoizQFnq2I4dL2OPl8RrPN7t2HHtGChHM1eW55655849rXKB+QMUReF7cZ5kk6gwUIgcx7Jsd4rSJCvywlWVwDQaVqt8gIpZxShIzvZxmdWh6VMMpAYjAmdGNICSYU3co+dPu2vvmuSKPNfTktQsRQQcx6uaNrXRt+3u9fEfHjsZYhiJtekOxp73Br9OLFX5/uLZ742PNbkoWk25MI49D3meH0bh1EF7m2csDpuMKizKVB9l4KMBSXI8P8tmtWwnK9NinsRRUV1Sqy7jMN3dOJUoVYpKBhoiB0YML4mKh6LqLc6BSij6bc+yNZW1saoqURQ1v6Iw2ds8pXFZt5HAK0CQBV4WBFkEquuEyzsHLw87VVpVrHXR75EEAQAIwuCe/GOr3emzl1C+GPE9hu8zVeS6DCeOJ1uHJ1/b5/N8IZthRjzHaYqexGlDbmQLlFp1mRXzu0HU0Q98CAAUuDipk1sTS1TGojV21WkcZ+m8zBeyzwClAb8kOGM0FElCYEeyYUQhCsWb9RHVbS5syfrQdLQ8LYbSlKYB4KDr+F/WMarXV6TOBOIq25Potg4uTXjtW7Dz6VHnYLUR05rYgu3oeV6PZJbmRV46tnO83xUoinM0O7A8S9AgGSAlT4yxCvCLI+LyCHn1A7XMKbSm4zRK5Sh3gjBLE8syDWNi2nZ+13AjstoIeazAA0lK0kXP2SwRxwPfcwTLE6AMqjMg8rwAIXSRFwZRcIvQr+H97Lxt//1cj6p2WOWbyFUNmjXBm7XX2x9eVS5gxRtRpTSThePh/VJ02nCU9ztPdg9X/3u7Nui80PJy+fHKytISQeIYdoYTuGkZszxtVprFhjkZ0tTV1dVgMKh0IYT+AafFKBmlLOFpAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;dns-routing&quot;
        title=&quot;&quot;
        src=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png&quot;
        srcset=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/30e25/dns-routing.png 163w,
/static/e2f6fe34c52e613cd80585054ae48a2f/fedab/dns-routing.png 325w,
/static/e2f6fe34c52e613cd80585054ae48a2f/4977e/dns-routing.png 582w&quot;
        sizes=&quot;(max-width: 582px) 100vw, 582px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;도메인 등록은 우리가 흔히 알고 있는 것처럼 .com이나 .kr 등의 도메인을 자신만의 이름로 사용할 수 있게 해주는 서비스이다. Ex. &lt;a href=&quot;https://www.naver.com&quot;&gt;https://www.naver.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음으로 DNS 라우팅은 인터넷 트래픽을 도메인의 리소스로 라우팅하는 것을 말한다. 다시 말해 사용자의 요청이나 입력 등을 등록된 도메인에 전달하는 작업을 말하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;더불어 도메인의 형태가 항상 우리가 알고있는 www~로 시작하는 것만 존재하는 것이 아니라는 것에 유의하자. 우리가 흔히 알고있는 www는 World Wide Web의 약지로, 하나의 규격이다. 가령 &lt;a href=&quot;https://mail.google.com%EC%99%80&quot;&gt;https://mail.google.com와&lt;/a&gt; 같은 도메인의 사용도 가능하다는 것이다.&lt;/li&gt;
&lt;li&gt;그렇다면 위와 같이 모든 도메인을 따로 등록해야 할까? 그건 아니다. 가령 구글을 예로 들자면 구글의 모든 서비스를 Route 53을 통해 하나로 라우팅하고 싶다면 도메인 입력 란에 google.com만 입력하는 것도 방법이다. 이때 이를 최상위 도메인이라고 부를 수 있으며 앞선 메일 혹은 홈 페이지를 하위 도메인으로 설정할 수도 있다.&lt;/li&gt;
&lt;li&gt;DNS에 대한 자세한 내용은 &lt;a href=&quot;https://aws.amazon.com/ko/route53/what-is-dns/&quot;&gt;DNS란 무엇입니까?&lt;/a&gt;을 활용하도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 상태 확인은 통신되고 있는 리소스의 상태를 확인한다는 의미이다. 문서에 따르면 Route 53은 인터넷을 통해 웹 서버 같은 리소스로 자동화된 요청을 보내어 접근 및 사용이 가능하고, 정상 작동 중인지 확인하는 기능을 한다고 한다. 더불어 리소스를 사용할 수 없게 될 때 알림을 수신한다거나 (비정상 리소스가 아닌) 다른 곳으로 인터넷 트래픽을 라우팅할 수도 있다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Amazon CloudFront(CF)&lt;/h2&gt;
&lt;p&gt;CloudFront는 사용해보지 않았기 때문에 무척 궁금했다. 그래서 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html&quot;&gt;Amazon CloudFront란?&lt;/a&gt;을 참고하기로 했다. 문서에 따르면 &quot;Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다.&quot;라는 설명을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;잉? 이런 건 EC2를 통해서 하는 게 아니었나? 가만, 다시 살펴보니 &lt;strong&gt;정적 및 동적 웹 콘텐츠&lt;/strong&gt;라는 단어가 신경쓰인다. 그렇구나. 이건 내 웹 사이트의 contents에 해당하는 이야기구나! 그렇다면 소스 코드는 왜 있는 걸까? 조금 더 문서를 읽어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;CloudFront는 엣지 위치라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다.
CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 라우팅되므로 콘텐츠 전송 성능이 뛰어납니다.

- 콘텐츠가 이미 지연 시간이 가장 낮은 엣지에 있는 경우 CloudFront가 콘텐츠를 즉시 제공합니다.
- 콘텐츠가 엣지 로케이션에 없는 경우 CloudFront는 콘텐츠의 최종 버전에 대한 소스로 지정된 오리진(예: Amazon S3 버킷, MediaPackage 채널,
  HTTP 서버(예: 웹 서버) 등)에서 콘텐츠를 검색합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 글을 통해 &quot;엣지 로케이션이 contents에 대한 Cache 역할을 하는구나!&quot;라고 이해할 수 있었지만, 그럼에도 왜 EC2에서 할 수 있는 작업을 굳이 CloudFront에서 하는지 몰랐다. 하지만 이런 의문은 다음 문장을 통해 해결할 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;예를 들어, CloudFront가 아닌 일반적인 웹 서버에서 이미지를 제공한다고 가정합니다.
예를 들어 http://example.com/sunsetphoto.png URL을 사용하여 sunsetphoto.png라는 이미지를 서비스할 수 있습니다.

사용자는 이 URL로 쉽게 이동해 해당 이미지를 볼 수 있습니다. 하지만 이미지가 발견될 때까지 인터넷으로 이루어진 상호 연결된 네트워크의 복잡한 모음을
통해 네트워크에서 다른 네트워크로 요청이 라우팅되었다는 사실은 아마도 모르고 있을 것입니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 리다이렉션을 통해 사용자가 콘텐츠에 접근하게 될 경우 발생하는 비용을 줄이고자 하는 목적으로 사용될 수 있음을 암시하고 있다. 앞서 이해한 Cache의 개념을 조금 확장해 사용자의 입장에서 낮은 지연 시간으로 contents를 얻고, 비용을 절약하게 된다는 것을 이해했다!!&lt;/p&gt;
&lt;p&gt;이는 언뜻 보기에는 별 것 아닐 수도 있지만, 나에게 있어서는 놀라운 기술일 수밖에 없다. 앞서 언급한 &apos;비용&apos;에는 사용자 경험, 물리 장비, 인력 등 다양한 의미가 포함되어 있고, 이를 단번에 최적화한 기술이기 때문이다. 놀라움도 잠시 다음 문장을 통해서 이해를 다질 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;CloudFront는 AWS 백본 네트워크를 통해 콘텐츠를 가장 효과적으로 서비스할 수 있는 엣지로 각 사용자 요청을 라우팅하여 콘텐츠 배포 속도를 높입니다.
일반적으로 CloudFront 엣지가 최종 사용자에게 가장 빨리 제공합니다.
AWS 네트워크를 사용하면 사용자의 요청이 반드시 통과해야 하는 네트워크의 수가 줄어들어 성능이 향상됩니다.
파일의 첫 바이트를 로드하는 데 걸리는 지연 시간이 줄어들고 데이터 전송 속도가 빨라집니다.

또한 파일(객체라고도 함)의 사본이 전 세계 여러 엣지 로케이션에 유지(또는 캐시)되므로 안정성과 가용성이 향상됩니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정말 너무 환상적인 서비스군! 저렴한 비용으로 각 도시에 나의 콘를 Caching할 수 있다니.. 그럼 놀라움은 잠시 뒤로 하고 다음 서비스를 알아보자.&lt;/p&gt;
&lt;h2&gt;Amazon S3&lt;/h2&gt;
&lt;p&gt;흔히 우리가 Storage 기능을 한다고 알고있는 S3다. 자세한 설명을 하지 않아도 이미 이해하고 있었지만, 내가 하고 있는 이해는 경험에 의한 것이기 때문에 오늘을 기회로 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html&quot;&gt;Amazon S3란 무엇입니까?&lt;/a&gt;를 읽어보도록 하자.&lt;/p&gt;
&lt;p&gt;아무래도 Storage 기능만을 제공하기 때문에 매우 짧다. 그래서 다음의 한 박스로 이를 이해할 수 있겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Simple Storage Service는 인터넷용 스토리지 서비스입니다.
이 서비스는 개발자가 더 쉽게 웹 규모 컴퓨팅 작업을 수행할 수 있도록 설계되었습니다.

Amazon S3에서 제공하는 단순한 웹 서비스 인터페이스를 사용하여 웹에서 언제 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있습니다.

또한, 개발자는 Amazon이 자체 웹 사이트의 글로벌 네트워크 운영에 사용하는 것과 같은 높은 확장성과 신뢰성을 갖춘 빠르고 경제적인 데이터 스토리지
인프라에 액세스할 수 있습니다. 이 서비스의 목적은 규모의 이점을 극대화하고 개발자들에게 이러한 이점을 제공하는 것입니다.

이 가이드는 버킷 및 객체와 같은 Amazon S3의 핵심 개념과, Amazon S3 애플리케이션 프로그래밍 인터페이스(API)를 사용하여 이러한 리소스에 대한
작업 방법을 설명합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;S3는 Storage의 기능을 하며 버킷이라고 부르는 단위를 통해 정적 파일을 관리한다는 것을 이해했다. 더불어 콘솔을 통해 제공되는 인터페이스를 활용하거나 API를 통해 코드에서의 활용도 가능할 것이라는 것을 이해할 수 있었다. 구글 드라이브인데 개발에 활용할 수 있겠다!&lt;/p&gt;
&lt;h2&gt;Elastic Load Balancing(ELB)&lt;/h2&gt;
&lt;p&gt;ELB는 로드 밸런싱이라고 부르는 작업을 해주는 서비스로 이해하고 있다. 이것도 지극히 경험적인 이해이므로 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/userguide/what-is-load-balancing.html&quot;&gt;Elastic Load Balancing란 무엇입니까?&lt;/a&gt;를 통해서 정확하게 이해해보자.&lt;/p&gt;
&lt;p&gt;일반적으로 로드 밸런싱이라 하면 트래픽을 분산하기 위해 사용한다고 이해하고 있다. 이에 대한 자세한 내용은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0&quot;&gt;부하분산&lt;/a&gt;을 통해 알아보도록 하고 이 글에서는 ELB를 알아보도록 하자. 문서에 따른 설명은 다음과 같다. 부가적으로 트래픽을 분산한다는 의미보다는 정해진 수의 CPU나 메모리같은 컴퓨팅 자원에게 작업을 나눠 제공한다고 이해하는 것이 바람직하겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Elastic Load Balancing는 Amazon EC2 인스턴스, 컨테이너 및 IP 주소와 같은 여러 대상에 대해 수신 애플리케이션 또는 네트워크 트래픽을 여러
가용 영역에 배포합니다.
애플리케이션에 대한 트래픽이 시간이 지남에 따라 변경되므로 Elastic Load Balancing가 로드 밸런서를 확장하고 대다수의 워크로드에 맞게 자동으로
조정할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 보고 동적인 부하 분산이 가능하겠다고 생각했다. 가령 어떤 날에는 1의 트래픽이, 어떤 날에는 10의 트래픽이 들어오는 서비스에서 트래픽을 처리하려면 10의 가용량을 항상 가지고 있어야 하기 때문에 1의 트래픽이 들어오는 날에는 9의 자원 낭비가 생길 수 있을 것이다. 그런데 이를 동적으로 관리한다면, 들어오는 트래픽에 따라 가용 공간을 늘려 사용할 수 있을 것이기 때문에, 심지어 위 내용에서 &apos;자동&apos;으로 저장할 수 있기 때문에 자원의 낭비를 최소화할 것이라 생각할 수 있었다.&lt;/p&gt;
&lt;p&gt;이런 생각은 문서에서도 나타나고 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;로드 밸런서 이점

로드 밸런서는 워크로드를 가상 서버와 같은 다수의 컴퓨팅 리소스로 분산합니다. 로드 밸런서를 사용하면 애플리케이션의 가용성과 내결함성이 높아집니다.

애플리케이션에 대한 요청의 전체적인 흐름을 방해하지 않고 필요에 따라 로드 밸런서에서 컴퓨팅 리소스를 추가 및 제거할 수 있습니다.

로드 밸런서가 정상적인 대상에만 요청을 보낼 수 있도록 컴퓨팅 리소스의 상태를 모니터링하는 데 사용되는 상태 확인을 구성할 수 있습니다.
또한 컴퓨팅 리소스가 주요 작업에 집중할 수 있도록 암호화 및 복호화 작업을 로드 밸런서로 오프로드할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Amazon EC2&lt;/h2&gt;
&lt;p&gt;흔히 알고 있는 EC2의 경우에도 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html&quot;&gt;Amazon EC2란 무엇입니까?&lt;/a&gt;를 통해 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Elastic Compute Cloud(Amazon EC2)는 Amazon Web Services(AWS) 클라우드에서 확장식 컴퓨팅을 제공합니다. Amazon EC2를
사용하면 하드웨어에 선투자할 필요가 없어 더 빠르게 애플리케이션을 개발하고 배포할 수 있습니다. Amazon EC2를 통해 원하는 만큼 가상 서버를 구축하고
보안 및 네트워크 구성과 스토리지 관리가 가능합니다.

또한 Amazon EC2는 요구 사항이나 갑작스러운 인기 증대 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소할 수 있어 서버 트래픽 예측 필요성이
줄어듭니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이번 정리를 통해 얻은 큰 수확 중 하나는 기존에 당연하게 사용하던 기술의 기능을 한 번에 정리하게 됐다는 점이다. EC2만 하더라도 가상 컴퓨팅 파워를 제공하는 것 외에도 다음과 같은 디테일한 기능을 가지고 있다는 것을 처음으로 알게되었기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon EC2의 기능
Amazon EC2는 다음의 기능을 제공합니다.

- 인스턴스: 가상 컴퓨팅 환경
- Amazon 머신 이미지(AMI): 서버에 필요한 운영체제와 여러 소프트웨어들이 적절히 구성된 상태로 제공되는 템플릿으로 인스턴스를 쉽게 만들 수 있습니다.
- 인스턴스 유형: 인스턴스를 위한 CPU, 메모리, 스토리지, 네트워킹 용량의 여러 가지 구성 제공
- 키 페어를 사용하여 인스턴스 로그인 정보 보호(AWS는 퍼블릭 키를 저장하고 사용자는 개인 키를 안전한 장소에 보관하는 방식)
- 인스턴스 스토어 볼륨: 임시 데이터를 저장하는 스토리지 볼륨으로 인스턴스 종료 시 삭제됨
- Amazon Elastic Block Store(Amazon EBS), 즉 Amazon EBS 볼륨을 사용해 영구 스토리지 볼륨에 데이터 저장
- 인스턴스와 Amazon EBS 볼륨 등의 리소스를 다른 물리적 장소에서 액세스할 수 있는 지역 및 가용 영역
- 보안 그룹을 사용해 인스턴스에 연결할 수 있는 프로토콜, 포트, 소스 IP 범위를 지정하는 방화벽 기능
- 탄력적 IP 주소(EIP): 동적 클라우드 컴퓨팅을 위한 고정 IPv4 주소
- 태그: 사용자가 생성하여 Amazon EC2 리소스에 할당할 수 있는 메타데이터
- AWS 클라우드에서는 논리적으로 격리되어 있지만, 원할 때 마다 고객의 네트워크와 간편히 연결할 수 있는 가상 네트워크, Virtual Private Clouds
  (VPC)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론 이런 기능들의 디테일을 설정하기 위해서는 보다 많은 스킬업이 필요하겠지만, &apos;가능하다&apos; 정도만 이해하고 넘어가는 것도 나중에 트러블 슈팅, 비용 최적화 등을 위해 큰 도움이 될 것만 같다. 정말 좋다!&lt;/p&gt;
&lt;p&gt;추가적으로 따로 단락을 만들어 언급하려 했던 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html&quot;&gt;Amazon EC2 Auto Scaling&lt;/a&gt;을 간단히 소개해보자면, 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon EC2 Auto Scaling를 통해 애플리케이션의 로드를 처리할 수 있는 정확한 수의 Amazon EC2 인스턴스를 보유하도록 보장할 수 있습니다.

Auto Scaling 그룹이라는 EC2 인스턴스 모음을 생성합니다. 각 Auto Scaling 그룹의 최소 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto
Scaling에서는 그룹의 크기가 이 값 아래로 내려가지 않습니다. 각 Auto Scaling 그룹의 최대 인스턴스 수를 지정할 수 있으며, Amazon EC2
Auto Scaling에서는 그룹의 크기가 이 값을 넘지 않습니다. 원하는 용량을 지정한 경우 그룹을 생성한 다음에는 언제든지 Amazon EC2

Auto Scaling에서 해당 그룹에서 이만큼의 인스턴스를 보유할 수 있습니다. 조정 정책을 지정했다면 Amazon EC2 Auto Scaling에서는 애플리케이션의
늘어나거나 줄어드는 수요에 따라 인스턴스를 시작하거나 종료할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Auto Scaling은 규모가 있는 서비스에서 필수적으로 필요할 것이라 생각된다. 왜냐하면 EC2의 인스턴스가 자동으로 스케일을 조정하는 경우는 트래픽이 많지 않으면 필요없을 것이라고 생각하기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 이는 다소 편향된 생각이다. Auto-Scailing을 설정하지 않으면 만약 우리 서비스의 트래픽이 급격하게 증가하는 경우에는 서버가 버티지 못할 것이기 때문이다. 스타트업의 경우라면 만에 하나 있을 &apos;대박&apos;의 기회를 한순간에 놓칠 수도 있을 거라고 생각한다.&lt;/p&gt;
&lt;p&gt;최소한의 인스턴스 수를 유지하면서 트래픽이 급격하게 증가할 경우에는 자동적으로 스케일 업을 진행하게 구현한다면 트래픽의 갑작스러운 변화에도 신속히 대응할 수 있을 것이라고 느꼈다. 문서에서는 다음과 같은 예시를 들어 이해를 돕는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;예를 들어, 다음 Auto Scaling 그룹의 경우 최소 인스턴스 수 1개, 희망 인스턴스 용량 2개, 최대 인스턴스 수 4개가 됩니다. 사용자가 정의한 조정
정책에 따라 인스턴스 수가 최소 및 최대 인스턴스 수 내에서 지정하는 조건에 따라 조절됩니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 310px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 72.25806451612904%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACeUlEQVQoz31Ry27aUBC9f5NVpapdV/2HfkIfiy6qfkA/oJW6atJtd1VVJQISaAATcB48QgQ2YMBP7GtsHoEQWyQkUgLX07FJF120R8fjudI5c2fuEPiDIAgwmhZtSS1NVWS522y2Wi2J2n1F1bqy2ndc+BtkNnb82cT3fM/zr3xPrBYPOK56Wq2UKzyXLmRTqfg2Rp7bLx/l5rOxfzF64HRIpo0ktL+t8q9Z/hWrfYZRFVqfoPQWKu+B7sHwBIw4mLtgJ8E9YtouU3aY/JOpcWbmyaXMw9GbYJMAMvE8cErB9w08BlskqHwIzExgpgP7MNBigcWBHgeaA7sQVrR5ctnlgX+5+kLYJmGxZ+CU4McGfCUhQzPHkPYJ0/fCRIszq8DoIdMTQAtk1toH6WOw+xQST+D0HbhFyL6A7Uew8xgaW+AcAI1D/xdYO+DyYfM0EUYLzQdkrNfUGq/WjzXhWKrkLkxxPlA9V0HOh6otlTqllHya7lbSep2Xq9luZR+pnuU8WyLXixup0xUbzabUVnVjfn2DG2MAq2hzg9G43VU1o2eYtCaIimboPSqrhmaYS8aIYejFYlEUhEajYZq9er12fn6ONsawAtiUFosnnU47WnvD6OmCIJTLJUGoo4Dc399PJpPb29urCJ7nLRYLPM7nc9/30b9cLlcRMEHDOl+XJvh1Op1kMsnzfDab5TiuUCjkcrl8Pr82B//Ag/nu7k5RFMuyer0ediGKoq7rlNK14j8I29Y0zXGcfgT0YBwMBlgFc9u2MXddFwVY2oyA16AFBwxvxh8qRqPRMALacIRYLJZKpTKZDD4nDnJ2djadTlEzjoCPimP/Bqt9zXDfGFTyAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;auto-scailing&quot;
        title=&quot;&quot;
        src=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png&quot;
        srcset=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/85daf/auto-scailing.png 163w,
/static/7b4c8ac32129aab596d7f10b471ac0c2/5a54c/auto-scailing.png 310w&quot;
        sizes=&quot;(max-width: 310px) 100vw, 310px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Amazon RDS&lt;/h3&gt;
&lt;p&gt;대망의 마지막 서비스이다! 이 설명이 끝나면 이제 구현이 가능하다! &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/Welcome.html&quot;&gt;Amazon Relational Database Service(Amazon RDS)란 무엇입니까?&lt;/a&gt;를 살펴보면, RDS를 다음과 같이 설명하고 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Relational Database Service(Amazon RDS)는 클라우드에서 관계형 데이터베이스를 더 쉽게 설치, 운영 및 확장할 수 있는 웹
서비스입니다. 이 서비스는 산업 표준 관계형 데이터베이스를 위한 경제적이고 크기 조절이 가능한 용량을 제공하고 공통 데이터베이스 관리 작업을 관리합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반적인 RDB(Relatinal Database)를 구현하기 위해선 따로 DB 서버를 두거나 하나의 서버에 해당 SQL의 DBMS를 설치해 콘솔 혹은 별도의 GUI 프로그램을 사용해야 했다. 하지만 RDS는 모든 DBMS의 UI를 하나로 통합해 제공하기 때문에 DBMS의 변경, 이주(Migation), 통합(Integration) 등에서 발생하는 정신적 스트레스, 별도의 학습 코스트를 최소화할 수 있을 것이다. 더불어 RDS는 별도의 Database 관리가 없이도 모니터링, 테이블 변경 등의 처리를 할 수 있어 이를 통해 다양한 비용을 절약할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이러한 필자의 생각은 문서 하단의 설명에서도 나온다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon RDS의 개요

관리되는 관계형 데이터베이스 서비스가 필요한 이유는 무엇일까요? Amazon RDS가 어렵거나 지루한 관계형 데이터베이스 관리 작업을 대다수 대신하기
때문입니다.

- 서버를 구입하면 CPU, 메모리, 스토리지 및 IOPS가 모두 한데 묶여 제공됩니다. Amazon RDS를 사용하면 이 모두가 따로 분할되므로 독립적으로 확장할
  수 있습니다. CPU가 더 많이 필요하거나 IOPS가 더 적게 필요하거나 스토리지가 더 많이 필요할 경우 쉽게 할당할 수 있습니다.
- Amazon RDS는 백업, 소프트웨어 패치, 자동 장애 감지 및 복구를 관리합니다.
- 관리형 서비스 환경을 제공하기 위해 Amazon RDS는 DB 인스턴스에 대해 shell 액세스를 제공하지 않으며, 고급 권한을 필요로 하는 특정 시스템
  절차와 테이블에 대한 액세스를 제한합니다.
- 필요할 때 자동화된 백업을 수행하거나 고유한 백업 스냅샷을 수동으로 만들 수 있습니다. 이러한 백업을 사용하여 데이터베이스를 복원할 수 있습니다.
  Amazon RDS 복원 프로세스는 안정적이고 효율적입니다.
- 기본 인스턴스 및 문제 발생 시 장애 조치를 수행할 수 있는 동기식 보조 인스턴스에서 가용성을 높일 수 있습니다. MySQL, MariaDB 또는 PostgreSQL 읽기 전용 복제본을 사용해 읽기 조정을 높일 수도 있습니다.
- 이미 친숙한 MySQL, MariaDB, PostgreSQL, Oracle 및 Microsoft SQL Server 같은 데이터베이스 제품을 사용할 수 있습니다.
- 데이터베이스 패키지의 보안 외에도 AWS Identity and Access Management(IAM)을 사용해 사용자 및 권한을 정의하는 방법으로 RDS 데이터베이스에 액세스할 수 있는 사용자를 제어할 수 있습니다. 데이터베이스를 가상 사설 클라우드에 넣어 데이터베이스를 보호할 수도 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RDS에는 DB 인스턴스라는 단위가 존재한다. DB 인스턴스는 RDS의 기본 빌딩 블록(최소 단위)라고 할 수 있다. 더불어 DB 인스턴스는 클라우드에 존재하기 때문에 서비스와는 완전히 격리된 데이터베이스 환경이다. 그렇기 때문에 서비스 운영의 호환성을 고려하지 않아도 된다는 장점을 가지고 있다.&lt;/p&gt;
&lt;p&gt;지금은 이정도만 이해하고 넘어가도 서비스를 사용함에 문제가 없다. 하지만, 더욱 자세한 설명을 원한다면 위에 제공된 링크를 통해 더욱 깊이 학습하도록 하자.&lt;/p&gt;
&lt;p&gt;이제서야 이번 아키텍처에서 사용하는 모든 서비스를 정리할 수 있었다. 하지만, 아직 아키텍처의 전반적인 설명을 하지 않았기 때문에 이를 설명할 필요도 있다고 생각하기 때문에 지금까지의 내용을 정리할 겸 사용자의 흐름에 따라 다음과 같이 요약할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;유저는 DNS 응답(requests)를 하나의 고가용성 DNS 서비스인 Amazon Route53에 보낸다. 이때 네트워크 트래픽은 AWS에서 실행되는 인프라(Infrastructure)로 라우팅된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정적, 동적, 실시간 콘텐츠는 하나의 글로벌 엣지 로케이션(일종의 Conetns Cache) 네트워크인 CloudFront에 의해 전달된다. 이때 응답(requests)은 자동적으로 가장 가까운 엣지 로케이션으로 라우팅되고, 그래서 콘텐츠는 최적의 가용성을 가지고 전달된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자원(Resources)과 정적 콘텐츠는 미션 크리티컬 및 기본 데이터 스토리지를 위해 고안된 내구성이 뛰어난 스토리지 인프라인 S3 위에 적재된(stored) 웹 어플리케이션에 의해 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 응답은 우선적으로 가용 영역(AZs)에서 다수의 Amazon Elastic Compute Cloud(EC2) 인스턴스로 들어오는 애플리케이션 트래픽을 자동으로 배분하는 ELB에 의해 처리(handled)되어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 서버와 애플리케이션 서버는 EC2 위에서 배포되어진다. 여기서 대부분의 조직은 AMI(Amazon Machine Image)를 선택한 다음 필요에 맞게 사용자 정의합니다. 이 사용자 정의된(custom) AMI는 앞으로의 웹 개발의 출발점이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 서버와 애플리케이션 서버는 Auto Scailing 그룹 안에서 배포되어진다. 이때 Auto Scaling은 정의한 조건에 따라 자동으로 용량을 늘리거나 줄이면서 조절합니다. Auto Scailing 기능을 사용하면 성능을 유지하기 위해 요구 사항이 급증 할 때 사용중인 EC2의 인스턴스의 수가 무사히 증가하고, 요구 사항이 발생하면 자동적으로 감소하여 비용을 최소화 할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고가용성을 제공하기 위해 어플리케이션 데이터가 포함된 관계형 데이터베이스는 RDS의 다중 가용구역(Multi-AZ, Master-Slave) 배포 위에서 중복적으로(redundantly) 호스팅된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;드디어 실습을 위한 사전 학습이 마무리됐다. 이 글 이후에는 실습을 위한 자료를 제공해 보다 나은 학습을 진행하고자 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 아키텍처 - Web Application Hosting 1]]></title><description><![CDATA[<h1>AWS 아키텍처 - Web Application Hosting</h1>
<p>What is <code class="language-text">Web-Application Hosting</code> in <a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">AWS Reference Architecture</a>?</p>
<div class="gatsby-highlight" data-language="english"><pre class="language-english"><code class="language-english">Highly available and scalable web hosting can be complex and expensive.
Dense peak periods and wild swings in traffic patterns result in low utilization of expensive hardware.

Amazon Web Services provides the reliable, scalable, secure, and high- performance infrastructure required for web applications while enabling an elastic, scale-out and scale-down infrastructure to match IT costs in real time as customer traffic fluctuates.</code></pre></div>
<p><a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">AWS Reference Architecture</a>에서 제공하는 <code class="language-text">Web-Application Hosting</code>은 무엇일까?</p>
<div class="gatsby-highlight" data-language="korean"><pre class="language-korean"><code class="language-korean">고가용성 및 확장성 웹 호스팅은 복잡하고 비용이 많이 듭니다.
이는 트래픽 패턴이 짙어지면서 피크 시간이 길어지고 값 비싼 하드웨어의 사용률이 낮아집니다.

Amazon Web Services에서는 웹 애플리케이션에 필요한 안정적이고 확장 가능하며 안전한 고성능 인프라를 제공하는 동시에 고객 트래픽이 변동함에 따라 IT 비용을 실시간으로 일치시킬 수있는 유연한 스케일 아웃 및 축소형 인프라를 제공합니다.</code></pre></div>]]></description><link>https://rayleighko.github.io/blog/2019-02-12-aws_ac_web</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-12-aws_ac_web</guid><pubDate>Tue, 12 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;AWS 아키텍처 - Web Application Hosting&lt;/h1&gt;
&lt;p&gt;What is &lt;code class=&quot;language-text&quot;&gt;Web-Application Hosting&lt;/code&gt; in &lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;AWS Reference Architecture&lt;/a&gt;?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;english&quot;&gt;&lt;pre class=&quot;language-english&quot;&gt;&lt;code class=&quot;language-english&quot;&gt;Highly available and scalable web hosting can be complex and expensive.
Dense peak periods and wild swings in traffic patterns result in low utilization of expensive hardware.

Amazon Web Services provides the reliable, scalable, secure, and high- performance infrastructure required for web applications while enabling an elastic, scale-out and scale-down infrastructure to match IT costs in real time as customer traffic fluctuates.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;AWS Reference Architecture&lt;/a&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;Web-Application Hosting&lt;/code&gt;은 무엇일까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;korean&quot;&gt;&lt;pre class=&quot;language-korean&quot;&gt;&lt;code class=&quot;language-korean&quot;&gt;고가용성 및 확장성 웹 호스팅은 복잡하고 비용이 많이 듭니다.
이는 트래픽 패턴이 짙어지면서 피크 시간이 길어지고 값 비싼 하드웨어의 사용률이 낮아집니다.

Amazon Web Services에서는 웹 애플리케이션에 필요한 안정적이고 확장 가능하며 안전한 고성능 인프라를 제공하는 동시에 고객 트래픽이 변동함에 따라 IT 비용을 실시간으로 일치시킬 수있는 유연한 스케일 아웃 및 축소형 인프라를 제공합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[2019 02, 필자 소개]]></title><description><![CDATA[<h1>간략 필자 소개 - for Korean</h1>
<p><a href="/README.md">뒤로가기</a></p>
<p><a href="http://hits.dwyl.io/rayleighko/training/resume"><img src="http://hits.dwyl.io/rayleighko/training/resume.svg" alt="HitCount"></a></p>
<p><a href="https://sourcerer.io/rayleighko"><img src="https://avatars2.githubusercontent.com/u/24822072?v=4" height="50px" width="50px" alt=""></a></p>
<p><a href="https://sourcerer.io/rayleighko">Sourcerer profile</a></p>
<h4>좌우명: <a href="https://en.wikipedia.org/wiki/Lifelong_learning">평생학습(Lifelong learning)</a>, <a href="https://bit.ly/2E22Als">민이호학 불치하문(敏而好學 不恥下問)</a></h4>
<p>개발이라는 분야만이 아닌 서비스 구현의 전반적인 워크 플로우를 공부하는 프로그래머가 되고자 합니다. 이를 위해 더나은 경험을 추구하며, 기술적으로 성장하는 것을 좋아합니다. 더불어 모든 일은 체계적으로 하거나, 다양한 의견을 수용해 최적의 결과를 만들 때 가장 큰 성취감을 느끼곤 합니다.</p>
<p>현재는 학업에 집중하고자 NineVR이라는 VR 스타트업에서 퇴사하고, 가벼운 프로젝트를 만들며 다음 학기를 준비하고 있습니다(2020. 2 졸업 예정).</p>
<blockquote>
<p>최근 사용한 언어 및 라이브러리: Node, Javascript(React, Redux, etc.), CSS3(SCSS, StyledComponents), HTML5(JSX)</p>
</blockquote>
<p>제가 추구하는 성향의 개발자는 Development만이 아닌 Operation까지도 생각하는 개발자이기 때문에 그에 따른 다양한 툴과 언어를 편식없이 학습하고 있습니다.</p>
<p>최근(2018. 12 ~ 2019. 02)에는 가장 활발한 발전을 이루고 있다고 생각되는 Javascript에 매력을 느껴 이를 이용하여 React를 활용한 <a href="https://github.com/teamthesol/boggler">프로젝트1</a>과 Node를 활용한 <a href="https://github.com/teamthesol/node-DeepSpeech">프로젝트 2</a>를 진행했습니다.</p>
<p>이와는 별개로 <a href="https://github.com/rayleighko/ml_study">머신러닝 스터디(2018. 06)</a>를 진행하며 머신러닝에 대해서도 관심이 있습니다.</p>
<blockquote>
<p>선호하는 개발 환경: MacOS(Zsh, Bash), Linux(Ubuntu), Opensource<br>
선호하는 도구: AWS, React, Node<br>
최근 관심있는 도구: CI(TravisCI, CircleCI 등), Container(Docker, Kubernetes)</p>
</blockquote>
<p>이렇게 다양한 도구를 사용하고, 이것저것 공부하는 이유는 제가 생각하는 개발자라는 직업은 배움을 게을리하지 않고, 무언가를 만들기 위해 다양한 경험을 해야 한다고 생각하기 때문입니다. 그래서 때로는 잡다하게 공부했다는 생각이 들 때가 있었습니다. 하지만 그 생각도 잠시 배움을 즐기고 있는 저 자신의 모습이 행복하기 때문에 지금까지, 그리고 앞으로도 후회없이 다양한 기술을 학습하고자 합니다.</p>
<h2>직무 관련 주제 별 활동 정리</h2>
<h3>참여한 재능기부 및 대외활동</h3>
<p><strong>2013. 07. 01 ~ 2013. 07. 15</strong>: 말레이시아 IT 봉사단 'Comma' - IT STAFF<br>
<strong>2017. 02. 27 ~ 2017. 05. 29</strong>: 스타트업캠퍼스, Signature Course 2nd - Tech Lab(개발자)<br>
<strong>2017. 05. 23</strong>: 5월, 소프트웨어에 물들다 - 의정부 어린이도서관(STAFF)<br>
<strong>2017. 12. 27</strong>: DevOps Korea meetup - STAFF<br>
<strong>2018. 01. 29 ~ 2018. 03. 16</strong>: 평창 Olympic/Pralympic - Passion Craw(IT STAFF)</p>
<p><strong>2018. 04. 01 ~ 현재</strong>: Djangogirls Seoul - Organizer<br>
<strong>2018. 08. 12 ~ 현재</strong>: AWS(KRUG) University Student Group - Member</p>
<h3>근무 및 아르바이트 경력</h3>
<p><strong>2017. 04. ~ 2017. 08</strong>: 프로젝트 HongU - Web Software Developer<br>
<strong>2017. 06. ~ 2017. 10. 13</strong>: 패스트캠퍼스 - OpenCV와 함께하는 컴퓨터 비전 캠프 조교<br>
<strong>2018. 08. 20 ~ 11. 20</strong>: 나인브이알 - (Contents) Software Engineer&#x3C;UE4을 활용한 클라이언트 게임 개발 및 사내 개발 인프라 관리></p>
<h3>공모전 및 수상 경력</h3>
<p><strong>2017. 09. 28 ~ 12. 21</strong>: (비공식) 컨트리뷰톤, uftrace/perf – 오픈소스 Contributor, 우수상(2등)<br>
<strong>2018. 08. 16 ~ 10. 25</strong>: (공식) 컨트리뷰톤, gitShare – 오픈소스 Contributor, 우수상(2등)<br>
<strong>2019. 01. 08 ~ 02. 27</strong>: (공식) 네이버 D2 CAMPUS FEST, boggler – 오픈소스 Maintainer로써 결승 진출</p>
<h3>입영기록</h3>
<p><strong>2014. 02. 25 ~ 2015. 11. 24</strong>: 대한민국 해병대(1사단) - 네트워크 관리/운용병, 전산/체계 관리/운용병</p>
<h3>보유 자격증</h3>
<p><strong>2017. 12. 24</strong>: DAsP(데이터아키텍처 준전문가) - 데이터진흥원<br>
<strong>2017. 12. 23</strong>: 리눅스마스터 2급 - 한국정보통신진흥협회</p>
<h2>최근에 진행한 프로젝트 3개(맡은 역할, 인원 수, 기간, 내용 등)</h2>
<h3>2018. 04. 01 ~ 2018. 11. 21: 강의 공유 플랫폼, Athena v1.0.0(4명) - Front-end(일부), Back-end(일부)</h3>
<blockquote>
<p>사용한 도구: React(Mobx), Node(Express, SocketIO), AWS(EC2, Route53, RDS), Git(GitKraken, Gitlab)</p>
</blockquote>
<p>이번 프로젝트의 시작은 수강했던 강의의 한 학생의 불편함이었습니다. 그 학생은 장애를 가지고 있어 수업을 듣기 위해서는 누군가의 도움이 필요했고, 그 도움조차 그 학생의 학습을 완벽히 도울 수는 없었습니다.</p>
<p>그래서 그 학생에게 도움이 되고자 그를 위한 프로젝트를 만들었습니다. - 3주 정도 서비스 후 서비스 유지비를 고려해 무기한 폐지하게 되었습니다.</p>
<p>작업물의 완성도는 낮았지만, 프로젝트를 진행하며 DevOps를 위해서는 안정적인 Development가 선행되어야 한다는 것을 깨닫게 되었습니다. 그래야 Operation을 위한 제대로 된 서비스를 제공할 수 있다는 것을 깨닫게 되었습니다.</p>
<p>뿐만 아니라 작업물의 완성을 목표로 진행했기 때문에 소스코드의 질이 떨어졌습니다. 이에 리펙토링의 필요성을 느꼈고, 프로젝트를 하나하나 수정하는 것보다 새로운 프로젝트를 만드는 것이 나을 것 같다고 생각해 새로운 프로젝트(Boggle)를 만들게 되었습니다.</p>
<p>결과적으로는 운영에 실패해 접게 되었지만, 생애 처음으로 구현부터 서비스 운영까지 진행하는 프로젝트를 경험했다는 중요한 경험이었습니다.</p>
<p><strong>프로젝트 소스코드 주소</strong>: <a href="https://github.com/rayleighChild/athena">https://github.com/rayleighChild/athena</a><br>
<strong>진행 간 부족한 점 피드백</strong>: <a href="https://github.com/rayleighChild/athena_FAQ">https://github.com/rayleighChild/athena_FAQ</a></p>
<h3>2018. 12. 26 ~ 2019. 02. 20: 음성인식 기반 메모 플랫폼, Boggler v1.0.0(3명) - Front-end(주도), Design(주도)</h3>
<blockquote>
<p>사용한 도구: React(Redux, ...), Node(Express, ...), Git(GitKraken, GitHub, Git-Bash, ...), Editor(VSCode), Mozilla/DeepSpeech 등 여러 오픈소스 프로젝트 참고</p>
</blockquote>
<p>보글러의 가장 큰 핵심은 스트리밍 혹은 파일로 입력받은 음성 정보를 분석해 이를 텍스트로 변환시킨다는 점입니다. 가령 미팅에서의 가벼운 대화 혹은 강연자의 음성을 텍스트로 변환해 보다 나은 필사(글을 옮겨 적는) 환경을 제공합니다.</p>
<p>때때로 우리는 강의를 듣거나 중요한 일을 녹음합니다. 하지만, 이렇게 녹음된 자료는 텍스트로 옮겨 적어야 하는 불편함이 있었습니다. 더불어 이런 작업은 꼭 필요한 일이 아니라면 쉽게 잊혀지곤 합니다. 더불어 유료로 서비스를 이용해야 하기도 하죠!</p>
<p>이런 문제를 보완하기 위해 보글러는 음성을 텍스트로 변환하기 위한 작업의 피로를 줄이기 위한 도구로 만들어졌습니다.</p>
<p>저는 팀 내에서 프론트 엔드와 디자인을 담당했고, 전체적인 프로젝트 진행 방향과 구성원의 일정관리와 프로젝트 이슈 관리, 문서화 등을 주도적으로 진행하며 프로젝트 관리를 병행했습니다.</p>
<p>위의 두 프로젝트(Athena, Boggler)를 진행하며 느낀 핵심 키워드는 “사용하는 기술에는 정당한 이유가 필요하며, 회사에서 사용하는 모든 기술에는 정당한 이유가 있다”라는 깨달음이었습니다.</p>
<p>이를 통해 프로젝트를 진행하기 전에는 마냥 트랜드를 따라 개발하는 것이 옳은 줄 알았지만, 사실은 기본에 충실해 기능과 구현에 적절한 기술을 사용하는 것이 옳다는 것을 깨닳았고 기본에 충실해야 좋은 서비스를 만들 수 있다는 것을 알게 되었습니다.</p>
<p><strong>프로젝트 주소</strong>: <a href="https://github.com/rayleighChild/boggler">https://github.com/rayleighChild/boggler</a> - 현재 진행 중.</p>
<h3>2018. 01. 23 ~ 01. 28: Mozilla/DeepSpeech 기반 Nodejs 함수 Node Packcage(2명) - 프로젝트 설계 및 주도</h3>
<blockquote>
<p>사용한 도구: Node, Mozilla/DeepSpeech</p>
</blockquote>
<p>앞서 설명한 보글러에서 편하게 사용하기 위해 오픈 소스 기반 Speech Recognition(음성 인식) 서비스인 Mozilla/DeepSpeech의 기능을 Node 모듈로 만든 프로젝트입니다. 또한, 기존의 Mozilla/DeepSpeech에서 제공하는 NPM 모듈이 있었지만 터미널 기반으로 사용해야 했기에 이를 코드로 사용하면 좋겠다고 생각해 진행하게 되었습니다.</p>
<p>해당 프로젝트를 진행하면서 처음으로 package에 대한 전 과정을 설계, 구현했기 때문에 Node Package 퍼블리싱 경험을 통해 사용자의 피드백을 받을 수 있었으며, 사용자로부터의 요구사항에 맞게 프로젝트의 기능을 수정했던 경험이 기억에 남습니다. 가령 사용자의 요구였던 동기적으로 함수가 호출되어 결과를 반환하는 방식을 체택한 사례(<a href="https://github.com/teamthesol/node-DeepSpeech/issues/2">https://github.com/teamthesol/node-DeepSpeech/issues/2</a>)는 개인 프로젝트로 진행하는 것과는 또다른 경험을 얻을 수 있는 계기가 되었습니다.</p>
<p><strong>현 기준(2019. 02. 17) 총 다운로드 수: 931회</strong></p>
<p><strong>프로젝트 주소</strong>:　<a href="https://github.com/teamthesol/node-DeepSpeech">https://github.com/teamthesol/node-DeepSpeech</a></p>
<h2>가장 기억에 남는 문제 해결 사례 소개</h2>
<h3>1. 기능 구현 - 비동기적으로 구현되어 있는 함수를 동기적으로 구현하기 위해 수정한 사례</h3>
<h4>문제 정의</h4>
<p>: 앞서 소개한 STT 기반 프로젝트인 Node-DeepSpeech라는 프로젝트는 처음에 구현될 때(0.2.4 버전)만 해도 비동기적으로 사용자에게 제공되었습니다.</p>
<p>그래서 사용자의 입장에서는 인식된 음성 데이터의 전달은 원하고자 할 때 성공적으로 서버에 전달할 수 있었지만, 분석되어 전달받은 문자 데이터의 반환 시기를 알 수 없었습니다(<a href="https://github.com/teamthesol/node-DeepSpeech/issues/2">https://github.com/teamthesol/node-DeepSpeech/issues/2</a>).</p>
<h4>문제 해결 과정</h4>
<p>: 우선적으로 Node라는 언어의 메커니즘 자체가 단일 스레드 기반으로 클러스터링을 통해 마치 멀티 스레드 환경에서처럼 한 번에 여러 작업을 동시에 수행하고 있었기 때문에 일반적인 함수를 사용한다 하더라도 비동기적으로 사용되고 있었습니다.</p>
<p>이를 해결하기 위해서는 별도의 함수 혹은 키워드가 필요했고, 이를 해결하기 위해 구글에서 동기적으로 함수를 구현하는 방법을 찾아 결국에는 Stackoverflow를 통해 callback function, Promise, async/await의 3가지 문법을 활용하는 방법이 있다는 것을 알게 되었습니다.</p>
<p>첫 번째 방법인 callback function의 경우에는 callback hell이라고 부르는 고전적인 문제를 안고 있었기 때문에 체택할 수 없어 나머지 두 방법 중 하나인 Promise로 함수를 구현하는 방식을 체택하게 되었습니다.</p>
<h4>결론</h4>
<p>: 이번 사례를 통해 로컬에서만 개발하고 개인의 요구에 맞춰 기능을 구현하던 과거를 반성하게 되었고, 사용자의 요구를 실현한다는 것에 대한 안목이 생겼습니다.</p>
<p><strong>해결된 문제 링크</strong>
: <a href="https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df">https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df</a></p>
<h3>2. FrontEnd - 오디오 파일 분석을 통한 기능 구현 및 스타일링 사례</h3>
<h4>문제 정의</h4>
<p>: 링크를 통해 미디어(유튜브, 트위치, 음성 파일 등)를 제공하는 형태였던 기존의 방식을 사용자의 파일을 통해 이를 분석하여 웨이브(frequency wave)를 그려야했고, DeepSpeech를 적용하여 텍스트를 분석하는 로직이 필요했습니다.(<a href="https://github.com/teamthesol/boggler/issues/18">https://github.com/teamthesol/boggler/issues/18</a>)</p>
<h4>문제 해결 과정</h4>
<p>: 우선적으로 문제를 정의하는 과정에서 하나의 문제가 아닌 여러 개의 문제를 한 번에 해결하려 하는 것 같다고 느껴 이를 여러 문제로 정의할 필요성을 느끼게 되었습니다.</p>
<ol>
<li>Audio Frequency wave 그리기(기본 뼈대 제작): <a href="https://github.com/teamthesol/boggler/issues/31">https://github.com/teamthesol/boggler/issues/31</a></li>
<li>Editor 그리기(기본 뼈대 및 참고할 예시 코드 삽입): <a href="https://github.com/teamthesol/boggler/issues/30">https://github.com/teamthesol/boggler/issues/30</a></li>
</ol>
<p>각 과정에서는 기능을 나눠 기능과 스타일링을 구현했고, 우선적으로 기능 구현을 먼저 해결하려 했습니다. 1번 기능인 Audio Frequency wave의 틀을 먼저 만들고, 기능을 구현한 이후에 스타일링을 구현했습니다.</p>
<p>1번에서는 오픈 소스 중 하나인 waveform-react를 사용했고, 여기에 사용되는 오디오 파일을 버퍼로 디코드하는 로직과 이를 반환할 시점이 디코딩이 끝난 이후여야 했기에 동기적으로 구현되어야 했습니다.</p>
<p>이를 위해 async/await 방식을 체택해 기능을 동기적으로 구현했고, 이에 따라 분석된 버퍼 데이터를 waveform-react에 삽입해 Audio Frequency wave를 그릴 수 있었습니다.</p>
<p>이어서 2번 기능인 Editor에서는 에디터의 기능을 하게 될 textarea와 여기에 들어온 텍스트를 바탕으로 사용자에게 텍스트를 보여줄 Article 기능이 필요했습니다.</p>
<p>더불어 텍스트는 state로 관리해 사용자의 변경에 따라 해당 state가 변하게 구현해야 했고, 변화되는 것과 동시에 사용자에게 보여주는 Article에서도 rerender가 일어나야 했기 때문에 이에 대해서도 고려해야 했습니다.</p>
<h4>결론</h4>
<p>: 이번 사례를 통해 하나의 메서드는 하나의 문제만 해결해야 한다는 것을 깨닫게 되었고, 여러 문제가 섞인 이슈를 해결하기 위해서는 문제를 기능 단위로 나누는 것이 효율적이라는 것을 깨닫게 되었습니다.</p>
<p>더불어 문제를 해결할 때 어느정도의 설계가 있어야 효율적으로 기능을 구현할 수 있다는 알게되었습니다.</p>
<p><strong>해결된 문제 링크 1</strong></p>
<ul>
<li>기능 구현: <a href="https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7">https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3">https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3</a></li>
</ul>
<p><strong>해결된 문제 링크 2</strong></p>
<ul>
<li>Article 컴포넌트 구현: <a href="https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f">https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f</a></li>
<li>Editor 기능 구현1: <a href="https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628">https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628</a></li>
<li>Editor 기능 구현2: <a href="https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1">https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1</a></li>
<li>Editor의 버튼 기능 구현<br>
: <a href="https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c">https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50">https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148">https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148</a></li>
</ul>
<h4>기타 내용</h4>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">2018년 회고: https://bit.ly/2FmPAaL
Github: https://github.com/rayleighko
Mail: gmj1197@gmail.com
Djangogirls, seoul: https://djangogirls.org/seoul/  
AUSG: https://www.facebook.com/AUSG-311547172765852/
Facebook page: https://www.facebook.com/RaykoDev</code></pre></div>]]></description><link>https://rayleighko.github.io/blog/2019-02-11-resume</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-11-resume</guid><pubDate>Mon, 11 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;간략 필자 소개 - for Korean&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/README.md&quot;&gt;뒤로가기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hits.dwyl.io/rayleighko/training/resume&quot;&gt;&lt;img src=&quot;http://hits.dwyl.io/rayleighko/training/resume.svg&quot; alt=&quot;HitCount&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourcerer.io/rayleighko&quot;&gt;&lt;img src=&quot;https://avatars2.githubusercontent.com/u/24822072?v=4&quot; height=&quot;50px&quot; width=&quot;50px&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourcerer.io/rayleighko&quot;&gt;Sourcerer profile&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;좌우명: &lt;a href=&quot;https://en.wikipedia.org/wiki/Lifelong_learning&quot;&gt;평생학습(Lifelong learning)&lt;/a&gt;, &lt;a href=&quot;https://bit.ly/2E22Als&quot;&gt;민이호학 불치하문(敏而好學 不恥下問)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;개발이라는 분야만이 아닌 서비스 구현의 전반적인 워크 플로우를 공부하는 프로그래머가 되고자 합니다. 이를 위해 더나은 경험을 추구하며, 기술적으로 성장하는 것을 좋아합니다. 더불어 모든 일은 체계적으로 하거나, 다양한 의견을 수용해 최적의 결과를 만들 때 가장 큰 성취감을 느끼곤 합니다.&lt;/p&gt;
&lt;p&gt;현재는 학업에 집중하고자 NineVR이라는 VR 스타트업에서 퇴사하고, 가벼운 프로젝트를 만들며 다음 학기를 준비하고 있습니다(2020. 2 졸업 예정).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최근 사용한 언어 및 라이브러리: Node, Javascript(React, Redux, etc.), CSS3(SCSS, StyledComponents), HTML5(JSX)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;제가 추구하는 성향의 개발자는 Development만이 아닌 Operation까지도 생각하는 개발자이기 때문에 그에 따른 다양한 툴과 언어를 편식없이 학습하고 있습니다.&lt;/p&gt;
&lt;p&gt;최근(2018. 12 ~ 2019. 02)에는 가장 활발한 발전을 이루고 있다고 생각되는 Javascript에 매력을 느껴 이를 이용하여 React를 활용한 &lt;a href=&quot;https://github.com/teamthesol/boggler&quot;&gt;프로젝트1&lt;/a&gt;과 Node를 활용한 &lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech&quot;&gt;프로젝트 2&lt;/a&gt;를 진행했습니다.&lt;/p&gt;
&lt;p&gt;이와는 별개로 &lt;a href=&quot;https://github.com/rayleighko/ml_study&quot;&gt;머신러닝 스터디(2018. 06)&lt;/a&gt;를 진행하며 머신러닝에 대해서도 관심이 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;선호하는 개발 환경: MacOS(Zsh, Bash), Linux(Ubuntu), Opensource&lt;br&gt;
선호하는 도구: AWS, React, Node&lt;br&gt;
최근 관심있는 도구: CI(TravisCI, CircleCI 등), Container(Docker, Kubernetes)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 다양한 도구를 사용하고, 이것저것 공부하는 이유는 제가 생각하는 개발자라는 직업은 배움을 게을리하지 않고, 무언가를 만들기 위해 다양한 경험을 해야 한다고 생각하기 때문입니다. 그래서 때로는 잡다하게 공부했다는 생각이 들 때가 있었습니다. 하지만 그 생각도 잠시 배움을 즐기고 있는 저 자신의 모습이 행복하기 때문에 지금까지, 그리고 앞으로도 후회없이 다양한 기술을 학습하고자 합니다.&lt;/p&gt;
&lt;h2&gt;직무 관련 주제 별 활동 정리&lt;/h2&gt;
&lt;h3&gt;참여한 재능기부 및 대외활동&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2013. 07. 01 ~ 2013. 07. 15&lt;/strong&gt;: 말레이시아 IT 봉사단 &apos;Comma&apos; - IT STAFF&lt;br&gt;
&lt;strong&gt;2017. 02. 27 ~ 2017. 05. 29&lt;/strong&gt;: 스타트업캠퍼스, Signature Course 2nd - Tech Lab(개발자)&lt;br&gt;
&lt;strong&gt;2017. 05. 23&lt;/strong&gt;: 5월, 소프트웨어에 물들다 - 의정부 어린이도서관(STAFF)&lt;br&gt;
&lt;strong&gt;2017. 12. 27&lt;/strong&gt;: DevOps Korea meetup - STAFF&lt;br&gt;
&lt;strong&gt;2018. 01. 29 ~ 2018. 03. 16&lt;/strong&gt;: 평창 Olympic/Pralympic - Passion Craw(IT STAFF)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2018. 04. 01 ~ 현재&lt;/strong&gt;: Djangogirls Seoul - Organizer&lt;br&gt;
&lt;strong&gt;2018. 08. 12 ~ 현재&lt;/strong&gt;: AWS(KRUG) University Student Group - Member&lt;/p&gt;
&lt;h3&gt;근무 및 아르바이트 경력&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2017. 04. ~ 2017. 08&lt;/strong&gt;: 프로젝트 HongU - Web Software Developer&lt;br&gt;
&lt;strong&gt;2017. 06. ~ 2017. 10. 13&lt;/strong&gt;: 패스트캠퍼스 - OpenCV와 함께하는 컴퓨터 비전 캠프 조교&lt;br&gt;
&lt;strong&gt;2018. 08. 20 ~ 11. 20&lt;/strong&gt;: 나인브이알 - (Contents) Software Engineer&amp;#x3C;UE4을 활용한 클라이언트 게임 개발 및 사내 개발 인프라 관리&gt;&lt;/p&gt;
&lt;h3&gt;공모전 및 수상 경력&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2017. 09. 28 ~ 12. 21&lt;/strong&gt;: (비공식) 컨트리뷰톤, uftrace/perf – 오픈소스 Contributor, 우수상(2등)&lt;br&gt;
&lt;strong&gt;2018. 08. 16 ~ 10. 25&lt;/strong&gt;: (공식) 컨트리뷰톤, gitShare – 오픈소스 Contributor, 우수상(2등)&lt;br&gt;
&lt;strong&gt;2019. 01. 08 ~ 02. 27&lt;/strong&gt;: (공식) 네이버 D2 CAMPUS FEST, boggler – 오픈소스 Maintainer로써 결승 진출&lt;/p&gt;
&lt;h3&gt;입영기록&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2014. 02. 25 ~ 2015. 11. 24&lt;/strong&gt;: 대한민국 해병대(1사단) - 네트워크 관리/운용병, 전산/체계 관리/운용병&lt;/p&gt;
&lt;h3&gt;보유 자격증&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2017. 12. 24&lt;/strong&gt;: DAsP(데이터아키텍처 준전문가) - 데이터진흥원&lt;br&gt;
&lt;strong&gt;2017. 12. 23&lt;/strong&gt;: 리눅스마스터 2급 - 한국정보통신진흥협회&lt;/p&gt;
&lt;h2&gt;최근에 진행한 프로젝트 3개(맡은 역할, 인원 수, 기간, 내용 등)&lt;/h2&gt;
&lt;h3&gt;2018. 04. 01 ~ 2018. 11. 21: 강의 공유 플랫폼, Athena v1.0.0(4명) - Front-end(일부), Back-end(일부)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: React(Mobx), Node(Express, SocketIO), AWS(EC2, Route53, RDS), Git(GitKraken, Gitlab)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 프로젝트의 시작은 수강했던 강의의 한 학생의 불편함이었습니다. 그 학생은 장애를 가지고 있어 수업을 듣기 위해서는 누군가의 도움이 필요했고, 그 도움조차 그 학생의 학습을 완벽히 도울 수는 없었습니다.&lt;/p&gt;
&lt;p&gt;그래서 그 학생에게 도움이 되고자 그를 위한 프로젝트를 만들었습니다. - 3주 정도 서비스 후 서비스 유지비를 고려해 무기한 폐지하게 되었습니다.&lt;/p&gt;
&lt;p&gt;작업물의 완성도는 낮았지만, 프로젝트를 진행하며 DevOps를 위해서는 안정적인 Development가 선행되어야 한다는 것을 깨닫게 되었습니다. 그래야 Operation을 위한 제대로 된 서비스를 제공할 수 있다는 것을 깨닫게 되었습니다.&lt;/p&gt;
&lt;p&gt;뿐만 아니라 작업물의 완성을 목표로 진행했기 때문에 소스코드의 질이 떨어졌습니다. 이에 리펙토링의 필요성을 느꼈고, 프로젝트를 하나하나 수정하는 것보다 새로운 프로젝트를 만드는 것이 나을 것 같다고 생각해 새로운 프로젝트(Boggle)를 만들게 되었습니다.&lt;/p&gt;
&lt;p&gt;결과적으로는 운영에 실패해 접게 되었지만, 생애 처음으로 구현부터 서비스 운영까지 진행하는 프로젝트를 경험했다는 중요한 경험이었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 소스코드 주소&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/athena&quot;&gt;https://github.com/rayleighChild/athena&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;진행 간 부족한 점 피드백&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/athena_FAQ&quot;&gt;https://github.com/rayleighChild/athena_FAQ&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2018. 12. 26 ~ 2019. 02. 20: 음성인식 기반 메모 플랫폼, Boggler v1.0.0(3명) - Front-end(주도), Design(주도)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: React(Redux, ...), Node(Express, ...), Git(GitKraken, GitHub, Git-Bash, ...), Editor(VSCode), Mozilla/DeepSpeech 등 여러 오픈소스 프로젝트 참고&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;보글러의 가장 큰 핵심은 스트리밍 혹은 파일로 입력받은 음성 정보를 분석해 이를 텍스트로 변환시킨다는 점입니다. 가령 미팅에서의 가벼운 대화 혹은 강연자의 음성을 텍스트로 변환해 보다 나은 필사(글을 옮겨 적는) 환경을 제공합니다.&lt;/p&gt;
&lt;p&gt;때때로 우리는 강의를 듣거나 중요한 일을 녹음합니다. 하지만, 이렇게 녹음된 자료는 텍스트로 옮겨 적어야 하는 불편함이 있었습니다. 더불어 이런 작업은 꼭 필요한 일이 아니라면 쉽게 잊혀지곤 합니다. 더불어 유료로 서비스를 이용해야 하기도 하죠!&lt;/p&gt;
&lt;p&gt;이런 문제를 보완하기 위해 보글러는 음성을 텍스트로 변환하기 위한 작업의 피로를 줄이기 위한 도구로 만들어졌습니다.&lt;/p&gt;
&lt;p&gt;저는 팀 내에서 프론트 엔드와 디자인을 담당했고, 전체적인 프로젝트 진행 방향과 구성원의 일정관리와 프로젝트 이슈 관리, 문서화 등을 주도적으로 진행하며 프로젝트 관리를 병행했습니다.&lt;/p&gt;
&lt;p&gt;위의 두 프로젝트(Athena, Boggler)를 진행하며 느낀 핵심 키워드는 “사용하는 기술에는 정당한 이유가 필요하며, 회사에서 사용하는 모든 기술에는 정당한 이유가 있다”라는 깨달음이었습니다.&lt;/p&gt;
&lt;p&gt;이를 통해 프로젝트를 진행하기 전에는 마냥 트랜드를 따라 개발하는 것이 옳은 줄 알았지만, 사실은 기본에 충실해 기능과 구현에 적절한 기술을 사용하는 것이 옳다는 것을 깨닳았고 기본에 충실해야 좋은 서비스를 만들 수 있다는 것을 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 주소&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/boggler&quot;&gt;https://github.com/rayleighChild/boggler&lt;/a&gt; - 현재 진행 중.&lt;/p&gt;
&lt;h3&gt;2018. 01. 23 ~ 01. 28: Mozilla/DeepSpeech 기반 Nodejs 함수 Node Packcage(2명) - 프로젝트 설계 및 주도&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: Node, Mozilla/DeepSpeech&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞서 설명한 보글러에서 편하게 사용하기 위해 오픈 소스 기반 Speech Recognition(음성 인식) 서비스인 Mozilla/DeepSpeech의 기능을 Node 모듈로 만든 프로젝트입니다. 또한, 기존의 Mozilla/DeepSpeech에서 제공하는 NPM 모듈이 있었지만 터미널 기반으로 사용해야 했기에 이를 코드로 사용하면 좋겠다고 생각해 진행하게 되었습니다.&lt;/p&gt;
&lt;p&gt;해당 프로젝트를 진행하면서 처음으로 package에 대한 전 과정을 설계, 구현했기 때문에 Node Package 퍼블리싱 경험을 통해 사용자의 피드백을 받을 수 있었으며, 사용자로부터의 요구사항에 맞게 프로젝트의 기능을 수정했던 경험이 기억에 남습니다. 가령 사용자의 요구였던 동기적으로 함수가 호출되어 결과를 반환하는 방식을 체택한 사례(&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/issues/2&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/issues/2&lt;/a&gt;)는 개인 프로젝트로 진행하는 것과는 또다른 경험을 얻을 수 있는 계기가 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;현 기준(2019. 02. 17) 총 다운로드 수: 931회&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 주소&lt;/strong&gt;:　&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech&quot;&gt;https://github.com/teamthesol/node-DeepSpeech&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;가장 기억에 남는 문제 해결 사례 소개&lt;/h2&gt;
&lt;h3&gt;1. 기능 구현 - 비동기적으로 구현되어 있는 함수를 동기적으로 구현하기 위해 수정한 사례&lt;/h3&gt;
&lt;h4&gt;문제 정의&lt;/h4&gt;
&lt;p&gt;: 앞서 소개한 STT 기반 프로젝트인 Node-DeepSpeech라는 프로젝트는 처음에 구현될 때(0.2.4 버전)만 해도 비동기적으로 사용자에게 제공되었습니다.&lt;/p&gt;
&lt;p&gt;그래서 사용자의 입장에서는 인식된 음성 데이터의 전달은 원하고자 할 때 성공적으로 서버에 전달할 수 있었지만, 분석되어 전달받은 문자 데이터의 반환 시기를 알 수 없었습니다(&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/issues/2&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/issues/2&lt;/a&gt;).&lt;/p&gt;
&lt;h4&gt;문제 해결 과정&lt;/h4&gt;
&lt;p&gt;: 우선적으로 Node라는 언어의 메커니즘 자체가 단일 스레드 기반으로 클러스터링을 통해 마치 멀티 스레드 환경에서처럼 한 번에 여러 작업을 동시에 수행하고 있었기 때문에 일반적인 함수를 사용한다 하더라도 비동기적으로 사용되고 있었습니다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 별도의 함수 혹은 키워드가 필요했고, 이를 해결하기 위해 구글에서 동기적으로 함수를 구현하는 방법을 찾아 결국에는 Stackoverflow를 통해 callback function, Promise, async/await의 3가지 문법을 활용하는 방법이 있다는 것을 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;첫 번째 방법인 callback function의 경우에는 callback hell이라고 부르는 고전적인 문제를 안고 있었기 때문에 체택할 수 없어 나머지 두 방법 중 하나인 Promise로 함수를 구현하는 방식을 체택하게 되었습니다.&lt;/p&gt;
&lt;h4&gt;결론&lt;/h4&gt;
&lt;p&gt;: 이번 사례를 통해 로컬에서만 개발하고 개인의 요구에 맞춰 기능을 구현하던 과거를 반성하게 되었고, 사용자의 요구를 실현한다는 것에 대한 안목이 생겼습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크&lt;/strong&gt;
: &lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. FrontEnd - 오디오 파일 분석을 통한 기능 구현 및 스타일링 사례&lt;/h3&gt;
&lt;h4&gt;문제 정의&lt;/h4&gt;
&lt;p&gt;: 링크를 통해 미디어(유튜브, 트위치, 음성 파일 등)를 제공하는 형태였던 기존의 방식을 사용자의 파일을 통해 이를 분석하여 웨이브(frequency wave)를 그려야했고, DeepSpeech를 적용하여 텍스트를 분석하는 로직이 필요했습니다.(&lt;a href=&quot;https://github.com/teamthesol/boggler/issues/18&quot;&gt;https://github.com/teamthesol/boggler/issues/18&lt;/a&gt;)&lt;/p&gt;
&lt;h4&gt;문제 해결 과정&lt;/h4&gt;
&lt;p&gt;: 우선적으로 문제를 정의하는 과정에서 하나의 문제가 아닌 여러 개의 문제를 한 번에 해결하려 하는 것 같다고 느껴 이를 여러 문제로 정의할 필요성을 느끼게 되었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Audio Frequency wave 그리기(기본 뼈대 제작): &lt;a href=&quot;https://github.com/teamthesol/boggler/issues/31&quot;&gt;https://github.com/teamthesol/boggler/issues/31&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 그리기(기본 뼈대 및 참고할 예시 코드 삽입): &lt;a href=&quot;https://github.com/teamthesol/boggler/issues/30&quot;&gt;https://github.com/teamthesol/boggler/issues/30&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각 과정에서는 기능을 나눠 기능과 스타일링을 구현했고, 우선적으로 기능 구현을 먼저 해결하려 했습니다. 1번 기능인 Audio Frequency wave의 틀을 먼저 만들고, 기능을 구현한 이후에 스타일링을 구현했습니다.&lt;/p&gt;
&lt;p&gt;1번에서는 오픈 소스 중 하나인 waveform-react를 사용했고, 여기에 사용되는 오디오 파일을 버퍼로 디코드하는 로직과 이를 반환할 시점이 디코딩이 끝난 이후여야 했기에 동기적으로 구현되어야 했습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 async/await 방식을 체택해 기능을 동기적으로 구현했고, 이에 따라 분석된 버퍼 데이터를 waveform-react에 삽입해 Audio Frequency wave를 그릴 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이어서 2번 기능인 Editor에서는 에디터의 기능을 하게 될 textarea와 여기에 들어온 텍스트를 바탕으로 사용자에게 텍스트를 보여줄 Article 기능이 필요했습니다.&lt;/p&gt;
&lt;p&gt;더불어 텍스트는 state로 관리해 사용자의 변경에 따라 해당 state가 변하게 구현해야 했고, 변화되는 것과 동시에 사용자에게 보여주는 Article에서도 rerender가 일어나야 했기 때문에 이에 대해서도 고려해야 했습니다.&lt;/p&gt;
&lt;h4&gt;결론&lt;/h4&gt;
&lt;p&gt;: 이번 사례를 통해 하나의 메서드는 하나의 문제만 해결해야 한다는 것을 깨닫게 되었고, 여러 문제가 섞인 이슈를 해결하기 위해서는 문제를 기능 단위로 나누는 것이 효율적이라는 것을 깨닫게 되었습니다.&lt;/p&gt;
&lt;p&gt;더불어 문제를 해결할 때 어느정도의 설계가 있어야 효율적으로 기능을 구현할 수 있다는 알게되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기능 구현: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7&quot;&gt;https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3&quot;&gt;https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크 2&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Article 컴포넌트 구현: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f&quot;&gt;https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 기능 구현1: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628&quot;&gt;https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 기능 구현2: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1&quot;&gt;https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor의 버튼 기능 구현&lt;br&gt;
: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c&quot;&gt;https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50&quot;&gt;https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148&quot;&gt;https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;기타 내용&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;2018년 회고: https://bit.ly/2FmPAaL
Github: https://github.com/rayleighko
Mail: gmj1197@gmail.com
Djangogirls, seoul: https://djangogirls.org/seoul/  
AUSG: https://www.facebook.com/AUSG-311547172765852/
Facebook page: https://www.facebook.com/RaykoDev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?]]></title><description><![CDATA[<h2>시작하기 전에</h2>
<blockquote>
<p>본 글은 지극히 주관적인 관점, 즉 유명 오픈 소스의 메인테이너(관리자)가 아닌 순수히 취미 혹은 자기 계발을 위해 '오픈 소스'라는 도구를 활용해 그 문화에 입문하려는 이의 관점에서 쓰여진 글입니다.</p>
</blockquote>
<p><strong>오픈 소스</strong>란 무엇일까? 필자는 지금까지 <strong>오픈 소스</strong>라는 단어를 심심치 않게 들을 수 있었다. 하지만, 이 단어가 가진 의미를 정확하게 알기란 쉽지 않았다.</p>
<p>그래서 필자는 오픈 소스를 처음 접했을 때 주변의 누군가로부터 오픈 소스는 <code class="language-text">무료로 사용할 수 있는 코드</code>라고, 또 다른 누군가로부터 <code class="language-text">돈이 안 되는 자선사업 혹은 그러한 서비스</code>라는 이야기를 들었다. 한편으로는 취업을 준비하는 주변 친구들은 <code class="language-text">오픈 소스는 취업에 도움이 된다</code>는 식의 뜬구름 잡는 이야기를 하기도 했다.</p>
<p>그래서 필자는 이 글을 통해 스스로 오픈 소스와 오픈 소스 생태계란 무엇인지를 고민해보고자 했다.</p>
<p><img src="https://images.velog.io/post-images/rjs1197/92ddfeb0-23d1-11e9-b431-39bfc876f2e4/places-with-the-most-contributors.jpg" alt="places-with-the-most-contributors.jpg"></p>
<p>이 그림은 DashBouquet<a href="https://dashbouquet.com/blog/web-development/github-octoverse-2018-overview-top-trends">[1]</a>에서 가져온 전 세계 컨트리뷰터 현황에 대한 자료이다. 이 자료만 보더라도 아시아 지역에서는 중국과 일본이 단연 앞서고 있다.</p>
<blockquote>
<p>물론 이 자료는 2017년 10월 1 일부터 2018년 9월 30일까지의 GitHub 트랜드 통계를 바탕으로 작성되었고, 국내 개발자의 수가 타국에 비해 현저히 적다는 점, 국내에서는 잘못된 인식으로 오픈 소스에 대한 편견이 지배적이기 때문에 완전히 객관적이라고는 할 수 없다. 하지만, 단편적으로나마 국내의 오픈 소스 프로젝트 생태계의 현 위치를 짐작할 수 있을 것이다.</p>
</blockquote>
<p>필자는 이처럼 상대적으로 관심이 적은 국내의 오픈 소스 생태계를 개선하기 위해선 기본적으로 본질을 이해해야 접근할 수 있을 거라고 생각했다. 우선, 그 생태계를 이해하기에 앞서 왜 나는 오픈 소스라는 키워드를 가지고 이를 활용하려 할까? 왜 주변 사람들은 오픈 소스가 중요하다고 이야기하는 걸까?</p>
<h2>오픈 소스란 무엇일까?</h2>
<p>과거의 오픈 소스는 서론에서 말한 것과 같이 다양한 범주와 의견으로 정의할 수 있었다. 하지만, 현시점의 오픈 소스는 한 개인이 쉽게 정의할 것이 아니라고 생각한다. 그 이유는 필자가 나열하는 것보다 본 글을 읽다 보면 자연스럽게 느낄 수 있을 것이기 때문에 여기서 따로 언급하지는 않고, 일부 사례를 통해 이를 느껴보도록 하자.</p>
<p>먼저, 위키피디아에서는 오픈 소스를 다음과 같이 정의하고 있다<a href="https://en.wikipedia.org/wiki/Open_source">[2]</a>.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Open source is a term denoting that a product includes permission to
use its source code, design documents, or content.

...</code></pre></div>
<p>한글로 해석하자면 <code class="language-text">&quot;오픈 소스는 제품에 대한 소스 코드, 디자인 문서 또는 콘텐츠를 사용할 수 있는 권한이 있음을 나타낸다.&quot;</code>라고 할 수 있다. 이를 통해 단편적이지만 '오픈 소스'라는 것은 어떠한 제품에 대한 지적 재산권을 나타낸다는 것을 알 수 있었다.</p>
<p>이를 통해 필자는 "그렇다면 오픈 소스 프로젝트 중에서 영리적인 사업을 하는 프로젝트들도 있나?"라거나 "소스 코드는 공개하지만, 오픈 소스의 수정은 거부하는 프로젝트들도 오픈 소스로서 존재할 수 있는 걸까?"라는 의문이 들었지만 위 정의만으로 그 의문을 해결하기란 어려웠다.</p>
<p>글을 작성하고 시간이 흘러 여러 피드백을 받아 수정하게 되면서 다음과 같은 힌트를 얻을 수 있었다.</p>
<hr>
<p>Debian에서 말한 'Free'와 'Free Software'의 의미<a href="https://www.debian.org/intro/free.en.html?fbclid=IwAR1ou9joShVBLNWdU4NjOm05ztGxbohRo5B95g98q40hqLHFAX2tmuDUMtg">[2-1]</a>를 살펴보면, 여기서의 'Free'는 우리가 일상적으로 사용하는 의미 중 하나인 '무료(at no cost)'가 아닌 '자유(freedom)'를 나타낸다고 말한다.</p>
<p>어쩌면 두 의미를 같다고 볼 수도 있지만, 필자가 느끼기에는 '오픈 소스'라는 단어가 가지는 'Open'의 의미가 '프리웨어(공공제)' 혹은 '셰어웨어'의 그것과는 전혀 다른 것이라고 느꼈다.</p>
<p>이어 읽어나가다 보면 오픈 소스는 '라이선스'라는 것을 가지며, 이를 통해 오픈 소스는 지적 재산권이 있는 원작자의 요구에 맞게 사용되어야 한다는 구문이 서술되어 있다.</p>
<p>이 점을 통해 "오픈 소스를 한다"라는 의미는 마냥 비용이 없는(at no cost) 소프트웨어를 만드는 의미가 아닌 "원작자 즉, 개발자의 의도가 자유로이 반영되어 운영되는 프로젝트를 진행한다"라는 의미가 아닐까 하는 생각도 들었다.</p>
<p>또한, 글에서는 오픈 소스 제작자들이 체택하는 일반적인 라이선스 조합에 대해 소개하고 있다.</p>
<ul>
<li>
<p>Not allowing use of their code in proprietary software. Since they are releasing their code for all to use, they don't want to see others steal it. In this case, use of the code is seen as a trust: you may use it, as long as you play by the same rules.</p>
</li>
<li>
<p>Protecting identity of authorship of the code. People take great pride in their work and do not want someone else to come along and remove their name from it or claim that they wrote it.</p>
</li>
<li>
<p>Distribution of source code. One of the problems with most proprietary software is that you can't fix bugs or customize it since the source code is not available. Also, the company may decide to stop supporting the hardware you use. Many free licenses force the distribution of the source code. This protects the user by allowing them to customize the software for their needs.</p>
</li>
<li>
<p>Forcing any work that includes part of their work (such works are called derived works in copyright discussions) to use the same license.</p>
</li>
</ul>
<p>이를 한글로 해석해보면 다음과 같다.</p>
<ul>
<li>
<p>독점적인 소프트웨어에서의 코드 사용을 거부합니다. 그들은 모두가 사용할 수 있도록 코드를 제공하지 않기 때문에 다른 사람들이 이것을 훔치려는 것을 보고싶지 않습니다. 이 사례는 '코드의 사용'을 '신뢰'라고 봅니다: 이 경우 동일한 라이선스의 규칙을 적용하면 코드를 사용할 수 있습니다.</p>
</li>
<li>
<p>코드 원작자의 신원을 보호합니다. 사람들은 그들의 일에 큰 자부심을 느끼고 있기에 원작자의 이름을 지우거나 자신이 쓴 것이라고 주장하지 말아야 합니다.</p>
</li>
<li>
<p>소스 코드의 배포(를 강제합니다). 독점 소프트웨어의 문제 중 하나는 소스 코드를 사용할 수 없기 때문에 사용자가 직접 버그를 수정하거나 맞춤화(customize)하는 것이 불가능하다는 것입니다. 또한, 회사는 귀하가 사용하는 하드웨어의 지원을 중단할 수도 있습니다. 많은 자유(Free) 라이선스들이 소스 코드의 배포를 강제하고 있습니다. 이는 사용자가 자신의 필요에 맞게 소프트웨어를 맞춤화할 수 있도록하여 사용자를 보호합니다.</p>
</li>
<li>
<p>저작물의 일부를 포함하는 저작물('Copyright Discussions'에서 <em>파생 저작물</em>이라고 정의함)이 동일한 라이선스를 사용하도록 강요합니다.</p>
</li>
</ul>
<p>필자는 이 문장들을 읽고 많은 오픈 소스 프로젝트는 원작자의 라이선스에 명시된 의도를 훼손하지 않는다면, 그의 저작물 사용이 가능하다는 것을 말하고자 하는 것이라 생각했다.</p>
<p>더불어 글의 다음 단락에서는 많은 사람들이 자체 라이선스를 쓰게 되면 모호한 문구 혹은 미묘한 문제가 되는 문장의 사용이 법적 문제에서 원작자의 권한을 침해할 수 있는 것을 우려해 가장 널리 사용되는 라이선스에 대해서도 소개한다.</p>
<ul>
<li>The <a href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License (GPL)</a>. Some good background information on software licenses and a copy of the license can be found at the GNU web site. This is the most common free license in use in the world.</li>
<li><a href="https://opensource.org/licenses/artistic-license.php">Artistic License.</a></li>
<li><a href="https://www.debian.org/misc/bsd.license">BSD style license.</a></li>
</ul>
<p>이 라이선스들은 다음과 같은 공통점을 지닌다.</p>
<ul>
<li>You can install the software on as many machines as you want.</li>
<li>Any number of people may use the software at one time.</li>
<li>You can make as many copies of the software as you want and give them to whomever you want (free or open redistribution).</li>
<li>There are no restrictions on modifying the software (except for keeping certain notices intact).</li>
<li>There is no restriction on distributing, or even selling, the software.</li>
</ul>
<p>마지막으로 OSI(Open Source Initiative)에서는 The Open Source Definition<a href="https://opensource.org/osd">[2-2]</a>에서 다음 10가지의 문장으로 Open Source를 정의한다는 것도 알아두도록 하자.</p>
<ol>
<li>자유 배포(Free Redistribution)</li>
<li>소스코드 공개(Source Code Open)</li>
<li>2차적 저작물(의 허용)(Derived Works)</li>
<li>원작자의 소스코드 수정 제한(Integrity of The Author's Source Code)</li>
<li>개인이나 단체에 대한 차별 금지(No Discrimination Against Persons or Groups)</li>
<li>사용 분야에 대한 제한 금지(No Discrimination Against Fields of Endeavor)</li>
<li>라이선스의 배포 (Distribution of License)</li>
<li>라이선스 적용상의 동일성 유지 (License must not be specific to a product)</li>
<li>다른 라이선스의 포괄적 수용 (License must not contaminate other software)</li>
<li>라이선스의 기술적 중립성 (License must be Technology-Neutral)</li>
</ol>
<blockquote>
<p>이 Open Source Definition은 <a href="(https://www.debian.org/social_contract#guidelines)">Debian Free Software Guidelines</a>(DFSG)에서 유래되었다는 것을 알아두고 이를 참고하도록 하자.</p>
</blockquote>
<p>글을 작성 및 수정하며 얻은 소감은 Debian에서 제공한 가이드라인과 OSI의 가이드라인은 약간 다를 뿐 거의 유사하다는 것이고, 근래에 들어서는 Free와 Open을 나누지않고 FOSS(Free &#x26; Open Source Software)라 칭한다는 것이다.</p>
<p>더불어 오픈 소스의 Open이 가지는 의미는 공짜가 아닌 소스 코드 및 SW의 자유로운 사용이라는 것을 알게 되었다.</p>
<blockquote>
<p>추가적으로 필자는 OSI의 창립자 레이몬드가 칭한 '오픈 소스'라는 단어는 상업화(Commercialization)에 대한 반대급부라고 이해했다. 하지만 그럼에도 왜 Open Source Software라고 부르며 이를 '소프트웨어'라 제품화를 시키는 것일까? 코드는 그저 특정 문제를 해결하기 위한 명세로 이야기되는 것이 아닌가? 왜 이를 위한 제품이 '오픈 소스'로서 이야기될 수 있는 것일까?</p>
<p>이러한 고민을 하게 된 까닭은 오픈 소스 소프트웨어라 칭함으로 인해 오픈 소스는 그 자체로 자유로운 의미로서 상업화의 반대급부로 정의하지만, 이를 활용하는 비즈니스 모델의 존재에 대한 여지를 주기 때문이다. 비즈니스 모델이 있는 오픈 소스 서비스들은 오픈 소스 문화에 동참하지 않는 것일까? 이러한 고민의 답은 다음의 'RedHat'의 사례를 통해 힌트를 얻어보도록 하자.</p>
</blockquote>
<h2>오픈 소스를 활용한 서비스들</h2>
<p><img src="https://images.velog.io/post-images/rjs1197/02e275c0-23d6-11e9-bf21-f7a982ab1aa4/ap550x55016x121transparentt.png" alt="ap,550x550,16x12,1,transparent,t.png"></p>
<p>위 그림<a href="https://www.google.com/url?sa=i&#x26;source=images&#x26;cd=&#x26;ved=2ahUKEwixjszon5PgAhXJ7WEKHRfWAwIQjRx6BAgBEAU&#x26;url=https%3A%2F%2Fwww.redbubble.com%2Fpeople%2Fradixvinni%2Fworks%2F30430581-developer-icons-open-source-project-logos-web-companies%3Fp%3Dart-print&#x26;psig=AOvVaw1ePP6ojSivrUxMGaEoLdwx&#x26;ust=1548860098305404">[3]</a>을 보면 우리가 흔히 접했던 프로젝트부터 난생처음 보는 프로젝트까지 다양하게 있는 것을 볼 수 있다.</p>
<p>위의 로고 중 필자가 아는 서비스에 한해 오픈 소스와 밀접한 관계가 있는 저작물을 소개해보려 한다.</p>
<p>가장 먼저 보이는 <code class="language-text">RedHat</code>은 대표적으로 오픈 소스를 통해 비즈니스를 하는 회사이다. 그들이 제공하는 저작물은 리눅스 운영체제가 대표적이고, 오픈 소스이기 때문에 기본적으로 자유로이 사용하는 것이 가능하다.</p>
<p>그렇다면 그들은 어떤 비즈니스 모델을 가지고 있을까? 어떻게 돈을 벌고, 이를 유지하고 있을까? 이에 대한 답을 고민하던 중 Quora의 <code class="language-text">&quot;What is Red Hat&#39;s business model?&quot;</code>라는 질문을 보게 되었는데, 이를 RedHat의 한 직원이 설명한 글<a href="https://www.quora.com/What-is-Red-Hats-business-model">[4]</a>을 통해 조금이나마 해결할 수 있었다. 그 중 일부는 다음과 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Red Hat doesn&#39;t sell software. You can download the software for free.

Red Hat sells service/support subscriptions.

...</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Red Hat은 소프트웨어를 판매하지 않습니다. 무료로 소프트웨어를 다운로드 할 수 있습니다.

Red Hat은 서비스, 지원 구독(Support Subscription)을 판매합니다.

...</code></pre></div>
<p>글에서는 RedHat은 소프트웨어를 '판매'하지 않고, 소프트웨어를 사용하는 데 필요한 서비스와 Support Subscription을 판매한다고 이야기한다(최근에는 고도화된 소프트웨어를 판매하기도 한다). 그래서 그는 자신들의 제품인 <strong>RHEL, Fedora</strong> 또는 <strong>CentOS</strong>를 다운로드하고, 수정하며 원하는대로 직접 컴파일하는 것을 자유로이 할 수 있다고 설명했다.</p>
<p>또한, 이와는 별개로 RedHat의 서비스가 제대로 작동되지 않을 때 RedHat의 지원을 받기 위해서는 Support Subscription 서비스에 대한 비용을 지불해야 한다는 식으로 이야기한다.</p>
<p>이런 비즈니스 모델을 가지고 있기 때문에 RedHat은 오픈 소스의 범주 안에서 경영을 할 수 있고, 오픈 소스를 활용한 사업의 선사례로 꼽히는 모양이다. 더불어 RedHat은 '오픈 소스 소프트웨어'를 운영하고 있기 때문에 이에 대한 서비스 개선을 계속해서 진행한다.</p>
<blockquote>
<p>Quora의 글을 읽기 전까지 필자는 레드헷의 제품이 단순하게 무료와 유료 버전으로 나뉘어져 있고, 사용자에게는 각각 다른 가치를 얻는다고 생각했다. 하지만 RedHat이 가진 가치는 그것이 아닌 오픈 소스라는 이름에 걸맞는 것이었다고 느끼게 되어 감사하게 읽었다.</p>
<p>이를 통해 필자는 RedHat은 오픈 소스라는 매개 자체로 비즈니스 모델을 구축했다기 보다는 오픈 소스를 활용한 저작물을 통해 비즈니스 모델을 구축한 것이라고 이해할 수 있었다. 그렇다면 오픈 소스 소프트웨어는 오픈 소스를 활용한 소프트웨어라고 이해하는 것이 맞을까? 이렇게 이해한다면 품고 있던 수익성에 대한 의문은 말끔히 정리될테니 말이다.</p>
</blockquote>
<hr>
<p>다시 앞선 그림으로 돌아가 다른 사례를 고민하던 중 프로그래밍 언어 중 하나인 <code class="language-text">C/C++</code>에 대해 궁금해졌다. 프로그래밍 언어도 오픈 소스와 관련이 있을까? 보통 컴파일 언어를 사용하기 위해서는 컴파일러라는 소프트웨어가 필수적으로 필요한데, 이때 사용하는 컴파일러들은 지금껏 의식없이 사용했었으니 말이다.</p>
<p>이와 더불어 프로그래밍 언어에서 사용하는 각종 라이브러리 혹은 패키지같이 언어를 둘러싼 모든 환경에서 오픈 소스가 사용될 수 있을 것이다. 우리가 흔히 사용하는 컴파일러 중에는 오픈 소스인 것들도 다양할 것이고, 세상에는 다양한 언어와 이를 둘러싼 환경이 있을 것이기 때문이다.</p>
<blockquote>
<p>러프하게 알 수 있는 오픈 소스 컴파일러 목록은 이 곳<a href="https://en.wikipedia.org/wiki/List_of_compilers">[5]</a>에서 찾을 수 있다.</p>
<p>추가적으로 프로그래밍 언어 같은 경우는 보편적으로 사용자에게 공공제로 제공되지만, 언어의 표준과 같이 특정 규율을 정하는 것은 별도의 기구(ISO<a href="https://www.iso.org/">[5-1]</a>)에서 관리하기도 한다.</p>
</blockquote>
<p>즉, <code class="language-text">C/C++</code>과 같은 프로그래밍 언어 또한 오픈 소스와 밀접하며, 이를 위한 오픈 소스 컴파일러는 당연히 소스 코드를 공개하고 이를 수정할 수 있다<a href="https://gcc.gnu.org/">[6]</a>.</p>
<hr>
<p>이쯤에서 다음과 같은 의문이 들 수 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">그렇다면 오픈 소스가 아닌 건 무엇일까?</code></pre></div>
<p>여기까지 쓰고 난 본인의 견해로는 이에 대한 답을 내리기 위해서는 <strong>오픈 소스가 아닌 것</strong>을 나열하기보다 <strong>오픈 소스인 것</strong>을 고민해야 한다고 느꼈다. 그렇기 때문에 만약 오픈 소스에 대해 보다 깊은 이해를 원하는 독자는 다음의 자료를 참고하길 바란다.</p>
<ul>
<li><a href="https://www.debian.org/intro/free.en.html">https://www.debian.org/intro/free.en.html</a></li>
<li><a href="https://www.gnu.org/philosophy/free-sw.en.html">https://www.gnu.org/philosophy/free-sw.en.html</a></li>
<li><a href="https://opensource.org/osd-annotated">https://opensource.org/osd-annotated</a></li>
</ul>
<blockquote>
<p>글을 수정하며 얻은 다양한 조언을 통해서 이제는 '오픈 소스'라는 단어가 각 개인의 의견으로 정의될 수 없다고 생각이 굳어졌다(그 정의에 대한 서적은 이미 차고 넘치기 때문이다).</p>
<p>물론 그 정의에 대한 각 개인의 이해와 파생된 견해가 다를 수 있겠지만 결과적으로 과거부터 이야기되어 현재에 이르러서는 논쟁의 여지가 수그러든 것이기 때문에 앞선 것과 같이 '오픈 소스는 이미 정의되어 있다'라고 생각을 굳힐 수 있었다.</p>
</blockquote>
<p>여기까지 글을 적으며 필자는 오픈 소스에 대해 어렴풋이 이해할 수 있게 되었다고 생각한다. 그럼에도 아직 오픈 소스를 둘러싸고 있는 그 환경에 대해서는 익숙하지 않다.</p>
<p>주변에서는 국내 오픈 소스 생태계에 불만을 품은 이들도 상당하다. 그들은 왜 그런 불만을 가지고 있을까? 그래서 이번에는 오픈 소스 생태계란 무엇인지를 살펴보도록 하자.</p>
<h2>오픈 소스 생태계란 무엇일까?</h2>
<p><img src="https://images.velog.io/post-images/rjs1197/9f6299c0-23db-11e9-bf21-f7a982ab1aa4/2016-2017-trends-open-source-ecosystem.jpg" alt="2016-2017-trends-open-source-ecosystem.jpg"></p>
<p>이 그림<a href="https://www.google.com/url?sa=i&#x26;source=images&#x26;cd=&#x26;ved=2ahUKEwjrho_4qJPgAhWWad4KHd4VAy8QjRx6BAgBEAU&#x26;url=https%3A%2F%2Fwww.altoros.com%2Fblog%2F2016-2017-trends-the-open-source-ecosystem-is-universal%2F&#x26;psig=AOvVaw1t-rgseFFa4Lscy9er3gEc&#x26;ust=1548862555751385">[7]</a>은 단일 오픈 소스 생태계를 가시적으로 보여준다고 느껴서 가져왔다.</p>
<p>이 그림은 <strong>단일 오픈 소스를 활용한 솔루션</strong>을 제공하는 <code class="language-text">VENDORS</code>, <strong>단일 오픈 소스를 지원</strong>하는 <code class="language-text">EXPERTS</code>와 <strong>단일 오픈 소스에 대한 조언, 기여 등</strong>을 제공하는 <code class="language-text">COMMUNITY</code>, 마지막으로 <strong>단일 오픈 소스와 이로 만들어진 솔루션들에 대한 피드백</strong>을 제공하는 <code class="language-text">USERS</code>로서 4사분면을 그리며 선순환을 이루고 있다.</p>
<p>이러한 선순환의 결과는 오픈 소스 생태계의 확장으로 이어질 것이고, "결과적으로 다양한 프로젝트들의 유지력도 향상될 수 있지 않을까?"라는 생각도 해봤다.</p>
<p>또한, 그렇게 된다면 사용자의 관점에서도, 기업의 관점에서도 오픈 소스라는 주제가 매력적으로 다가올 수 있지 않을까라는 결론도 조심스럽게 내려보았다.</p>
<blockquote>
<p>여기서의 매력은 각기 다르게 이야기될 수 있을 것이다. '비용적인' 측면을 차치하고 말이다.</p>
</blockquote>
<p>하지만, 이처럼 건강한 생태계를 유지하기는 쉽지 않을 것만 같다. 프로젝트가 커짐에 따라 한 개인이 관리하기에는 부담스러울뿐더러 기업의 입장에서도 하나의 생태계를 책임진다는 것은 큰 위험 부담을 감수하는 것이기 때문이다. 그렇다고 국가(정부기관)가 떠안기에는 상대적으로 이해관계가 성립되기 힘들다는 생각도 해봤다.</p>
<blockquote>
<p>물론 이러한 위험 부담에도 생태계를 책임지고 있는 <code class="language-text">Google</code>과 <code class="language-text">Facebook</code>, <code class="language-text">Alibaba</code> 등이 있는 것도 사실이고 미국이나 독일 등 다양한 국가에서 정부 차원의 지원이 있는 것은 사실이기에 이 부분은 국내의 정서로 받아들이기에는 다소 민감할 수 있겠다.</p>
</blockquote>
<hr>
<p>이제 필자는 오픈 소스 생태계의 실루엣을 어느 정도나마 엿볼 수 있게 되었다. 그렇다면 왜 필자는 최근에서야 오픈 소스라는 주제에 관심을 가지게 되었을까? 그것은 필자의 경험 부족과 더불어 오픈 소스의 중요성이 수면 위로 뜨게 된 것이 얼마되지 않았기 때문라고 생각한다.</p>
<p>이는 그 누구의 잘못도 아닐뿐더러 이미 각 사분면의 구성원들이 노력하고 있었기 때문에 지금에서라도 수면 위로 드러난 것이기에 본격적인 이야기에 앞서 그들의 노고가 어떠했을지 마냥 고개를 조아리게 된다.</p>
<p>그래서 필자는 생태계 각 구성원들의 활약이 궁금해졌다. 주변인들이 국내 오픈 소스 생태계가 제대로 구성되어 있지 않다고 느낀 이유는 위에서 언급한 기업들 같은 <code class="language-text">VENDORS(DRIVERS)</code>의 부재 때문일까?</p>
<p>여기에 대한 답을 내리려면 보다 다양한 토론과 본질적인 문제에 대한 접근이 필요할 것이다.</p>
<blockquote>
<p>그럼에도 한 가지 확실한 것은 개인의 입장에서 오픈 소스에 기여하는 것 또한 중요하다는 것이다.</p>
</blockquote>
<p>가령 국내에서 오픈 소스 생태계에 관여하고 있는 기업이 다수 존재한다. 대표적으로 삼성과 네이버 또한 GitHub<a href="https://github.com/samsung">[7]</a><a href="https://github.com/naver">[8]</a>을 통해 국내 오픈 소스 생태계에 기여하고 있는 것을 쉽게 찾을 수 있다.</p>
<blockquote>
<p>물론 참여하고 있는 기업은 더 다양하다!</p>
</blockquote>
<p>그렇다면 필자가 찾고자 했던 근본적인 문제는 <code class="language-text">COMMUNITY</code>의 부재일까? 그렇지만도 않다. 그도 그럴 것이 자바스크립트 개발자 포럼<a href="https://jsdev.kr/">[9]</a>과 TensorflowKR<a href="https://www.facebook.com/groups/TensorFlowKR/">[10]</a>를 비롯한 여러 커뮤니티<a href="https://hamonikr.org/">[11]</a>, <a href="http://rankedin.kr/">[11-1]</a>, <a href="https://kldp.org/">[11-2]</a>가 이미 충분할 정도로 활성화되어있기 때문이다(오픈 소스만을 위한 커뮤니티로 활성화되어 있는지는 별개지만 말이다).</p>
<p>그렇다면 이제 남은 구성원인 <code class="language-text">USERS</code>와 <code class="language-text">EXPERTS</code>도 살펴보자.</p>
<p>잠시 전하자면 필자가 전하고자 하는 이 글의 목적은 단연코 <strong><code class="language-text">USERS</code>의 부재</strong>를 말하는 것이다. 여기서의 사용자는 프로젝트를 운영하는 메인테이너를 말하는 것이 아닌 컨트리뷰터를 의미한다. 이는 국내에 아무리 유명한 프로젝트가 많고, 훌륭한 메인테이너분들이 존재한다고 할지라도 이를 팔로우해줄 컨트리뷰터들이 없다면 이는 읽히지 않을 고전의 가치를 이야기하는 것과 같다고 생각하기 때문이다.</p>
<p>유저의 부재를 해결하기 위한 방법을 제시하기에는 이미 수많은 이들의 노고가 있었기 때문에 여기서 그것들을 다시 언급할 수는 없겠지만, 아직 견문이 짧은 필자가 느끼기에는 그들만의 리그가 구성되어 있는 것이 아닐까라고 생각했다. 한 마디로 진입장벽이 너무 높았다!</p>
<blockquote>
<p>이는 필자가 경험한 모든 오픈 소스 프로젝트들과 그 구성원들 모두가 체감하고 있으며 이를 위해 세세한 가이드를 제공하고 있다. 하지만 그럼에도 입문자에게 대부분의 오픈 소스는 기술에 대한 이해, 영어에 대한 언어적인 문제를 차치하고서라도 프로젝트에 기여하기 위해서는 커뮤니케이션 피드백이 늦다거나, 그 서비스가 무엇인지를 알아야 하고, 코어를 이해하지 못하면 쉽게 진입하기도 어렵기 때문에 느낀점이다.</p>
</blockquote>
<p>더불어 필자의 입장에서는 활성화되어 있다고 하는 여러 오픈 소스 프로젝트들과의 접점이 없어 기여하는 목정성을 느끼지 못하는 프로젝트가 대부분이었고, 이를 위한 각종 커뮤니티는 이미 오픈 소스의 장이 아닌 잡담의 장소 혹은 친목의 광장이었다.</p>
<blockquote>
<p>이를 부정적으로 생각하지는 않지만 마냥 '오픈 소스 커뮤니티'라는 느낌보다는 그저 개발에 대한 다양한 주제를 공유하는 커뮤니티라는 인식이 강했다.</p>
<p>참고로 필자에겐 리눅스 기반의 프로젝트 대부분은 과거 7080 전산실에서부터 내려오던 Nerd 성향이 강했다. '그냥 재미로'라는 리누스 토발즈의 자서전의 제목과는 상반되게 필자에게는 전혀 재미있지 않은 프로젝트였던 것이다.</p>
<p>추가적으로 이러한 주관적인 의견은 그러한 프로젝트나 커뮤니티를 폄하하려 한다기보다는 본인을 포함한 오픈 소스 입문자들의 기술 편식에 대해 이야기하고, 어떻게 하면 이를 극복할 수 있을까에 대한 고민을 해결하기 위해 공유한 것이니 커뮤니티에서 활동하시는 분들께 불편하게 느낄 수 있는 여지를 준 것에 대해 죄송하다는 말씀을 전하고 싶다.</p>
</blockquote>
<p>과거보다 오픈 소스 프로젝트의 사용자 수와 커뮤니티가 늘어난 것은 사실이지만 수가 늘어난 것과 생태계가 정상적으로 유지된다는 것은 별개의 이야기인 것 같다고 느꼈다.</p>
<p>이 글을 읽고 있는(이 글을 읽길 바라는) 독자들 중 일부는 GitHub과 같이 상대적으로 가시적인 소스 코드 호스팅 사이트에서조차 오픈 소스 프로젝트에 기여하기 위한 커밋 혹은 이슈보다는 자신의 프로젝트를 저장하기 위한 도구로 사용되고 있기 때문이다.</p>
<blockquote>
<p>물론 예외는 존재한다. 더이상의 논란은 독자 중 일부가 민감하게 받아드릴 수 있는 주제이기 때문에 넘어가도록 하자.</p>
</blockquote>
<p>결과적으로 필자는 보다 근본적으로 현 생태계의 문제를 따져보았을 때, "컨트리뷰터의 부재에 대한 책임은 결국 <code class="language-text">EXPERTS</code>에 있고, 그들이 주도적으로 <code class="language-text">Users</code>를 이끌어야만 건강한 생태계가 유지되는 것이 아닐까?"라는 생각을 했다.</p>
<p>국내에서는 기관 혹은 정부부처와 오픈 소스 저작권자(Maintainer)의 이해가 동일하지 않을 뿐더러 이해가 일치하더라도 이를 제대로 관리하려는 중앙 관리 기관의 역할도 제대로 수행되지 않는다고 느꼈기 때문이다.</p>
<blockquote>
<p>더이상의 발언은 문제의 여지로 발전할 것만 같아 말을 아끼지만 생태계에 대해서는 다양한 이해관계가 얽혀있어 도덕책처럼 이야기되는 위 그림의 생태계를 유지하기 어려운 것은 사실이라는 것을 깨닫게 되었다.</p>
</blockquote>
<p>이와 같은 시점에서 내가 할 수 있는 선택은 무엇이 있을까? 나는 오픈 소스라는 문화에 인생을 올인하여 장래를 이어나갈 생각도 없고, 그러한 사명을 느끼지도 못한다. 더불어 오픈 소스 프로젝트를 진행하는 것은 소소한 재미 혹은 알량한 명예를 위한 도구였을 뿐이고, 적절한 형상 관리를 위한 협업의 도구가 필요했기 때문이었다.</p>
<p>해외의 대부분 풀타임 오픈 소스 개발자들도 각자의 가치(명예, 재미, 금전적인 이익 등)를 추구하며 이에 대한 보상을 위해 그 길을 걷는 것인데, 이에 대한 보상은 커녕 푸대접뿐인 사회의 분위기 속에서 젊은이들은 그 속으로의 진입에 대해 리스키함을 넘어 실패에 대한 확증을 가지게 될까 걱정되기도 한다.</p>
<blockquote>
<p>필자에게 오픈 소스 프로젝트를 진행한다는 것은 자선사업을 하기 위한 것이 아니기 때문이다! 사회적인 명예 혹은 만족감, 뿌듯함과 같은 개인의 이익을 위해서이다!</p>
</blockquote>
<p>이러한 국내 오픈 소스 생태계를 보며 자란 필자와 같은 환경의 젊은 개발자 중에서 필자와 다른 의견을 가질 수 있는 이가 얼마나 있을지도 얼마나 있을까 싶어 필자의 "과연 나는 오픈 소스를 통해 원하고자 하는 가치를 얻을 수 있을까?"에 대한 고민이 깊어졌다.</p>
<p>가치를 추구하는 것은 개인의 자유지만 그에 대한 피드백은 확신할 수 없기 때문이다.</p>
<blockquote>
<p>여기까지 글을 쓴 필자에겐 우려가 되는 한 가지가 있다. 공개된 이 글을 읽는 독자의 신분은 다양할 것이고, 글을 소비하는 모든 이들의 입맛에 맞는 글을 써내려 간다는 것은 어려운 일이기 때문이다.</p>
<p>그렇기에 한 가지 당부의 말씀을 드리고 싶다. 필자의 글은 국내 오픈 소스와 관계된 어떠한 이해 관계도 고려하지않고 그저 필자가 느낀 심정을 써내려 온 것이라는 것이다. 따라서 이 글을 읽는 독자가 필자의 편향된 견해를 시장의 보편적인 정의로 이해하는 실수를 범하지 않길 바란다.</p>
<p>다시 한 번 강조하지만 필자는 오픈 소스로 학사 이상의 학위를 가지고 있지도, 어떠한 자격이나 권한도 없는 일개 개발자에 불과하다. 그래서 이 글을 읽으며 느낀 불편함은 그저 '잘 모르는 이야기' 혹은 '풋내나는 견해'라고 생각해주길 바라며 이에 양해를 구한다.</p>
</blockquote>
<p>앞으로 필자는 앞선 경험과 관점을 통해 스스로가 얻게 된 '내가 생각하는 오픈 소스를 활용하는 방법'에 대해 이야기하고자 한다. '오픈 소스'라는 단어는 이제 소프트웨어에 국한된 것만이 아닌 하드웨어에서의 기여도 활발하기 때문에 추후에 '오픈 소스 하드웨어'라는 주제를 이야기 할 수 있었으면 하는 개인적인 소망도 있다.</p>
<blockquote>
<p>물론 이는 앞서 우리가 탐구해본 주제와 사뭇 다를 수 있고, 단어의 선택에 대해 여러 진영에서의 불편함이 있을 수 있음을 유의해야 할 것이다.</p>
</blockquote>
<p>이렇게 줄글로만 필자의 생각을 전달한다고 해서 "그래! 오픈 소스, 나도 한 번 해보자!"하며 행동으로 실천할 수 있는 사람이 몇이나 있을까? 그래서 필자는 본 글을 시작으로 오픈 소스 기여를 다짐한 이들을 위해서나마 오픈 소스에 입문하기 위해 필요한 몇 가지 정보를 다음의 시리즈를 통해 하고자 한다.</p>
<p><a href="#">1. 오픈 소스 활용기(0) - 지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?</a><br>
<a href="#">2. 오픈 소스 활용기(1) - 개인 프로젝트 관리하기(준비중)</a><br>
<a href="#">3. 오픈 소스 활용기(2) - 팀 프로젝트 관리하기(준비중)</a><br>
<a href="#">4. 오픈 소스 활용기(3) - 유명 프로젝트 컨트리뷰터 되기(준비중)</a><br>
<a href="#">5. 오픈 소스 활용기(4) - 오픈소스 메인테이너 되기(준비중)</a><br>
<a href="#">6. 오픈 소스 활용기(5) - 한 편으로 끝나는 오픈소스 가이드(준비중)</a></p>
<blockquote>
<p>시리즈의 내용 또한 필자가 기록하고 싶은 것을 기록하기 위한 것이지 백과사전이 아님을 전하며, 주관적인 이야기가 아닌 펙트를 원한다면 전문가 분들의 이야기를 찾아 읽기를 바란다.</p>
</blockquote>
<p>마지막으로 필자가 위와 같은 시리즈를 연재하기로 한 이유를 공유하고자 한다. 필자가 경험한 '오픈 소스'라는 문화가 흥미로웠고 내가 알고 있는 기술로 다른 프로젝트에 기여하는 것에 재미를 느꼈기 때문에 스스로의 힘으로 오픈 소스에 빠져들고자 했던 과거의 필자가 필요로 했던 주제를 전하고 싶었다. 그것은 이 글과 같은 짧다면 짧은 한 편의 글이었기 때문이다.</p>
<p>다만, 앞으로의 글을 읽는 독자에게 한 가지 바라는 점이 있다면 글을 통해 얻은 정보와 지혜를 그대도 다른 이들에게 전하길 바란다는 것이다. 당장이라도 함께 공부하는 친구들에게, 주변의 동료에게 함께 오픈 소스를 시작하고자 다짐한다면 이 이상 건강한 문화를 만들기 위해 필요한 것도 없기 때문이다.</p>
<p>그럼 그대도 이 기회에 오픈 소스의 매력에 빠져보길 바란다!</p>
<blockquote>
<p>물론 오픈 소스로 생계를 유지할 생각을 하거나, 제 2의 리눅스를 꿈꾼다면 이 글이 아닌 전문가의 글을 참고하라. 제발.</p>
</blockquote>]]></description><link>https://rayleighko.github.io/blog/2019-01-30-what_is_opensource</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-01-30-what_is_opensource</guid><pubDate>Wed, 30 Jan 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;시작하기 전에&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 지극히 주관적인 관점, 즉 유명 오픈 소스의 메인테이너(관리자)가 아닌 순수히 취미 혹은 자기 계발을 위해 &apos;오픈 소스&apos;라는 도구를 활용해 그 문화에 입문하려는 이의 관점에서 쓰여진 글입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;오픈 소스&lt;/strong&gt;란 무엇일까? 필자는 지금까지 &lt;strong&gt;오픈 소스&lt;/strong&gt;라는 단어를 심심치 않게 들을 수 있었다. 하지만, 이 단어가 가진 의미를 정확하게 알기란 쉽지 않았다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 오픈 소스를 처음 접했을 때 주변의 누군가로부터 오픈 소스는 &lt;code class=&quot;language-text&quot;&gt;무료로 사용할 수 있는 코드&lt;/code&gt;라고, 또 다른 누군가로부터 &lt;code class=&quot;language-text&quot;&gt;돈이 안 되는 자선사업 혹은 그러한 서비스&lt;/code&gt;라는 이야기를 들었다. 한편으로는 취업을 준비하는 주변 친구들은 &lt;code class=&quot;language-text&quot;&gt;오픈 소스는 취업에 도움이 된다&lt;/code&gt;는 식의 뜬구름 잡는 이야기를 하기도 했다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 이 글을 통해 스스로 오픈 소스와 오픈 소스 생태계란 무엇인지를 고민해보고자 했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/92ddfeb0-23d1-11e9-b431-39bfc876f2e4/places-with-the-most-contributors.jpg&quot; alt=&quot;places-with-the-most-contributors.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 그림은 DashBouquet&lt;a href=&quot;https://dashbouquet.com/blog/web-development/github-octoverse-2018-overview-top-trends&quot;&gt;[1]&lt;/a&gt;에서 가져온 전 세계 컨트리뷰터 현황에 대한 자료이다. 이 자료만 보더라도 아시아 지역에서는 중국과 일본이 단연 앞서고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이 자료는 2017년 10월 1 일부터 2018년 9월 30일까지의 GitHub 트랜드 통계를 바탕으로 작성되었고, 국내 개발자의 수가 타국에 비해 현저히 적다는 점, 국내에서는 잘못된 인식으로 오픈 소스에 대한 편견이 지배적이기 때문에 완전히 객관적이라고는 할 수 없다. 하지만, 단편적으로나마 국내의 오픈 소스 프로젝트 생태계의 현 위치를 짐작할 수 있을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;필자는 이처럼 상대적으로 관심이 적은 국내의 오픈 소스 생태계를 개선하기 위해선 기본적으로 본질을 이해해야 접근할 수 있을 거라고 생각했다. 우선, 그 생태계를 이해하기에 앞서 왜 나는 오픈 소스라는 키워드를 가지고 이를 활용하려 할까? 왜 주변 사람들은 오픈 소스가 중요하다고 이야기하는 걸까?&lt;/p&gt;
&lt;h2&gt;오픈 소스란 무엇일까?&lt;/h2&gt;
&lt;p&gt;과거의 오픈 소스는 서론에서 말한 것과 같이 다양한 범주와 의견으로 정의할 수 있었다. 하지만, 현시점의 오픈 소스는 한 개인이 쉽게 정의할 것이 아니라고 생각한다. 그 이유는 필자가 나열하는 것보다 본 글을 읽다 보면 자연스럽게 느낄 수 있을 것이기 때문에 여기서 따로 언급하지는 않고, 일부 사례를 통해 이를 느껴보도록 하자.&lt;/p&gt;
&lt;p&gt;먼저, 위키피디아에서는 오픈 소스를 다음과 같이 정의하고 있다&lt;a href=&quot;https://en.wikipedia.org/wiki/Open_source&quot;&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Open source is a term denoting that a product includes permission to
use its source code, design documents, or content.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;한글로 해석하자면 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;오픈 소스는 제품에 대한 소스 코드, 디자인 문서 또는 콘텐츠를 사용할 수 있는 권한이 있음을 나타낸다.&amp;quot;&lt;/code&gt;라고 할 수 있다. 이를 통해 단편적이지만 &apos;오픈 소스&apos;라는 것은 어떠한 제품에 대한 지적 재산권을 나타낸다는 것을 알 수 있었다.&lt;/p&gt;
&lt;p&gt;이를 통해 필자는 &quot;그렇다면 오픈 소스 프로젝트 중에서 영리적인 사업을 하는 프로젝트들도 있나?&quot;라거나 &quot;소스 코드는 공개하지만, 오픈 소스의 수정은 거부하는 프로젝트들도 오픈 소스로서 존재할 수 있는 걸까?&quot;라는 의문이 들었지만 위 정의만으로 그 의문을 해결하기란 어려웠다.&lt;/p&gt;
&lt;p&gt;글을 작성하고 시간이 흘러 여러 피드백을 받아 수정하게 되면서 다음과 같은 힌트를 얻을 수 있었다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Debian에서 말한 &apos;Free&apos;와 &apos;Free Software&apos;의 의미&lt;a href=&quot;https://www.debian.org/intro/free.en.html?fbclid=IwAR1ou9joShVBLNWdU4NjOm05ztGxbohRo5B95g98q40hqLHFAX2tmuDUMtg&quot;&gt;[2-1]&lt;/a&gt;를 살펴보면, 여기서의 &apos;Free&apos;는 우리가 일상적으로 사용하는 의미 중 하나인 &apos;무료(at no cost)&apos;가 아닌 &apos;자유(freedom)&apos;를 나타낸다고 말한다.&lt;/p&gt;
&lt;p&gt;어쩌면 두 의미를 같다고 볼 수도 있지만, 필자가 느끼기에는 &apos;오픈 소스&apos;라는 단어가 가지는 &apos;Open&apos;의 의미가 &apos;프리웨어(공공제)&apos; 혹은 &apos;셰어웨어&apos;의 그것과는 전혀 다른 것이라고 느꼈다.&lt;/p&gt;
&lt;p&gt;이어 읽어나가다 보면 오픈 소스는 &apos;라이선스&apos;라는 것을 가지며, 이를 통해 오픈 소스는 지적 재산권이 있는 원작자의 요구에 맞게 사용되어야 한다는 구문이 서술되어 있다.&lt;/p&gt;
&lt;p&gt;이 점을 통해 &quot;오픈 소스를 한다&quot;라는 의미는 마냥 비용이 없는(at no cost) 소프트웨어를 만드는 의미가 아닌 &quot;원작자 즉, 개발자의 의도가 자유로이 반영되어 운영되는 프로젝트를 진행한다&quot;라는 의미가 아닐까 하는 생각도 들었다.&lt;/p&gt;
&lt;p&gt;또한, 글에서는 오픈 소스 제작자들이 체택하는 일반적인 라이선스 조합에 대해 소개하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Not allowing use of their code in proprietary software. Since they are releasing their code for all to use, they don&apos;t want to see others steal it. In this case, use of the code is seen as a trust: you may use it, as long as you play by the same rules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Protecting identity of authorship of the code. People take great pride in their work and do not want someone else to come along and remove their name from it or claim that they wrote it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Distribution of source code. One of the problems with most proprietary software is that you can&apos;t fix bugs or customize it since the source code is not available. Also, the company may decide to stop supporting the hardware you use. Many free licenses force the distribution of the source code. This protects the user by allowing them to customize the software for their needs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Forcing any work that includes part of their work (such works are called derived works in copyright discussions) to use the same license.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 한글로 해석해보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;독점적인 소프트웨어에서의 코드 사용을 거부합니다. 그들은 모두가 사용할 수 있도록 코드를 제공하지 않기 때문에 다른 사람들이 이것을 훔치려는 것을 보고싶지 않습니다. 이 사례는 &apos;코드의 사용&apos;을 &apos;신뢰&apos;라고 봅니다: 이 경우 동일한 라이선스의 규칙을 적용하면 코드를 사용할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 원작자의 신원을 보호합니다. 사람들은 그들의 일에 큰 자부심을 느끼고 있기에 원작자의 이름을 지우거나 자신이 쓴 것이라고 주장하지 말아야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소스 코드의 배포(를 강제합니다). 독점 소프트웨어의 문제 중 하나는 소스 코드를 사용할 수 없기 때문에 사용자가 직접 버그를 수정하거나 맞춤화(customize)하는 것이 불가능하다는 것입니다. 또한, 회사는 귀하가 사용하는 하드웨어의 지원을 중단할 수도 있습니다. 많은 자유(Free) 라이선스들이 소스 코드의 배포를 강제하고 있습니다. 이는 사용자가 자신의 필요에 맞게 소프트웨어를 맞춤화할 수 있도록하여 사용자를 보호합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;저작물의 일부를 포함하는 저작물(&apos;Copyright Discussions&apos;에서 &lt;em&gt;파생 저작물&lt;/em&gt;이라고 정의함)이 동일한 라이선스를 사용하도록 강요합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필자는 이 문장들을 읽고 많은 오픈 소스 프로젝트는 원작자의 라이선스에 명시된 의도를 훼손하지 않는다면, 그의 저작물 사용이 가능하다는 것을 말하고자 하는 것이라 생각했다.&lt;/p&gt;
&lt;p&gt;더불어 글의 다음 단락에서는 많은 사람들이 자체 라이선스를 쓰게 되면 모호한 문구 혹은 미묘한 문제가 되는 문장의 사용이 법적 문제에서 원작자의 권한을 침해할 수 있는 것을 우려해 가장 널리 사용되는 라이선스에 대해서도 소개한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;http://www.gnu.org/copyleft/gpl.html&quot;&gt;GNU General Public License (GPL)&lt;/a&gt;. Some good background information on software licenses and a copy of the license can be found at the GNU web site. This is the most common free license in use in the world.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.org/licenses/artistic-license.php&quot;&gt;Artistic License.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.debian.org/misc/bsd.license&quot;&gt;BSD style license.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 라이선스들은 다음과 같은 공통점을 지닌다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can install the software on as many machines as you want.&lt;/li&gt;
&lt;li&gt;Any number of people may use the software at one time.&lt;/li&gt;
&lt;li&gt;You can make as many copies of the software as you want and give them to whomever you want (free or open redistribution).&lt;/li&gt;
&lt;li&gt;There are no restrictions on modifying the software (except for keeping certain notices intact).&lt;/li&gt;
&lt;li&gt;There is no restriction on distributing, or even selling, the software.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;마지막으로 OSI(Open Source Initiative)에서는 The Open Source Definition&lt;a href=&quot;https://opensource.org/osd&quot;&gt;[2-2]&lt;/a&gt;에서 다음 10가지의 문장으로 Open Source를 정의한다는 것도 알아두도록 하자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;자유 배포(Free Redistribution)&lt;/li&gt;
&lt;li&gt;소스코드 공개(Source Code Open)&lt;/li&gt;
&lt;li&gt;2차적 저작물(의 허용)(Derived Works)&lt;/li&gt;
&lt;li&gt;원작자의 소스코드 수정 제한(Integrity of The Author&apos;s Source Code)&lt;/li&gt;
&lt;li&gt;개인이나 단체에 대한 차별 금지(No Discrimination Against Persons or Groups)&lt;/li&gt;
&lt;li&gt;사용 분야에 대한 제한 금지(No Discrimination Against Fields of Endeavor)&lt;/li&gt;
&lt;li&gt;라이선스의 배포 (Distribution of License)&lt;/li&gt;
&lt;li&gt;라이선스 적용상의 동일성 유지 (License must not be specific to a product)&lt;/li&gt;
&lt;li&gt;다른 라이선스의 포괄적 수용 (License must not contaminate other software)&lt;/li&gt;
&lt;li&gt;라이선스의 기술적 중립성 (License must be Technology-Neutral)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;이 Open Source Definition은 &lt;a href=&quot;(https://www.debian.org/social_contract#guidelines)&quot;&gt;Debian Free Software Guidelines&lt;/a&gt;(DFSG)에서 유래되었다는 것을 알아두고 이를 참고하도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;글을 작성 및 수정하며 얻은 소감은 Debian에서 제공한 가이드라인과 OSI의 가이드라인은 약간 다를 뿐 거의 유사하다는 것이고, 근래에 들어서는 Free와 Open을 나누지않고 FOSS(Free &amp;#x26; Open Source Software)라 칭한다는 것이다.&lt;/p&gt;
&lt;p&gt;더불어 오픈 소스의 Open이 가지는 의미는 공짜가 아닌 소스 코드 및 SW의 자유로운 사용이라는 것을 알게 되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추가적으로 필자는 OSI의 창립자 레이몬드가 칭한 &apos;오픈 소스&apos;라는 단어는 상업화(Commercialization)에 대한 반대급부라고 이해했다. 하지만 그럼에도 왜 Open Source Software라고 부르며 이를 &apos;소프트웨어&apos;라 제품화를 시키는 것일까? 코드는 그저 특정 문제를 해결하기 위한 명세로 이야기되는 것이 아닌가? 왜 이를 위한 제품이 &apos;오픈 소스&apos;로서 이야기될 수 있는 것일까?&lt;/p&gt;
&lt;p&gt;이러한 고민을 하게 된 까닭은 오픈 소스 소프트웨어라 칭함으로 인해 오픈 소스는 그 자체로 자유로운 의미로서 상업화의 반대급부로 정의하지만, 이를 활용하는 비즈니스 모델의 존재에 대한 여지를 주기 때문이다. 비즈니스 모델이 있는 오픈 소스 서비스들은 오픈 소스 문화에 동참하지 않는 것일까? 이러한 고민의 답은 다음의 &apos;RedHat&apos;의 사례를 통해 힌트를 얻어보도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;오픈 소스를 활용한 서비스들&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/02e275c0-23d6-11e9-bf21-f7a982ab1aa4/ap550x55016x121transparentt.png&quot; alt=&quot;ap,550x550,16x12,1,transparent,t.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 그림&lt;a href=&quot;https://www.google.com/url?sa=i&amp;#x26;source=images&amp;#x26;cd=&amp;#x26;ved=2ahUKEwixjszon5PgAhXJ7WEKHRfWAwIQjRx6BAgBEAU&amp;#x26;url=https%3A%2F%2Fwww.redbubble.com%2Fpeople%2Fradixvinni%2Fworks%2F30430581-developer-icons-open-source-project-logos-web-companies%3Fp%3Dart-print&amp;#x26;psig=AOvVaw1ePP6ojSivrUxMGaEoLdwx&amp;#x26;ust=1548860098305404&quot;&gt;[3]&lt;/a&gt;을 보면 우리가 흔히 접했던 프로젝트부터 난생처음 보는 프로젝트까지 다양하게 있는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;위의 로고 중 필자가 아는 서비스에 한해 오픈 소스와 밀접한 관계가 있는 저작물을 소개해보려 한다.&lt;/p&gt;
&lt;p&gt;가장 먼저 보이는 &lt;code class=&quot;language-text&quot;&gt;RedHat&lt;/code&gt;은 대표적으로 오픈 소스를 통해 비즈니스를 하는 회사이다. 그들이 제공하는 저작물은 리눅스 운영체제가 대표적이고, 오픈 소스이기 때문에 기본적으로 자유로이 사용하는 것이 가능하다.&lt;/p&gt;
&lt;p&gt;그렇다면 그들은 어떤 비즈니스 모델을 가지고 있을까? 어떻게 돈을 벌고, 이를 유지하고 있을까? 이에 대한 답을 고민하던 중 Quora의 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;What is Red Hat&amp;#39;s business model?&amp;quot;&lt;/code&gt;라는 질문을 보게 되었는데, 이를 RedHat의 한 직원이 설명한 글&lt;a href=&quot;https://www.quora.com/What-is-Red-Hats-business-model&quot;&gt;[4]&lt;/a&gt;을 통해 조금이나마 해결할 수 있었다. 그 중 일부는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Red Hat doesn&amp;#39;t sell software. You can download the software for free.

Red Hat sells service/support subscriptions.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Red Hat은 소프트웨어를 판매하지 않습니다. 무료로 소프트웨어를 다운로드 할 수 있습니다.

Red Hat은 서비스, 지원 구독(Support Subscription)을 판매합니다.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;글에서는 RedHat은 소프트웨어를 &apos;판매&apos;하지 않고, 소프트웨어를 사용하는 데 필요한 서비스와 Support Subscription을 판매한다고 이야기한다(최근에는 고도화된 소프트웨어를 판매하기도 한다). 그래서 그는 자신들의 제품인 &lt;strong&gt;RHEL, Fedora&lt;/strong&gt; 또는 &lt;strong&gt;CentOS&lt;/strong&gt;를 다운로드하고, 수정하며 원하는대로 직접 컴파일하는 것을 자유로이 할 수 있다고 설명했다.&lt;/p&gt;
&lt;p&gt;또한, 이와는 별개로 RedHat의 서비스가 제대로 작동되지 않을 때 RedHat의 지원을 받기 위해서는 Support Subscription 서비스에 대한 비용을 지불해야 한다는 식으로 이야기한다.&lt;/p&gt;
&lt;p&gt;이런 비즈니스 모델을 가지고 있기 때문에 RedHat은 오픈 소스의 범주 안에서 경영을 할 수 있고, 오픈 소스를 활용한 사업의 선사례로 꼽히는 모양이다. 더불어 RedHat은 &apos;오픈 소스 소프트웨어&apos;를 운영하고 있기 때문에 이에 대한 서비스 개선을 계속해서 진행한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Quora의 글을 읽기 전까지 필자는 레드헷의 제품이 단순하게 무료와 유료 버전으로 나뉘어져 있고, 사용자에게는 각각 다른 가치를 얻는다고 생각했다. 하지만 RedHat이 가진 가치는 그것이 아닌 오픈 소스라는 이름에 걸맞는 것이었다고 느끼게 되어 감사하게 읽었다.&lt;/p&gt;
&lt;p&gt;이를 통해 필자는 RedHat은 오픈 소스라는 매개 자체로 비즈니스 모델을 구축했다기 보다는 오픈 소스를 활용한 저작물을 통해 비즈니스 모델을 구축한 것이라고 이해할 수 있었다. 그렇다면 오픈 소스 소프트웨어는 오픈 소스를 활용한 소프트웨어라고 이해하는 것이 맞을까? 이렇게 이해한다면 품고 있던 수익성에 대한 의문은 말끔히 정리될테니 말이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;다시 앞선 그림으로 돌아가 다른 사례를 고민하던 중 프로그래밍 언어 중 하나인 &lt;code class=&quot;language-text&quot;&gt;C/C++&lt;/code&gt;에 대해 궁금해졌다. 프로그래밍 언어도 오픈 소스와 관련이 있을까? 보통 컴파일 언어를 사용하기 위해서는 컴파일러라는 소프트웨어가 필수적으로 필요한데, 이때 사용하는 컴파일러들은 지금껏 의식없이 사용했었으니 말이다.&lt;/p&gt;
&lt;p&gt;이와 더불어 프로그래밍 언어에서 사용하는 각종 라이브러리 혹은 패키지같이 언어를 둘러싼 모든 환경에서 오픈 소스가 사용될 수 있을 것이다. 우리가 흔히 사용하는 컴파일러 중에는 오픈 소스인 것들도 다양할 것이고, 세상에는 다양한 언어와 이를 둘러싼 환경이 있을 것이기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;러프하게 알 수 있는 오픈 소스 컴파일러 목록은 이 곳&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_compilers&quot;&gt;[5]&lt;/a&gt;에서 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;추가적으로 프로그래밍 언어 같은 경우는 보편적으로 사용자에게 공공제로 제공되지만, 언어의 표준과 같이 특정 규율을 정하는 것은 별도의 기구(ISO&lt;a href=&quot;https://www.iso.org/&quot;&gt;[5-1]&lt;/a&gt;)에서 관리하기도 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;code class=&quot;language-text&quot;&gt;C/C++&lt;/code&gt;과 같은 프로그래밍 언어 또한 오픈 소스와 밀접하며, 이를 위한 오픈 소스 컴파일러는 당연히 소스 코드를 공개하고 이를 수정할 수 있다&lt;a href=&quot;https://gcc.gnu.org/&quot;&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이쯤에서 다음과 같은 의문이 들 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;그렇다면 오픈 소스가 아닌 건 무엇일까?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지 쓰고 난 본인의 견해로는 이에 대한 답을 내리기 위해서는 &lt;strong&gt;오픈 소스가 아닌 것&lt;/strong&gt;을 나열하기보다 &lt;strong&gt;오픈 소스인 것&lt;/strong&gt;을 고민해야 한다고 느꼈다. 그렇기 때문에 만약 오픈 소스에 대해 보다 깊은 이해를 원하는 독자는 다음의 자료를 참고하길 바란다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.debian.org/intro/free.en.html&quot;&gt;https://www.debian.org/intro/free.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gnu.org/philosophy/free-sw.en.html&quot;&gt;https://www.gnu.org/philosophy/free-sw.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.org/osd-annotated&quot;&gt;https://opensource.org/osd-annotated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;글을 수정하며 얻은 다양한 조언을 통해서 이제는 &apos;오픈 소스&apos;라는 단어가 각 개인의 의견으로 정의될 수 없다고 생각이 굳어졌다(그 정의에 대한 서적은 이미 차고 넘치기 때문이다).&lt;/p&gt;
&lt;p&gt;물론 그 정의에 대한 각 개인의 이해와 파생된 견해가 다를 수 있겠지만 결과적으로 과거부터 이야기되어 현재에 이르러서는 논쟁의 여지가 수그러든 것이기 때문에 앞선 것과 같이 &apos;오픈 소스는 이미 정의되어 있다&apos;라고 생각을 굳힐 수 있었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기까지 글을 적으며 필자는 오픈 소스에 대해 어렴풋이 이해할 수 있게 되었다고 생각한다. 그럼에도 아직 오픈 소스를 둘러싸고 있는 그 환경에 대해서는 익숙하지 않다.&lt;/p&gt;
&lt;p&gt;주변에서는 국내 오픈 소스 생태계에 불만을 품은 이들도 상당하다. 그들은 왜 그런 불만을 가지고 있을까? 그래서 이번에는 오픈 소스 생태계란 무엇인지를 살펴보도록 하자.&lt;/p&gt;
&lt;h2&gt;오픈 소스 생태계란 무엇일까?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/9f6299c0-23db-11e9-bf21-f7a982ab1aa4/2016-2017-trends-open-source-ecosystem.jpg&quot; alt=&quot;2016-2017-trends-open-source-ecosystem.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 그림&lt;a href=&quot;https://www.google.com/url?sa=i&amp;#x26;source=images&amp;#x26;cd=&amp;#x26;ved=2ahUKEwjrho_4qJPgAhWWad4KHd4VAy8QjRx6BAgBEAU&amp;#x26;url=https%3A%2F%2Fwww.altoros.com%2Fblog%2F2016-2017-trends-the-open-source-ecosystem-is-universal%2F&amp;#x26;psig=AOvVaw1t-rgseFFa4Lscy9er3gEc&amp;#x26;ust=1548862555751385&quot;&gt;[7]&lt;/a&gt;은 단일 오픈 소스 생태계를 가시적으로 보여준다고 느껴서 가져왔다.&lt;/p&gt;
&lt;p&gt;이 그림은 &lt;strong&gt;단일 오픈 소스를 활용한 솔루션&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;VENDORS&lt;/code&gt;, &lt;strong&gt;단일 오픈 소스를 지원&lt;/strong&gt;하는 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;와 &lt;strong&gt;단일 오픈 소스에 대한 조언, 기여 등&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;COMMUNITY&lt;/code&gt;, 마지막으로 &lt;strong&gt;단일 오픈 소스와 이로 만들어진 솔루션들에 대한 피드백&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;로서 4사분면을 그리며 선순환을 이루고 있다.&lt;/p&gt;
&lt;p&gt;이러한 선순환의 결과는 오픈 소스 생태계의 확장으로 이어질 것이고, &quot;결과적으로 다양한 프로젝트들의 유지력도 향상될 수 있지 않을까?&quot;라는 생각도 해봤다.&lt;/p&gt;
&lt;p&gt;또한, 그렇게 된다면 사용자의 관점에서도, 기업의 관점에서도 오픈 소스라는 주제가 매력적으로 다가올 수 있지 않을까라는 결론도 조심스럽게 내려보았다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서의 매력은 각기 다르게 이야기될 수 있을 것이다. &apos;비용적인&apos; 측면을 차치하고 말이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만, 이처럼 건강한 생태계를 유지하기는 쉽지 않을 것만 같다. 프로젝트가 커짐에 따라 한 개인이 관리하기에는 부담스러울뿐더러 기업의 입장에서도 하나의 생태계를 책임진다는 것은 큰 위험 부담을 감수하는 것이기 때문이다. 그렇다고 국가(정부기관)가 떠안기에는 상대적으로 이해관계가 성립되기 힘들다는 생각도 해봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이러한 위험 부담에도 생태계를 책임지고 있는 &lt;code class=&quot;language-text&quot;&gt;Google&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;Facebook&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Alibaba&lt;/code&gt; 등이 있는 것도 사실이고 미국이나 독일 등 다양한 국가에서 정부 차원의 지원이 있는 것은 사실이기에 이 부분은 국내의 정서로 받아들이기에는 다소 민감할 수 있겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;이제 필자는 오픈 소스 생태계의 실루엣을 어느 정도나마 엿볼 수 있게 되었다. 그렇다면 왜 필자는 최근에서야 오픈 소스라는 주제에 관심을 가지게 되었을까? 그것은 필자의 경험 부족과 더불어 오픈 소스의 중요성이 수면 위로 뜨게 된 것이 얼마되지 않았기 때문라고 생각한다.&lt;/p&gt;
&lt;p&gt;이는 그 누구의 잘못도 아닐뿐더러 이미 각 사분면의 구성원들이 노력하고 있었기 때문에 지금에서라도 수면 위로 드러난 것이기에 본격적인 이야기에 앞서 그들의 노고가 어떠했을지 마냥 고개를 조아리게 된다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 생태계 각 구성원들의 활약이 궁금해졌다. 주변인들이 국내 오픈 소스 생태계가 제대로 구성되어 있지 않다고 느낀 이유는 위에서 언급한 기업들 같은 &lt;code class=&quot;language-text&quot;&gt;VENDORS(DRIVERS)&lt;/code&gt;의 부재 때문일까?&lt;/p&gt;
&lt;p&gt;여기에 대한 답을 내리려면 보다 다양한 토론과 본질적인 문제에 대한 접근이 필요할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그럼에도 한 가지 확실한 것은 개인의 입장에서 오픈 소스에 기여하는 것 또한 중요하다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;가령 국내에서 오픈 소스 생태계에 관여하고 있는 기업이 다수 존재한다. 대표적으로 삼성과 네이버 또한 GitHub&lt;a href=&quot;https://github.com/samsung&quot;&gt;[7]&lt;/a&gt;&lt;a href=&quot;https://github.com/naver&quot;&gt;[8]&lt;/a&gt;을 통해 국내 오픈 소스 생태계에 기여하고 있는 것을 쉽게 찾을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 참여하고 있는 기업은 더 다양하다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그렇다면 필자가 찾고자 했던 근본적인 문제는 &lt;code class=&quot;language-text&quot;&gt;COMMUNITY&lt;/code&gt;의 부재일까? 그렇지만도 않다. 그도 그럴 것이 자바스크립트 개발자 포럼&lt;a href=&quot;https://jsdev.kr/&quot;&gt;[9]&lt;/a&gt;과 TensorflowKR&lt;a href=&quot;https://www.facebook.com/groups/TensorFlowKR/&quot;&gt;[10]&lt;/a&gt;를 비롯한 여러 커뮤니티&lt;a href=&quot;https://hamonikr.org/&quot;&gt;[11]&lt;/a&gt;, &lt;a href=&quot;http://rankedin.kr/&quot;&gt;[11-1]&lt;/a&gt;, &lt;a href=&quot;https://kldp.org/&quot;&gt;[11-2]&lt;/a&gt;가 이미 충분할 정도로 활성화되어있기 때문이다(오픈 소스만을 위한 커뮤니티로 활성화되어 있는지는 별개지만 말이다).&lt;/p&gt;
&lt;p&gt;그렇다면 이제 남은 구성원인 &lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;도 살펴보자.&lt;/p&gt;
&lt;p&gt;잠시 전하자면 필자가 전하고자 하는 이 글의 목적은 단연코 &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;의 부재&lt;/strong&gt;를 말하는 것이다. 여기서의 사용자는 프로젝트를 운영하는 메인테이너를 말하는 것이 아닌 컨트리뷰터를 의미한다. 이는 국내에 아무리 유명한 프로젝트가 많고, 훌륭한 메인테이너분들이 존재한다고 할지라도 이를 팔로우해줄 컨트리뷰터들이 없다면 이는 읽히지 않을 고전의 가치를 이야기하는 것과 같다고 생각하기 때문이다.&lt;/p&gt;
&lt;p&gt;유저의 부재를 해결하기 위한 방법을 제시하기에는 이미 수많은 이들의 노고가 있었기 때문에 여기서 그것들을 다시 언급할 수는 없겠지만, 아직 견문이 짧은 필자가 느끼기에는 그들만의 리그가 구성되어 있는 것이 아닐까라고 생각했다. 한 마디로 진입장벽이 너무 높았다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 필자가 경험한 모든 오픈 소스 프로젝트들과 그 구성원들 모두가 체감하고 있으며 이를 위해 세세한 가이드를 제공하고 있다. 하지만 그럼에도 입문자에게 대부분의 오픈 소스는 기술에 대한 이해, 영어에 대한 언어적인 문제를 차치하고서라도 프로젝트에 기여하기 위해서는 커뮤니케이션 피드백이 늦다거나, 그 서비스가 무엇인지를 알아야 하고, 코어를 이해하지 못하면 쉽게 진입하기도 어렵기 때문에 느낀점이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;더불어 필자의 입장에서는 활성화되어 있다고 하는 여러 오픈 소스 프로젝트들과의 접점이 없어 기여하는 목정성을 느끼지 못하는 프로젝트가 대부분이었고, 이를 위한 각종 커뮤니티는 이미 오픈 소스의 장이 아닌 잡담의 장소 혹은 친목의 광장이었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이를 부정적으로 생각하지는 않지만 마냥 &apos;오픈 소스 커뮤니티&apos;라는 느낌보다는 그저 개발에 대한 다양한 주제를 공유하는 커뮤니티라는 인식이 강했다.&lt;/p&gt;
&lt;p&gt;참고로 필자에겐 리눅스 기반의 프로젝트 대부분은 과거 7080 전산실에서부터 내려오던 Nerd 성향이 강했다. &apos;그냥 재미로&apos;라는 리누스 토발즈의 자서전의 제목과는 상반되게 필자에게는 전혀 재미있지 않은 프로젝트였던 것이다.&lt;/p&gt;
&lt;p&gt;추가적으로 이러한 주관적인 의견은 그러한 프로젝트나 커뮤니티를 폄하하려 한다기보다는 본인을 포함한 오픈 소스 입문자들의 기술 편식에 대해 이야기하고, 어떻게 하면 이를 극복할 수 있을까에 대한 고민을 해결하기 위해 공유한 것이니 커뮤니티에서 활동하시는 분들께 불편하게 느낄 수 있는 여지를 준 것에 대해 죄송하다는 말씀을 전하고 싶다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과거보다 오픈 소스 프로젝트의 사용자 수와 커뮤니티가 늘어난 것은 사실이지만 수가 늘어난 것과 생태계가 정상적으로 유지된다는 것은 별개의 이야기인 것 같다고 느꼈다.&lt;/p&gt;
&lt;p&gt;이 글을 읽고 있는(이 글을 읽길 바라는) 독자들 중 일부는 GitHub과 같이 상대적으로 가시적인 소스 코드 호스팅 사이트에서조차 오픈 소스 프로젝트에 기여하기 위한 커밋 혹은 이슈보다는 자신의 프로젝트를 저장하기 위한 도구로 사용되고 있기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 예외는 존재한다. 더이상의 논란은 독자 중 일부가 민감하게 받아드릴 수 있는 주제이기 때문에 넘어가도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과적으로 필자는 보다 근본적으로 현 생태계의 문제를 따져보았을 때, &quot;컨트리뷰터의 부재에 대한 책임은 결국 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;에 있고, 그들이 주도적으로 &lt;code class=&quot;language-text&quot;&gt;Users&lt;/code&gt;를 이끌어야만 건강한 생태계가 유지되는 것이 아닐까?&quot;라는 생각을 했다.&lt;/p&gt;
&lt;p&gt;국내에서는 기관 혹은 정부부처와 오픈 소스 저작권자(Maintainer)의 이해가 동일하지 않을 뿐더러 이해가 일치하더라도 이를 제대로 관리하려는 중앙 관리 기관의 역할도 제대로 수행되지 않는다고 느꼈기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;더이상의 발언은 문제의 여지로 발전할 것만 같아 말을 아끼지만 생태계에 대해서는 다양한 이해관계가 얽혀있어 도덕책처럼 이야기되는 위 그림의 생태계를 유지하기 어려운 것은 사실이라는 것을 깨닫게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이와 같은 시점에서 내가 할 수 있는 선택은 무엇이 있을까? 나는 오픈 소스라는 문화에 인생을 올인하여 장래를 이어나갈 생각도 없고, 그러한 사명을 느끼지도 못한다. 더불어 오픈 소스 프로젝트를 진행하는 것은 소소한 재미 혹은 알량한 명예를 위한 도구였을 뿐이고, 적절한 형상 관리를 위한 협업의 도구가 필요했기 때문이었다.&lt;/p&gt;
&lt;p&gt;해외의 대부분 풀타임 오픈 소스 개발자들도 각자의 가치(명예, 재미, 금전적인 이익 등)를 추구하며 이에 대한 보상을 위해 그 길을 걷는 것인데, 이에 대한 보상은 커녕 푸대접뿐인 사회의 분위기 속에서 젊은이들은 그 속으로의 진입에 대해 리스키함을 넘어 실패에 대한 확증을 가지게 될까 걱정되기도 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필자에게 오픈 소스 프로젝트를 진행한다는 것은 자선사업을 하기 위한 것이 아니기 때문이다! 사회적인 명예 혹은 만족감, 뿌듯함과 같은 개인의 이익을 위해서이다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 국내 오픈 소스 생태계를 보며 자란 필자와 같은 환경의 젊은 개발자 중에서 필자와 다른 의견을 가질 수 있는 이가 얼마나 있을지도 얼마나 있을까 싶어 필자의 &quot;과연 나는 오픈 소스를 통해 원하고자 하는 가치를 얻을 수 있을까?&quot;에 대한 고민이 깊어졌다.&lt;/p&gt;
&lt;p&gt;가치를 추구하는 것은 개인의 자유지만 그에 대한 피드백은 확신할 수 없기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기까지 글을 쓴 필자에겐 우려가 되는 한 가지가 있다. 공개된 이 글을 읽는 독자의 신분은 다양할 것이고, 글을 소비하는 모든 이들의 입맛에 맞는 글을 써내려 간다는 것은 어려운 일이기 때문이다.&lt;/p&gt;
&lt;p&gt;그렇기에 한 가지 당부의 말씀을 드리고 싶다. 필자의 글은 국내 오픈 소스와 관계된 어떠한 이해 관계도 고려하지않고 그저 필자가 느낀 심정을 써내려 온 것이라는 것이다. 따라서 이 글을 읽는 독자가 필자의 편향된 견해를 시장의 보편적인 정의로 이해하는 실수를 범하지 않길 바란다.&lt;/p&gt;
&lt;p&gt;다시 한 번 강조하지만 필자는 오픈 소스로 학사 이상의 학위를 가지고 있지도, 어떠한 자격이나 권한도 없는 일개 개발자에 불과하다. 그래서 이 글을 읽으며 느낀 불편함은 그저 &apos;잘 모르는 이야기&apos; 혹은 &apos;풋내나는 견해&apos;라고 생각해주길 바라며 이에 양해를 구한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞으로 필자는 앞선 경험과 관점을 통해 스스로가 얻게 된 &apos;내가 생각하는 오픈 소스를 활용하는 방법&apos;에 대해 이야기하고자 한다. &apos;오픈 소스&apos;라는 단어는 이제 소프트웨어에 국한된 것만이 아닌 하드웨어에서의 기여도 활발하기 때문에 추후에 &apos;오픈 소스 하드웨어&apos;라는 주제를 이야기 할 수 있었으면 하는 개인적인 소망도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이는 앞서 우리가 탐구해본 주제와 사뭇 다를 수 있고, 단어의 선택에 대해 여러 진영에서의 불편함이 있을 수 있음을 유의해야 할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 줄글로만 필자의 생각을 전달한다고 해서 &quot;그래! 오픈 소스, 나도 한 번 해보자!&quot;하며 행동으로 실천할 수 있는 사람이 몇이나 있을까? 그래서 필자는 본 글을 시작으로 오픈 소스 기여를 다짐한 이들을 위해서나마 오픈 소스에 입문하기 위해 필요한 몇 가지 정보를 다음의 시리즈를 통해 하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#&quot;&gt;1. 오픈 소스 활용기(0) - 지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;2. 오픈 소스 활용기(1) - 개인 프로젝트 관리하기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;3. 오픈 소스 활용기(2) - 팀 프로젝트 관리하기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;4. 오픈 소스 활용기(3) - 유명 프로젝트 컨트리뷰터 되기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;5. 오픈 소스 활용기(4) - 오픈소스 메인테이너 되기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;6. 오픈 소스 활용기(5) - 한 편으로 끝나는 오픈소스 가이드(준비중)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시리즈의 내용 또한 필자가 기록하고 싶은 것을 기록하기 위한 것이지 백과사전이 아님을 전하며, 주관적인 이야기가 아닌 펙트를 원한다면 전문가 분들의 이야기를 찾아 읽기를 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마지막으로 필자가 위와 같은 시리즈를 연재하기로 한 이유를 공유하고자 한다. 필자가 경험한 &apos;오픈 소스&apos;라는 문화가 흥미로웠고 내가 알고 있는 기술로 다른 프로젝트에 기여하는 것에 재미를 느꼈기 때문에 스스로의 힘으로 오픈 소스에 빠져들고자 했던 과거의 필자가 필요로 했던 주제를 전하고 싶었다. 그것은 이 글과 같은 짧다면 짧은 한 편의 글이었기 때문이다.&lt;/p&gt;
&lt;p&gt;다만, 앞으로의 글을 읽는 독자에게 한 가지 바라는 점이 있다면 글을 통해 얻은 정보와 지혜를 그대도 다른 이들에게 전하길 바란다는 것이다. 당장이라도 함께 공부하는 친구들에게, 주변의 동료에게 함께 오픈 소스를 시작하고자 다짐한다면 이 이상 건강한 문화를 만들기 위해 필요한 것도 없기 때문이다.&lt;/p&gt;
&lt;p&gt;그럼 그대도 이 기회에 오픈 소스의 매력에 빠져보길 바란다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 오픈 소스로 생계를 유지할 생각을 하거나, 제 2의 리눅스를 꿈꾼다면 이 글이 아닌 전문가의 글을 참고하라. 제발.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>