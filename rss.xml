<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RayLog]]></title><description><![CDATA[Technical blog]]></description><link>http://github.com/dylang/node-rss</link><generator>RSS for Node</generator><lastBuildDate>Mon, 08 Apr 2019 03:33:51 GMT</lastBuildDate><item><title><![CDATA[WePlanet Intern - study docker]]></title><description><![CDATA[<h1>WePlanet Intern - study - Docker</h1>
<h2>이번 스터디 목표</h2>
<p><a href="https://aws.amazon.com/ko/docker/">AWS - Docker란 무엇입니까?</a>를 참고하여 Docker에 대한 학습을 하는 것이 이번 스터디의 목적이다.</p>
<p>사실 이번에 시작한 프로젝트에서 Docker를 사용하기 때문에 이를 학습하여 보다 나은 이해를 하고자 함이다.</p>
<p>우선 위에서 언급한 <a href="https://aws.amazon.com/ko/docker/">AWS - Docker란 무엇입니까?</a>를 살펴보면
Docker의 정의, 작동 방식, 사용해야 하는 이유, 사용하는 경우 등을 설명한다. 그래서 우리도 마찬가지로 이것들을
살펴보고 어떻게 하면 도커를 잘 사용할 수 있을지를 생각해보자.</p>
<p>언제나 말하지만 기술은 그냥 사용하는 게 아닌 '잘' 사용해야 하기 때문이다.</p>
<p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html">참고자료 - 초보를 위한 도커 안내서</a></p>
<h3>Docker란 무엇인가?</h3>
<p>우선 Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.</p>
<p>소프트웨어를 컨테이너라는 표준화된 유닛으로 패키징하며, 이 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등
소프트웨어를 실행하는 데 필요한 모든 것이 포함되어 있다.</p>
<p>그래서 Docker를 사용하면 개발 환경에 구애받지 않고 애플리케이션을 신속하게 배포 및 확장할 수 있다.
즉, Docker를 사용하면 서비스마다 다른 개발 환경에 대한 스트레스가 줄어든다는 의미가 될 것이다.</p>
<h3>Docker의 작동 방식</h3>
<p><img src="https://d1.awsstatic.com/Developer%20Marketing/containers/monolith_2-VM-vs-Containers.78f841efba175556d82f64d1779eb8b725de398d.png"></p>
<p>Docker는 코드를 실행하는 표준 방식을 제공하기 때문에 개발 환경에 구애받지 않고, 운영체제가 달라져도
어렵지않게 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 것이다.</p>
<p>그래서 Docker는 컨테이너를 위한 운영 체제라고 할 수 있다. 기존의 가상 머신(VMWare 등)과 유사하게 컴퓨팅 파워(서버 하드웨어)를
가상화하지만 실제로 모든 것을 가상화하는 것이 아니라 '이미지'라는 단위를 통해 최소한으로 가상화하는 방식이다.</p>
<p>이렇게 가상화된 단위를 '컨테이너'라고 부르는데, 이해를 돕자면 '이미지'를 통해 컨테이너를 추상화해놓고 필요할 때마다
이미지를 바탕으로 컨테이너를 구성하는 것을 말한다고 할 수 있다.</p>
<p>여기까지 설명하면 사실 감이 잘 오지 않을 것이다. 그래서 지금은 완전히 이해한다는 마음보다는 'Docker는 이렇게 동작하는구나' 정도로 이해하고
넘어가도록 하자.</p>
<h3>Docker를 사용해야 하는 이유</h3>
<p>Docker를 사용하면 코드를 더 빨리 전달하고, 애플리케이션 운영을 표준화하고, 코드를 원활하게 이동하고, 리소스 사용률을 높여 비용을 절감할 수 있다고 한다.</p>
<p>따라서 Docker를 사용하면 어디서나 안정적으로 실행할 수 있는 단일 객체를 확보할 수 있고, 간단한 Docker 구문으로 이를 완벽하게 제어할 수 있다. 이를 정리하면 다음과 같다.</p>
<ul>
<li>
<p>더 많은 소프트웨어를 더 빨리 제공: Docker를 사용하면 필요할 때마다 격리돤 서비스를 제공할 수 있어 상대적으로 더 많은 소프트웨어를 더 빨리 제공할 수 있다.  </p>
</li>
<li>
<p>운영 표준화: 컨테이너 기반 애플리케이션을 사용하면 손쉽게 배포하고, 문제를 파악할 수 있으며, 수정을 위해 롤백을 할 수도 있다.</p>
</li>
<li>
<p>원활한 이전: Docker 기반 애플리케이션을 로컬 개발 환경에서 프로덕션 환경으로 원활하게 배포할 수 있다.</p>
</li>
<li>
<p>비용 절감: 각 서버에서 좀 더 쉽게 더 많은 코드를 실행하여 사용률을 높이고 비용을 절감할 수 있다.</p>
</li>
</ul>
<h3>Docker를 사용하는 경우</h3>
<p>Docker 컨테이너를 최신 애플리케이션 및 플랫폼을 생성하는 핵심 빌딩 블록으로 사용할 수 있다.
따라서 Docker를 사용하면 분산 마이크로 서비스 아키텍처를 구축 및 실행하고, 표준화된 지속적 통합 및 지속적 전달 파이프라인을 통해 코드를 배포하고, 고도로 확장 가능한 데이터 처리 시스템을 구축하고, 개발자를 위한 완전관리형 플랫폼을 생성할 수 있다.</p>
<p>그래서 Docker는 대체로 마이크로 서비스, CI/CD, 대량의 데이터 처리, 컨테이너 서비스 등에 사용한다.</p>
<h3>마지막으로</h3>
<p>이제는 어느정도 도커를 사용하는 이유와 사용하면 좋은 점을 이해했다고 할 수 있다. 그러니 이제부터는 별도의 프로젝트를 통해 어떻게 하면 도커를 '잘' 사용할 수 있을지를 고민해보자.</p>]]></description><link>https://rayleighko.github.io/blog/2019-04-08-weplanet_study_docker</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-04-08-weplanet_study_docker</guid><pubDate>Mon, 08 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;WePlanet Intern - study - Docker&lt;/h1&gt;
&lt;h2&gt;이번 스터디 목표&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/docker/&quot;&gt;AWS - Docker란 무엇입니까?&lt;/a&gt;를 참고하여 Docker에 대한 학습을 하는 것이 이번 스터디의 목적이다.&lt;/p&gt;
&lt;p&gt;사실 이번에 시작한 프로젝트에서 Docker를 사용하기 때문에 이를 학습하여 보다 나은 이해를 하고자 함이다.&lt;/p&gt;
&lt;p&gt;우선 위에서 언급한 &lt;a href=&quot;https://aws.amazon.com/ko/docker/&quot;&gt;AWS - Docker란 무엇입니까?&lt;/a&gt;를 살펴보면
Docker의 정의, 작동 방식, 사용해야 하는 이유, 사용하는 경우 등을 설명한다. 그래서 우리도 마찬가지로 이것들을
살펴보고 어떻게 하면 도커를 잘 사용할 수 있을지를 생각해보자.&lt;/p&gt;
&lt;p&gt;언제나 말하지만 기술은 그냥 사용하는 게 아닌 &apos;잘&apos; 사용해야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;참고자료 - 초보를 위한 도커 안내서&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Docker란 무엇인가?&lt;/h3&gt;
&lt;p&gt;우선 Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.&lt;/p&gt;
&lt;p&gt;소프트웨어를 컨테이너라는 표준화된 유닛으로 패키징하며, 이 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등
소프트웨어를 실행하는 데 필요한 모든 것이 포함되어 있다.&lt;/p&gt;
&lt;p&gt;그래서 Docker를 사용하면 개발 환경에 구애받지 않고 애플리케이션을 신속하게 배포 및 확장할 수 있다.
즉, Docker를 사용하면 서비스마다 다른 개발 환경에 대한 스트레스가 줄어든다는 의미가 될 것이다.&lt;/p&gt;
&lt;h3&gt;Docker의 작동 방식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://d1.awsstatic.com/Developer%20Marketing/containers/monolith_2-VM-vs-Containers.78f841efba175556d82f64d1779eb8b725de398d.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Docker는 코드를 실행하는 표준 방식을 제공하기 때문에 개발 환경에 구애받지 않고, 운영체제가 달라져도
어렵지않게 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;그래서 Docker는 컨테이너를 위한 운영 체제라고 할 수 있다. 기존의 가상 머신(VMWare 등)과 유사하게 컴퓨팅 파워(서버 하드웨어)를
가상화하지만 실제로 모든 것을 가상화하는 것이 아니라 &apos;이미지&apos;라는 단위를 통해 최소한으로 가상화하는 방식이다.&lt;/p&gt;
&lt;p&gt;이렇게 가상화된 단위를 &apos;컨테이너&apos;라고 부르는데, 이해를 돕자면 &apos;이미지&apos;를 통해 컨테이너를 추상화해놓고 필요할 때마다
이미지를 바탕으로 컨테이너를 구성하는 것을 말한다고 할 수 있다.&lt;/p&gt;
&lt;p&gt;여기까지 설명하면 사실 감이 잘 오지 않을 것이다. 그래서 지금은 완전히 이해한다는 마음보다는 &apos;Docker는 이렇게 동작하는구나&apos; 정도로 이해하고
넘어가도록 하자.&lt;/p&gt;
&lt;h3&gt;Docker를 사용해야 하는 이유&lt;/h3&gt;
&lt;p&gt;Docker를 사용하면 코드를 더 빨리 전달하고, 애플리케이션 운영을 표준화하고, 코드를 원활하게 이동하고, 리소스 사용률을 높여 비용을 절감할 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;따라서 Docker를 사용하면 어디서나 안정적으로 실행할 수 있는 단일 객체를 확보할 수 있고, 간단한 Docker 구문으로 이를 완벽하게 제어할 수 있다. 이를 정리하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;더 많은 소프트웨어를 더 빨리 제공: Docker를 사용하면 필요할 때마다 격리돤 서비스를 제공할 수 있어 상대적으로 더 많은 소프트웨어를 더 빨리 제공할 수 있다.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영 표준화: 컨테이너 기반 애플리케이션을 사용하면 손쉽게 배포하고, 문제를 파악할 수 있으며, 수정을 위해 롤백을 할 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;원활한 이전: Docker 기반 애플리케이션을 로컬 개발 환경에서 프로덕션 환경으로 원활하게 배포할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비용 절감: 각 서버에서 좀 더 쉽게 더 많은 코드를 실행하여 사용률을 높이고 비용을 절감할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Docker를 사용하는 경우&lt;/h3&gt;
&lt;p&gt;Docker 컨테이너를 최신 애플리케이션 및 플랫폼을 생성하는 핵심 빌딩 블록으로 사용할 수 있다.
따라서 Docker를 사용하면 분산 마이크로 서비스 아키텍처를 구축 및 실행하고, 표준화된 지속적 통합 및 지속적 전달 파이프라인을 통해 코드를 배포하고, 고도로 확장 가능한 데이터 처리 시스템을 구축하고, 개발자를 위한 완전관리형 플랫폼을 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 Docker는 대체로 마이크로 서비스, CI/CD, 대량의 데이터 처리, 컨테이너 서비스 등에 사용한다.&lt;/p&gt;
&lt;h3&gt;마지막으로&lt;/h3&gt;
&lt;p&gt;이제는 어느정도 도커를 사용하는 이유와 사용하면 좋은 점을 이해했다고 할 수 있다. 그러니 이제부터는 별도의 프로젝트를 통해 어떻게 하면 도커를 &apos;잘&apos; 사용할 수 있을지를 고민해보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - 개발 문서 작성기]]></title><description><![CDATA[<h2>개발 문서 작성기</h2>
<h3>현재 상황</h3>
<p>이번에는 개발팀 내의 문서화 작업에 대한 고민을 하게 되었다. 그 이유는 CEO인 Daniel이 개발 팀 내에 따로 문서를 정의하고 있지 않아, 이번 기회에 문서화 작업을 해보자는 의견이 있었기 때문이다.</p>
<p>현재는 각자의 스타일대로 코드를 작성하고, API나 DB 구조를 구현하고 있다. 물론, 이는 각자의 개성이나 취향이기 때문에 욕할 수 있는 부분은 아니다. 하지만, 만약 그 프로젝트를 본인이 아닌 타인 그러니까 co-worker가 본다면 단번에 이해할 수 없는 부분이 있을 것이기 때문에 이를 위해 문서화 작업이 필요한 것이다.</p>
<p>따라서 인턴 기간동안 진행하는 문서화 작업의 기록을 이 문서를 통해 공유해보고자 한다.</p>
<h3>무엇을? 어떻게?</h3>
<p>앞서 '현재 상황'에서는 '왜?'에 대한 질문의 답을 했다. 따라서 이제 개발 문서를 '왜' 만드는지를 이해했다. 하지만 개발 문서를 작성하는 것을 해본 적이 없는 나는 당연히 개발 문서에 무엇이 들어가야 하고, 어떻게 그것들을 정의할 것인지에 대한 의문이 들었다.</p>
<p>그래서 이번 섹션에서는 개발 문서에 들어갈 '무엇'과 '어떻게' 작성되어야 하는지에 대해 알아보도록 하자.</p>
<p>본격적인 작성에 앞서 내가 참고한 문서는 다음과 같다.</p>
<p><a href="http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software_Documentation_Templates/">http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software<em>Documentation</em>Templates/</a></p>
<p><a href="https://github.com/nhnent/fe.javascript">https://github.com/nhnent/fe.javascript</a></p>
<p><a href="https://coderlife.tistory.com/237">https://coderlife.tistory.com/237</a></p>
<p>제일 처음에 있는 문서는 포멀한 가이드인 것 같아서 대충 읽어봤다. 그러고 나서 3번째 문서를 살펴보니 개발 문서는 개발팀의 성향에 따라 다르며, 달라져야 한다는 것을 알게되었다. 마냥 좋은 것을 따라한다고 소고기 안먹는 사람들끼리 소고기를 어떻게 먹어야 잘 먹는지를 이야기하는 것만큼 의미없는 것일테니 말이다.</p>
<p>그러다가 2번째 문서를 보면서 조금이나마 힌트를 얻었다. 우선 나는 문서의 형태를 프론트엔드 전반, 백엔드 전반, 각 프로젝트 별 추가적인 사항으로 나누고, 프로젝트 별 추가적인 사항은 다시 프론트엔드와 백엔드로 나눠 기재하려고 했다.</p>
<p>그러다보니 자연스럽게 어떻게 하면 개발자가 보기 편할지를 고민하게 되었고, 그 핵심은 필요로하는 필수 내용만 적는 것이라고 판단해 작성하게 되었다.</p>
<p>그래서 우선 FE(Frontend) JS 개발 가이드와 BE(Backend) JS 개발 가이드를 만들어 여기에서는 각각의 JS의 커딩컨벤션, 디버깅, 테스트 등에 해당하는 내용을 기재하게 되었다.</p>
<p>그러고 나서 각각의 프로젝트에 해당하는 내용을 기재했고, 이것은 해당 프로젝트 개발자의 취향 및 역량에 따라 달리해야 한다는 생각이 들어서 우선은 해당 내용에 대한 템플릿을 작성하는 일을 멈췄다.</p>
<p>JS 개발 가이드에 참고한 문서는 다음과 같다.</p>
<p><a href="http://crockford.com/javascript/">http://crockford.com/javascript/</a></p>
<p><a href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a></p>
<p>위 두 문서는 더글라스 크락포드의 JS 가이드와 Google의 JS Styleguide인데, 둘 다 많은 회사들이 JS에 대한 기술 문서를 작성할 때 많이 참고할 것 같아서 흝어보게 되었다. 이 두 문서는 앞으로도 계속 참고해야 할 것만 같으니 다음에 기회가 되면 정독해보도록 할 것이다.</p>
<h3>결론</h3>
<p>결과적으로 FE JS 가이드, BE JS 가이드, 프로젝트 별 가이드로 나누었고, 이를 마크다운으로 정리했다. 더불어 개발 문서이기 때문에 이것을 처음 읽는 사람의 입장에서 '이걸 왜 읽어야 하지?'라는 의문을 해결하기 위해 문서화를 하는 목적, 수정 방법 등을 명시해두었다.</p>
<p>여기까지의 소감은 하루동안 작성했기 때문에 너무 대충 적었다는 자기 반성과 앞으로 프로젝트를 진행하며 갈고 닦아야 한다는 의지를 볼 수 있었다는 것이다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-20-weplanet_documents_01</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-20-weplanet_documents_01</guid><pubDate>Wed, 20 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;개발 문서 작성기&lt;/h2&gt;
&lt;h3&gt;현재 상황&lt;/h3&gt;
&lt;p&gt;이번에는 개발팀 내의 문서화 작업에 대한 고민을 하게 되었다. 그 이유는 CEO인 Daniel이 개발 팀 내에 따로 문서를 정의하고 있지 않아, 이번 기회에 문서화 작업을 해보자는 의견이 있었기 때문이다.&lt;/p&gt;
&lt;p&gt;현재는 각자의 스타일대로 코드를 작성하고, API나 DB 구조를 구현하고 있다. 물론, 이는 각자의 개성이나 취향이기 때문에 욕할 수 있는 부분은 아니다. 하지만, 만약 그 프로젝트를 본인이 아닌 타인 그러니까 co-worker가 본다면 단번에 이해할 수 없는 부분이 있을 것이기 때문에 이를 위해 문서화 작업이 필요한 것이다.&lt;/p&gt;
&lt;p&gt;따라서 인턴 기간동안 진행하는 문서화 작업의 기록을 이 문서를 통해 공유해보고자 한다.&lt;/p&gt;
&lt;h3&gt;무엇을? 어떻게?&lt;/h3&gt;
&lt;p&gt;앞서 &apos;현재 상황&apos;에서는 &apos;왜?&apos;에 대한 질문의 답을 했다. 따라서 이제 개발 문서를 &apos;왜&apos; 만드는지를 이해했다. 하지만 개발 문서를 작성하는 것을 해본 적이 없는 나는 당연히 개발 문서에 무엇이 들어가야 하고, 어떻게 그것들을 정의할 것인지에 대한 의문이 들었다.&lt;/p&gt;
&lt;p&gt;그래서 이번 섹션에서는 개발 문서에 들어갈 &apos;무엇&apos;과 &apos;어떻게&apos; 작성되어야 하는지에 대해 알아보도록 하자.&lt;/p&gt;
&lt;p&gt;본격적인 작성에 앞서 내가 참고한 문서는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software_Documentation_Templates/&quot;&gt;http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software&lt;em&gt;Documentation&lt;/em&gt;Templates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nhnent/fe.javascript&quot;&gt;https://github.com/nhnent/fe.javascript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://coderlife.tistory.com/237&quot;&gt;https://coderlife.tistory.com/237&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제일 처음에 있는 문서는 포멀한 가이드인 것 같아서 대충 읽어봤다. 그러고 나서 3번째 문서를 살펴보니 개발 문서는 개발팀의 성향에 따라 다르며, 달라져야 한다는 것을 알게되었다. 마냥 좋은 것을 따라한다고 소고기 안먹는 사람들끼리 소고기를 어떻게 먹어야 잘 먹는지를 이야기하는 것만큼 의미없는 것일테니 말이다.&lt;/p&gt;
&lt;p&gt;그러다가 2번째 문서를 보면서 조금이나마 힌트를 얻었다. 우선 나는 문서의 형태를 프론트엔드 전반, 백엔드 전반, 각 프로젝트 별 추가적인 사항으로 나누고, 프로젝트 별 추가적인 사항은 다시 프론트엔드와 백엔드로 나눠 기재하려고 했다.&lt;/p&gt;
&lt;p&gt;그러다보니 자연스럽게 어떻게 하면 개발자가 보기 편할지를 고민하게 되었고, 그 핵심은 필요로하는 필수 내용만 적는 것이라고 판단해 작성하게 되었다.&lt;/p&gt;
&lt;p&gt;그래서 우선 FE(Frontend) JS 개발 가이드와 BE(Backend) JS 개발 가이드를 만들어 여기에서는 각각의 JS의 커딩컨벤션, 디버깅, 테스트 등에 해당하는 내용을 기재하게 되었다.&lt;/p&gt;
&lt;p&gt;그러고 나서 각각의 프로젝트에 해당하는 내용을 기재했고, 이것은 해당 프로젝트 개발자의 취향 및 역량에 따라 달리해야 한다는 생각이 들어서 우선은 해당 내용에 대한 템플릿을 작성하는 일을 멈췄다.&lt;/p&gt;
&lt;p&gt;JS 개발 가이드에 참고한 문서는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://crockford.com/javascript/&quot;&gt;http://crockford.com/javascript/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/jsguide.html&quot;&gt;https://google.github.io/styleguide/jsguide.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위 두 문서는 더글라스 크락포드의 JS 가이드와 Google의 JS Styleguide인데, 둘 다 많은 회사들이 JS에 대한 기술 문서를 작성할 때 많이 참고할 것 같아서 흝어보게 되었다. 이 두 문서는 앞으로도 계속 참고해야 할 것만 같으니 다음에 기회가 되면 정독해보도록 할 것이다.&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;결과적으로 FE JS 가이드, BE JS 가이드, 프로젝트 별 가이드로 나누었고, 이를 마크다운으로 정리했다. 더불어 개발 문서이기 때문에 이것을 처음 읽는 사람의 입장에서 &apos;이걸 왜 읽어야 하지?&apos;라는 의문을 해결하기 위해 문서화를 하는 목적, 수정 방법 등을 명시해두었다.&lt;/p&gt;
&lt;p&gt;여기까지의 소감은 하루동안 작성했기 때문에 너무 대충 적었다는 자기 반성과 앞으로 프로젝트를 진행하며 갈고 닦아야 한다는 의지를 볼 수 있었다는 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_06]]></title><description><![CDATA[<h2>투표 기능 구현</h2>
<h3>현재 상황</h3>]]></description><link>https://rayleighko.github.io/blog/2019-03-20-weplanet_project_06</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-20-weplanet_project_06</guid><pubDate>Wed, 20 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;투표 기능 구현&lt;/h2&gt;
&lt;h3&gt;현재 상황&lt;/h3&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project Backend_01]]></title><description><![CDATA[<h2>Node Backend API 서버 - Web Storage</h2>
<h3>현재 상황</h3>
<p>이번에 진행하는 프로젝트의 백엔드 부분을 살펴보고 있다. 현재 API 서버를 구현해 Localstorage 방식으로 토큰(AccessToken, refreshToken)을 교환하기 때문에 이에 대해 학습할 필요가 있다고 느꼈다.</p>
<p><a href="https://developer.mozilla.org/ko/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">참고자료 - 1 Mozilla, Web<em>Storage</em>API </a></p>
<p><a href="https://www.zerocho.com/category/HTML&#x26;DOM/post/5918515b1ed39f00182d3048">참고자료 - 2 로컬스토리지, 세션스토리지</a></p>
<h3>Sessionstorage와 Localstorage의 차이</h3>
<p>참고자료 1에 따르면 Web Storage는 위의 두 방식이 있고, 이 둘의 차이는 다음과 같다고 한다.</p>
<ul>
<li>sessionStorage는 페이지의 세션이 유지되는동안 사용할 수 있는 각 origin별로 별도의 스토리지를 관리합니다. (페이지 리로딩 및 복원을 포함한, 브라우저가 열려있는 한 최대한 긴 시간동안)</li>
<li>localStorage도 같은 일을 하지만, 브라우저가 닫히거나 다시 열리더라도 유지합니다.</li>
</ul>
<p>이런 정보를 바탕으로 참고자료 2와 함께 둘의 차이점을 '영구성'이라고 정의할 수 있겠다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-20-weplanet_project_08</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-20-weplanet_project_08</guid><pubDate>Wed, 20 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Node Backend API 서버 - Web Storage&lt;/h2&gt;
&lt;h3&gt;현재 상황&lt;/h3&gt;
&lt;p&gt;이번에 진행하는 프로젝트의 백엔드 부분을 살펴보고 있다. 현재 API 서버를 구현해 Localstorage 방식으로 토큰(AccessToken, refreshToken)을 교환하기 때문에 이에 대해 학습할 필요가 있다고 느꼈다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;참고자료 - 1 Mozilla, Web&lt;em&gt;Storage&lt;/em&gt;API &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zerocho.com/category/HTML&amp;#x26;DOM/post/5918515b1ed39f00182d3048&quot;&gt;참고자료 - 2 로컬스토리지, 세션스토리지&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Sessionstorage와 Localstorage의 차이&lt;/h3&gt;
&lt;p&gt;참고자료 1에 따르면 Web Storage는 위의 두 방식이 있고, 이 둘의 차이는 다음과 같다고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sessionStorage는 페이지의 세션이 유지되는동안 사용할 수 있는 각 origin별로 별도의 스토리지를 관리합니다. (페이지 리로딩 및 복원을 포함한, 브라우저가 열려있는 한 최대한 긴 시간동안)&lt;/li&gt;
&lt;li&gt;localStorage도 같은 일을 하지만, 브라우저가 닫히거나 다시 열리더라도 유지합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 정보를 바탕으로 참고자료 2와 함께 둘의 차이점을 &apos;영구성&apos;이라고 정의할 수 있겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project React-Admin_01]]></title><description><![CDATA[<h2>React-Admin을 활용한 프로젝트 리뷰</h2>
<h3>현재 상황</h3>
<p>이번 프로젝트에서는 React-Admin으로 Admin page를 구현한다고 한다. 하지만, 이전에 React-Admin을 사용해본 적이 없기 때문에 이번 기회에 튜토리얼을 따라 만들며 React-Admin을 학습해보자.  </p>
<h3><a href="https://marmelab.com/react-admin/Tutorial.html">React-Admin Tutorial</a></h3>
<p>물론 저번 NextJS 튜토리얼처럼 우선 개별적으로 튜토리얼을 진행하고, 후기와 함께 유의해야 할 내용을 정리할 것이다.  </p>
<blockquote>
<p>후기: Admin에 해당하는 부분을 React 프로젝트에서 구현할 수 있도록 해주는 도구라고 생각했다.
더불어 만약 Django를 쓰면 그냥 Django Admin으로 편하게 작업을 할 수도 있지 않을까 했다.</p>
<p>그럼에도 만약 프로젝트 전체를 JS로 관리하고 싶다거나 다른 백엔드 환경을 구성해야 할 필요가 있다면,
사용하면 좋을 것도 같다고 생각했다.</p>
</blockquote>
<p>이번에는 전체적으로 유의해야 할 내용에 대해 적을 필요성을 느끼지 못했다. 가장 큰 이유는 특정 기술이나 React의 어떤 특성을 사용한다기보다는 React-Admin이라는 도구를 사용한다고 느꼈기 때문이다.</p>
<p>그렇기 때문에 만약 추후에 문제가 생기거나 이해가 되지 않는 부분이 생긴다면 그저 문서를 보면 답이 나올 것 같았다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-20-weplanet_project_07</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-20-weplanet_project_07</guid><pubDate>Wed, 20 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;React-Admin을 활용한 프로젝트 리뷰&lt;/h2&gt;
&lt;h3&gt;현재 상황&lt;/h3&gt;
&lt;p&gt;이번 프로젝트에서는 React-Admin으로 Admin page를 구현한다고 한다. 하지만, 이전에 React-Admin을 사용해본 적이 없기 때문에 이번 기회에 튜토리얼을 따라 만들며 React-Admin을 학습해보자.  &lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://marmelab.com/react-admin/Tutorial.html&quot;&gt;React-Admin Tutorial&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;물론 저번 NextJS 튜토리얼처럼 우선 개별적으로 튜토리얼을 진행하고, 후기와 함께 유의해야 할 내용을 정리할 것이다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;후기: Admin에 해당하는 부분을 React 프로젝트에서 구현할 수 있도록 해주는 도구라고 생각했다.
더불어 만약 Django를 쓰면 그냥 Django Admin으로 편하게 작업을 할 수도 있지 않을까 했다.&lt;/p&gt;
&lt;p&gt;그럼에도 만약 프로젝트 전체를 JS로 관리하고 싶다거나 다른 백엔드 환경을 구성해야 할 필요가 있다면,
사용하면 좋을 것도 같다고 생각했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번에는 전체적으로 유의해야 할 내용에 대해 적을 필요성을 느끼지 못했다. 가장 큰 이유는 특정 기술이나 React의 어떤 특성을 사용한다기보다는 React-Admin이라는 도구를 사용한다고 느꼈기 때문이다.&lt;/p&gt;
&lt;p&gt;그렇기 때문에 만약 추후에 문제가 생기거나 이해가 되지 않는 부분이 생긴다면 그저 문서를 보면 답이 나올 것 같았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_05]]></title><description><![CDATA[<h2>ViewMore(더보기) 동작 구현</h2>
<h3>현재 상황</h3>
<ol>
<li>API 서버에는 대략 80개 이상의 Comments(댓글 및 답글)에 대한 정보가 담겨있다.  </li>
<li>이때 API 서버는 20개의 Array 정보를 ApiRoute이라는 추상화된 액션 함수를 통해 하나의 액션 함수(getComments)를 만들고, 이를 프론트 엔드에 Axios로 전달한다. 이때 전달되는 데이터의 형태는 다음과 같이 제공된다(댓글과 답글은 형식 구분없이 스타일만 다르게 제공).  </li>
</ol>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"list"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"id"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> not <span class="token null">null</span><span class="token punctuation">,</span> // 모든 comments는 id를 갖는다.
      <span class="token property">"content"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 내용
      <span class="token property">"parent_id"</span><span class="token operator">:</span> number or <span class="token null">null</span><span class="token punctuation">,</span> // 댓글은 <span class="token null">null</span><span class="token punctuation">,</span> 답글은 number
      <span class="token property">"created_at"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 만들어진 시기
      <span class="token property">"author_name"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 작성자
      <span class="token property">"author_image"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 작성자 프로필 사진
      <span class="token property">"total_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 답글의 갯수<span class="token punctuation">,</span> 답글의 경우는 해당 데이터가 존재하지 않음.
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      ...
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"total_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 해당 게시글의 댓글 및 답글의 수
    <span class="token property">"parent_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 해당 게시글의 댓글 수
    <span class="token property">"limit"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 한 번에 전달되는 데이터의 수(default<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id<span class="token punctuation">)</span><span class="token punctuation">,</span> last_created_at(첫 번째로 전달받을 comments의 생성 일자<span class="token punctuation">)</span>임.</code></pre></div>
<ol start="3">
<li>프론트 엔드는 액션 함수를 통해 받은 데이터를 Array.prototype.map으로 뿌려준다.  </li>
<li>이런 상황에서 유저는 viewMore(더보기) 버튼을 눌렀다.  </li>
<li>현재 우리는 viewMore 버튼이 클릭되면 현재를 뷰를 기준으로 다음 20개의 Comments 정보를 유저의 뷰에 전달하고 싶다.  </li>
</ol>
<h3>가정 및 의문</h3>
<ol>
<li>props를 통해 받은 20개의 Array를 props.comment.list라고 칭하고, 이 props.comment.list에 concat을 통해 다음 20개의 Array를 이어 나가는 게 맞나?</li>
<li>props를 통해 받은 20개의 Array를 하나의 로컬 Array</li>
<li>props를 통해 받은 20개의 Array를 하나의 로컬 Array로 만들고, 다음 20개의 Array를 다른 로컬 Array로 만들고 둘을 cancat해 렌더하는 게 맞을까?</li>
</ol>
<h3>해결 과정</h3>
<ol>
<li>우선 가정 및 의문을 해결하기 위해 <a href="https://stackoverflow.com/questions/41616376/concat-vs-push-adding-new-array-in-react-best-practice">참고자료</a>를 읽음. 결론: 리액트 컴포넌트의 상태(state)는 직접 변경(setState가 아닌 직접적인 대입(=, push, 등)하면 안된다(불변성 문제). (<a href="https://reactjs.org/docs/react-component.html#state">docs</a> 참고)</li>
<li>고민하던 와중에 API 서버에서 던져주는 데이터의 구조가 바뀌었다(DOM이 리랜더링하더라도 사용자가 현재 보고 있는 페이지의 구조가 변하면 안되기 때문에 기존의 방식(20개씩 받아 concat하려고 했던 방식)이 아닌 create_at대신 page를 받아 page * limit을 사용자가 보는 comments의 View로 뿌려주도록 하고자 한다). </li>
</ol>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"list"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"id"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> not <span class="token null">null</span><span class="token punctuation">,</span> // 모든 comments는 id를 갖는다.
      <span class="token property">"content"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 내용
      <span class="token property">"parent_id"</span><span class="token operator">:</span> number or <span class="token null">null</span><span class="token punctuation">,</span> // 댓글은 <span class="token null">null</span><span class="token punctuation">,</span> 답글은 number
      <span class="token property">"created_at"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 만들어진 시기
      <span class="token property">"author_name"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 작성자
      <span class="token property">"author_image"</span><span class="token operator">:</span> string<span class="token punctuation">,</span> // 작성자 프로필 사진
      <span class="token property">"total_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 답글의 갯수<span class="token punctuation">,</span> 답글의 경우는 해당 데이터가 존재하지 않음.
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      ...
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"total_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 해당 게시글의 댓글 및 답글의 수
    <span class="token property">"parent_count"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 해당 게시글의 댓글 수
    <span class="token property">"limit"</span><span class="token operator">:</span> number<span class="token punctuation">,</span> // 한 번에 전달되는 데이터의 수(default<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id<span class="token punctuation">)</span><span class="token punctuation">,</span> page(<span class="token number">1</span>부터 시작<span class="token punctuation">,</span> <span class="token number">1</span>개의 페이지는 total_count까지 limit의 배수만큼 증가<span class="token punctuation">,</span> Ex. page가 <span class="token number">3</span>이고<span class="token punctuation">,</span> limit이 <span class="token number">20</span>이면 총 <span class="token number">60</span>개의 comments를 보여줌<span class="token punctuation">)</span>임.</code></pre></div>
<ol start="3">
<li>concat이 아닌, props로 넘겨 받는 데이터를 state로 변환(직접적이지 않게)해 list를 만들고 이걸 map해서 page가 증가함에 따라 mapping하자!</li>
<li>중간에 props의 list로 map해서 state는 바뀌는데, 이에 따라 View가 변하지 않아서 한참을 삽질했지만, 결국 해결!</li>
</ol>]]></description><link>https://rayleighko.github.io/blog/2019-03-12-weplanet_project_05</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-12-weplanet_project_05</guid><pubDate>Tue, 12 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;ViewMore(더보기) 동작 구현&lt;/h2&gt;
&lt;h3&gt;현재 상황&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;API 서버에는 대략 80개 이상의 Comments(댓글 및 답글)에 대한 정보가 담겨있다.  &lt;/li&gt;
&lt;li&gt;이때 API 서버는 20개의 Array 정보를 ApiRoute이라는 추상화된 액션 함수를 통해 하나의 액션 함수(getComments)를 만들고, 이를 프론트 엔드에 Axios로 전달한다. 이때 전달되는 데이터의 형태는 다음과 같이 제공된다(댓글과 답글은 형식 구분없이 스타일만 다르게 제공).  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;list&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; not &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 모든 comments는 id를 갖는다.
      &lt;span class=&quot;token property&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 내용
      &lt;span class=&quot;token property&quot;&gt;&quot;parent_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number or &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 댓글은 &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 답글은 number
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 만들어진 시기
      &lt;span class=&quot;token property&quot;&gt;&quot;author_name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 작성자
      &lt;span class=&quot;token property&quot;&gt;&quot;author_image&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 작성자 프로필 사진
      &lt;span class=&quot;token property&quot;&gt;&quot;total_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 답글의 갯수&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 답글의 경우는 해당 데이터가 존재하지 않음.
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      ...
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;total_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 해당 게시글의 댓글 및 답글의 수
    &lt;span class=&quot;token property&quot;&gt;&quot;parent_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 해당 게시글의 댓글 수
    &lt;span class=&quot;token property&quot;&gt;&quot;limit&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 한 번에 전달되는 데이터의 수(default&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; last_created_at(첫 번째로 전달받을 comments의 생성 일자&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;임.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;프론트 엔드는 액션 함수를 통해 받은 데이터를 Array.prototype.map으로 뿌려준다.  &lt;/li&gt;
&lt;li&gt;이런 상황에서 유저는 viewMore(더보기) 버튼을 눌렀다.  &lt;/li&gt;
&lt;li&gt;현재 우리는 viewMore 버튼이 클릭되면 현재를 뷰를 기준으로 다음 20개의 Comments 정보를 유저의 뷰에 전달하고 싶다.  &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;가정 및 의문&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;props를 통해 받은 20개의 Array를 props.comment.list라고 칭하고, 이 props.comment.list에 concat을 통해 다음 20개의 Array를 이어 나가는 게 맞나?&lt;/li&gt;
&lt;li&gt;props를 통해 받은 20개의 Array를 하나의 로컬 Array&lt;/li&gt;
&lt;li&gt;props를 통해 받은 20개의 Array를 하나의 로컬 Array로 만들고, 다음 20개의 Array를 다른 로컬 Array로 만들고 둘을 cancat해 렌더하는 게 맞을까?&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;해결 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;우선 가정 및 의문을 해결하기 위해 &lt;a href=&quot;https://stackoverflow.com/questions/41616376/concat-vs-push-adding-new-array-in-react-best-practice&quot;&gt;참고자료&lt;/a&gt;를 읽음. 결론: 리액트 컴포넌트의 상태(state)는 직접 변경(setState가 아닌 직접적인 대입(=, push, 등)하면 안된다(불변성 문제). (&lt;a href=&quot;https://reactjs.org/docs/react-component.html#state&quot;&gt;docs&lt;/a&gt; 참고)&lt;/li&gt;
&lt;li&gt;고민하던 와중에 API 서버에서 던져주는 데이터의 구조가 바뀌었다(DOM이 리랜더링하더라도 사용자가 현재 보고 있는 페이지의 구조가 변하면 안되기 때문에 기존의 방식(20개씩 받아 concat하려고 했던 방식)이 아닌 create_at대신 page를 받아 page * limit을 사용자가 보는 comments의 View로 뿌려주도록 하고자 한다). &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;list&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; not &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 모든 comments는 id를 갖는다.
      &lt;span class=&quot;token property&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 내용
      &lt;span class=&quot;token property&quot;&gt;&quot;parent_id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number or &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 댓글은 &lt;span class=&quot;token null&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 답글은 number
      &lt;span class=&quot;token property&quot;&gt;&quot;created_at&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 만들어진 시기
      &lt;span class=&quot;token property&quot;&gt;&quot;author_name&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 작성자
      &lt;span class=&quot;token property&quot;&gt;&quot;author_image&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 작성자 프로필 사진
      &lt;span class=&quot;token property&quot;&gt;&quot;total_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 답글의 갯수&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 답글의 경우는 해당 데이터가 존재하지 않음.
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      ...
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;total_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 해당 게시글의 댓글 및 답글의 수
    &lt;span class=&quot;token property&quot;&gt;&quot;parent_count&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 해당 게시글의 댓글 수
    &lt;span class=&quot;token property&quot;&gt;&quot;limit&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; // 한 번에 전달되는 데이터의 수(default&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
// 서버에서 전달하는 Parameters는 Id(해당 게시글의 Id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; page(&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;부터 시작&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;개의 페이지는 total_count까지 limit의 배수만큼 증가&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Ex. page가 &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;이고&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; limit이 &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;이면 총 &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt;개의 comments를 보여줌&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;임.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;concat이 아닌, props로 넘겨 받는 데이터를 state로 변환(직접적이지 않게)해 list를 만들고 이걸 map해서 page가 증가함에 따라 mapping하자!&lt;/li&gt;
&lt;li&gt;중간에 props의 list로 map해서 state는 바뀌는데, 이에 따라 View가 변하지 않아서 한참을 삽질했지만, 결국 해결!&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[2019.03의 RESUME]]></title><description><![CDATA[<h1>2019. 03의 RESUME</h1>
<h4>좌우명: <a href="https://en.wikipedia.org/wiki/Lifelong_learning">평생학습(Lifelong learning)</a>, <a href="https://bit.ly/2E22Als">민이호학 불치하문(敏而好學 不恥下問)</a></h4>
<p>개발이라는 분야만이 아닌 서비스 구현의 전반적인 워크 플로우를 공부하는 프로그래머가 되고자 합니다. 이를 위해 더나은 경험을 추구하며, 기술적으로 성장하는 것을 좋아합니다. 더불어 모든 일은 체계적으로 하거나, 다양한 의견을 수용해 최적의 결과를 만들 때 가장 큰 성취감을 느끼곤 합니다.</p>
<blockquote>
<p>최근 사용한 언어 및 라이브러리: Node, Javascript(React, Redux, etc.), CSS3(SCSS, StyledComponents), HTML5(JSX)</p>
</blockquote>
<p>제가 추구하는 성향의 개발자는 Development만이 아닌 Operation까지도 생각하는 개발자이기 때문에 그에 따른 다양한 툴과 언어를 편식없이 학습하고 있습니다.</p>
<p>최근에는 가장 활발한 발전을 이루고 있는 웹 프론트엔드에 매력을 느껴 이를 이용하여 React를 활용한 <a href="https://github.com/teamthesol/boggler">프로젝트1</a>과 Node를 활용한 <a href="https://github.com/teamthesol/node-DeepSpeech">프로젝트 2</a>를 진행했습니다.</p>
<blockquote>
<p>선호하는 개발 환경: MacOS(Zsh, Bash), Linux(Ubuntu), Opensource<br>
선호하는 도구: AWS, React, Node<br>
최근 관심있는 도구: CI(TravisCI, CircleCI 등), Container(Docker, Kubernetes)</p>
</blockquote>
<p>이렇게 다양한 도구를 사용하고, 이것저것 공부하는 이유는 제가 생각하는 개발자라는 직업은 배움을 게을리하지 않고, 무언가를 만들기 위해 다양한 경험을 해야 한다고 생각하기 때문입니다. 그래서 때로는 잡다하게 공부했다는 생각이 들 때가 있었습니다.</p>
<p>하지만 그 생각도 잠시 배움을 즐기고 있는 저 자신의 모습이 행복하기 때문에 지금까지, 그리고 앞으로도 후회없이 다양한 기술을 학습하고자 합니다.</p>
<h3>참여 중인 대외활동</h3>
<p><strong>2018. 04. 01 ~ 현재</strong>: Djangogirls Seoul - Organizer<br>
<strong>2018. 08. 12 ~ 현재</strong>: AWS(KRUG) University Student Group - Member</p>
<h3>공모전 및 수상 경력</h3>
<p><strong>2017. 09. 28 ~ 12. 21</strong>: (비공식) 컨트리뷰톤, uftrace/perf – 오픈소스 Contributor, 우수상(2등)<br>
<strong>2018. 08. 16 ~ 10. 25</strong>: (공식) 컨트리뷰톤, gitShare – 오픈소스 Contributor, 우수상(2등)<br>
<strong>2019. 01. 08 ~ 02. 27</strong>: (공식) 네이버 D2 CAMPUS FEST, boggler – 오픈소스 Maintainer로써 결승 진출</p>
<h3>근무 이력</h3>
<p><strong>2017. 03. 04 ~ 08. 11</strong>: 홍구 - 기술 담당, 공동 창업 및 웹 개발 담당(DJANGO)</p>
<p><strong>2018. 08. 20 ~ 11. 20</strong>: 나인브이알 - 컨텐츠 소프트웨어 엔지니어, PC 기반 게임 개발 및 웹 개발 담당(PHP, JQUERY), 스타팅 멤버</p>
<p><strong>2019. 03. 04 ~ 06. 21</strong>: 위플래닛 - 웹 프론트엔드 인턴, 웹 프론트엔드 개발 담당(React - NextJS, Redux-Form)</p>
<h2>최근에 진행한 프로젝트 3개(맡은 역할, 인원 수, 기간, 내용 등)</h2>
<h3>2018. 04. 01 ~ 2018. 11. 21: 강의 공유 플랫폼, 오픈 소스(4명) - Front-end(일부), Back-end(일부)</h3>
<blockquote>
<p>사용한 도구: React(Mobx), Node(Express, SocketIO), AWS(EC2, Route53, RDS), Git(GitKraken, Gitlab)</p>
</blockquote>
<p>이번 프로젝트의 시작은 수강했던 강의의 한 학생의 불편함이었습니다. 그 학생은 장애를 가지고 있어 수업을 듣기 위해서는 누군가의 도움이 필요했고, 그 도움조차 그 학생의 학습을 완벽히 도울 수는 없었습니다.</p>
<p>그래서 그 학생에게 도움이 되고자 그를 위한 프로젝트를 만들었습니다. - 3주 정도 서비스 후 서비스 유지비를 고려해 무기한 폐지하게 되었습니다.</p>
<p>작업물의 완성도는 낮았지만, 프로젝트를 진행하며 DevOps를 위해서는 안정적인 Development가 선행되어야 한다는 것을 깨닫게 되었습니다. 그래야 Operation을 위한 제대로 된 서비스를 제공할 수 있다는 것을 깨닫게 되었습니다.</p>
<p>뿐만 아니라 작업물의 완성을 목표로 진행했기 때문에 소스코드의 질이 떨어졌습니다. 이에 리펙토링의 필요성을 느꼈고, 프로젝트를 하나하나 수정하는 것보다 새로운 프로젝트를 만드는 것이 나을 것 같다고 생각해 새로운 프로젝트(Boggle)를 만들게 되었습니다.</p>
<p>결과적으로는 운영에 실패해 접게 되었지만, 생애 처음으로 구현부터 서비스 운영까지 진행하는 프로젝트를 경험했다는 중요한 경험이었습니다.</p>
<p><strong>프로젝트 소스코드 주소</strong>: <a href="https://github.com/rayleighChild/athena">https://github.com/rayleighChild/athena</a><br>
<strong>진행 간 부족한 점 피드백</strong>: <a href="https://github.com/rayleighChild/athena_FAQ">https://github.com/rayleighChild/athena_FAQ</a></p>
<h3>2018. 12. 26 ~ 2019. 02. 20: 음성인식 기반 메모 플랫폼, 오픈 소스(3명) - Front-end(주도), Design(주도)</h3>
<blockquote>
<p>사용한 도구: React(Redux, ...), Node(Express, ...), Git(GitKraken, GitHub, Git-Bash, ...), Editor(VSCode), Mozilla/DeepSpeech 등 여러 오픈소스 프로젝트 참고</p>
</blockquote>
<p>보글러의 가장 큰 핵심은 스트리밍 혹은 파일로 입력받은 음성 정보를 분석해 이를 텍스트로 변환시킨다는 점입니다. 가령 미팅에서의 가벼운 대화 혹은 강연자의 음성을 텍스트로 변환해 보다 나은 필사(글을 옮겨 적는) 환경을 제공합니다.</p>
<p>때때로 우리는 강의를 듣거나 중요한 일을 녹음합니다. 하지만, 이렇게 녹음된 자료는 텍스트로 옮겨 적어야 하는 불편함이 있었습니다. 더불어 이런 작업은 꼭 필요한 일이 아니라면 쉽게 잊혀지곤 합니다. 더불어 유료로 서비스를 이용해야 하기도 하죠!</p>
<p>이런 문제를 보완하기 위해 보글러는 음성을 텍스트로 변환하기 위한 작업의 피로를 줄이기 위한 도구로 만들어졌습니다.</p>
<p>저는 팀 내에서 프론트 엔드와 디자인을 담당했고, 전체적인 프로젝트 진행 방향과 구성원의 일정관리와 프로젝트 이슈 관리, 문서화 등을 주도적으로 진행하며 프로젝트 관리를 병행했습니다.</p>
<p>위의 두 프로젝트(Athena, Boggler)를 진행하며 느낀 핵심 키워드는 “사용하는 기술에는 정당한 이유가 필요하며, 회사에서 사용하는 모든 기술에는 정당한 이유가 있다”라는 깨달음이었습니다.</p>
<p>이를 통해 프로젝트를 진행하기 전에는 마냥 트랜드를 따라 개발하는 것이 옳은 줄 알았지만, 사실은 기본에 충실해 기능과 구현에 적절한 기술을 사용하는 것이 옳다는 것을 깨닳았고 기본에 충실해야 좋은 서비스를 만들 수 있다는 것을 알게 되었습니다.</p>
<p><strong>프로젝트 주소</strong>: <a href="https://github.com/rayleighChild/boggler">https://github.com/rayleighChild/boggler</a></p>
<h3>2018. 01. 23 ~ 01. 28: Mozilla/DeepSpeech 기반 Node Packcage, 오픈 소스(2명) - 프로젝트 설계 및 주도</h3>
<blockquote>
<p>사용한 도구: Node, Mozilla/DeepSpeech</p>
</blockquote>
<p>앞서 설명한 보글러에서 편하게 사용하기 위해 오픈 소스 기반 Speech Recognition(음성 인식) 서비스인 Mozilla/DeepSpeech의 기능을 Node 모듈로 만든 프로젝트입니다. 또한, 기존의 Mozilla/DeepSpeech에서 제공하는 NPM 모듈이 있었지만 터미널 기반으로 사용해야 했기에 이를 코드로 사용하면 좋겠다고 생각해 진행하게 되었습니다.</p>
<p>해당 프로젝트를 진행하면서 처음으로 package에 대한 전 과정을 설계, 구현했기 때문에 Node Package 퍼블리싱 경험을 통해 사용자의 피드백을 받을 수 있었으며, 사용자로부터의 요구사항에 맞게 프로젝트의 기능을 수정했던 경험이 기억에 남습니다. 가령 사용자의 요구였던 동기적으로 함수가 호출되어 결과를 반환하는 방식을 체택한 사례(<a href="https://github.com/teamthesol/node-DeepSpeech/issues/2">https://github.com/teamthesol/node-DeepSpeech/issues/2</a>)는 개인 프로젝트로 진행하는 것과는 또다른 경험을 얻을 수 있는 계기가 되었습니다.</p>
<p><strong>현 기준(2019. 03. 11) 총 다운로드 수: 990회</strong></p>
<p><strong>프로젝트 주소</strong>:　<a href="https://github.com/teamthesol/node-DeepSpeech">https://github.com/teamthesol/node-DeepSpeech</a></p>
<h2>가장 기억에 남는 문제 해결 사례 소개</h2>
<h3>1. 기능 구현 - 비동기적으로 구현되어 있는 함수를 동기적으로 구현하기 위해 수정한 사례</h3>
<h4>문제 정의</h4>
<p>: 앞서 소개한 STT 기반 프로젝트인 Node-DeepSpeech라는 프로젝트는 처음에 구현될 때(0.2.4 버전)만 해도 비동기적으로 사용자에게 제공되었습니다.</p>
<p>그래서 사용자의 입장에서는 인식된 음성 데이터의 전달은 원하고자 할 때 성공적으로 서버에 전달할 수 있었지만, 분석되어 전달받은 문자 데이터의 반환 시기를 알 수 없었습니다(<a href="https://github.com/teamthesol/node-DeepSpeech/issues/2">https://github.com/teamthesol/node-DeepSpeech/issues/2</a>).</p>
<h4>문제 해결 과정</h4>
<p>: 우선적으로 Node라는 언어의 메커니즘 자체가 단일 스레드 기반으로 클러스터링을 통해 마치 멀티 스레드 환경에서처럼 한 번에 여러 작업을 동시에 수행하고 있었기 때문에 일반적인 함수를 사용한다 하더라도 비동기적으로 사용되고 있었습니다.</p>
<p>이를 해결하기 위해서는 별도의 함수 혹은 키워드가 필요했고, 이를 해결하기 위해 구글에서 동기적으로 함수를 구현하는 방법을 찾아 결국에는 Stackoverflow를 통해 callback function, Promise, async/await의 3가지 문법을 활용하는 방법이 있다는 것을 알게 되었습니다.</p>
<p>첫 번째 방법인 callback function의 경우에는 callback hell이라고 부르는 고전적인 문제를 안고 있었기 때문에 체택할 수 없어 나머지 두 방법 중 하나인 Promise로 함수를 구현하는 방식을 체택하게 되었습니다.</p>
<h4>결론</h4>
<p>: 이번 사례를 통해 로컬에서만 개발하고 개인의 요구에 맞춰 기능을 구현하던 과거를 반성하게 되었고, 사용자의 요구를 실현한다는 것에 대한 안목이 생겼습니다.</p>
<p><strong>해결된 문제 링크</strong>
: <a href="https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df">https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df</a></p>
<h3>2. FrontEnd - 오디오 파일 분석을 통한 기능 구현 및 스타일링 사례</h3>
<h4>문제 정의</h4>
<p>: 링크를 통해 미디어(유튜브, 트위치, 음성 파일 등)를 제공하는 형태였던 기존의 방식을 사용자의 파일을 통해 이를 분석하여 웨이브(frequency wave)를 그려야했고, DeepSpeech를 적용하여 텍스트를 분석하는 로직이 필요했습니다.(<a href="https://github.com/teamthesol/boggler/issues/18">https://github.com/teamthesol/boggler/issues/18</a>)</p>
<h4>문제 해결 과정</h4>
<p>: 우선적으로 문제를 정의하는 과정에서 하나의 문제가 아닌 여러 개의 문제를 한 번에 해결하려 하는 것 같다고 느껴 이를 여러 문제로 정의할 필요성을 느끼게 되었습니다.</p>
<ol>
<li>Audio Frequency wave 그리기(기본 뼈대 제작): <a href="https://github.com/teamthesol/boggler/issues/31">https://github.com/teamthesol/boggler/issues/31</a></li>
<li>Editor 그리기(기본 뼈대 및 참고할 예시 코드 삽입): <a href="https://github.com/teamthesol/boggler/issues/30">https://github.com/teamthesol/boggler/issues/30</a></li>
</ol>
<p>각 과정에서는 기능을 나눠 기능과 스타일링을 구현했고, 우선적으로 기능 구현을 먼저 해결하려 했습니다. 1번 기능인 Audio Frequency wave의 틀을 먼저 만들고, 기능을 구현한 이후에 스타일링을 구현했습니다.</p>
<p>1번에서는 오픈 소스 중 하나인 waveform-react를 사용했고, 여기에 사용되는 오디오 파일을 버퍼로 디코드하는 로직과 이를 반환할 시점이 디코딩이 끝난 이후여야 했기에 동기적으로 구현되어야 했습니다.</p>
<p>이를 위해 async/await 방식을 체택해 기능을 동기적으로 구현했고, 이에 따라 분석된 버퍼 데이터를 waveform-react에 삽입해 Audio Frequency wave를 그릴 수 있었습니다.</p>
<p>이어서 2번 기능인 Editor에서는 에디터의 기능을 하게 될 textarea와 여기에 들어온 텍스트를 바탕으로 사용자에게 텍스트를 보여줄 Article 기능이 필요했습니다.</p>
<p>더불어 텍스트는 state로 관리해 사용자의 변경에 따라 해당 state가 변하게 구현해야 했고, 변화되는 것과 동시에 사용자에게 보여주는 Article에서도 rerender가 일어나야 했기 때문에 이에 대해서도 고려해야 했습니다.</p>
<h4>결론</h4>
<p>: 이번 사례를 통해 하나의 메서드는 하나의 문제만 해결해야 한다는 것을 깨닫게 되었고, 여러 문제가 섞인 이슈를 해결하기 위해서는 문제를 기능 단위로 나누는 것이 효율적이라는 것을 깨닫게 되었습니다.</p>
<p>더불어 문제를 해결할 때 어느정도의 설계가 있어야 효율적으로 기능을 구현할 수 있다는 알게되었습니다.</p>
<p><strong>해결된 문제 링크 1</strong></p>
<ul>
<li>기능 구현: <a href="https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7">https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3">https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3</a></li>
</ul>
<p><strong>해결된 문제 링크 2</strong></p>
<ul>
<li>Article 컴포넌트 구현: <a href="https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f">https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f</a></li>
<li>Editor 기능 구현1: <a href="https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628">https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628</a></li>
<li>Editor 기능 구현2: <a href="https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1">https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1</a></li>
<li>Editor의 버튼 기능 구현<br>
: <a href="https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c">https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50">https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50</a></li>
<li>스타일링: <a href="https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148">https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148</a></li>
</ul>
<h4>기타 내용</h4>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">2018년 회고: https://bit.ly/2FmPAaL
Github: https://github.com/rayleighko
Mail: gmj1197@gmail.com
Djangogirls, seoul: https://djangogirls.org/seoul/  
AUSG: https://www.facebook.com/AUSG-311547172765852/
Facebook page: https://www.facebook.com/RaykoDev</code></pre></div>]]></description><link>https://rayleighko.github.io/blog/2019-03-11-resume</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-11-resume</guid><pubDate>Mon, 11 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;2019. 03의 RESUME&lt;/h1&gt;
&lt;h4&gt;좌우명: &lt;a href=&quot;https://en.wikipedia.org/wiki/Lifelong_learning&quot;&gt;평생학습(Lifelong learning)&lt;/a&gt;, &lt;a href=&quot;https://bit.ly/2E22Als&quot;&gt;민이호학 불치하문(敏而好學 不恥下問)&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;개발이라는 분야만이 아닌 서비스 구현의 전반적인 워크 플로우를 공부하는 프로그래머가 되고자 합니다. 이를 위해 더나은 경험을 추구하며, 기술적으로 성장하는 것을 좋아합니다. 더불어 모든 일은 체계적으로 하거나, 다양한 의견을 수용해 최적의 결과를 만들 때 가장 큰 성취감을 느끼곤 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최근 사용한 언어 및 라이브러리: Node, Javascript(React, Redux, etc.), CSS3(SCSS, StyledComponents), HTML5(JSX)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;제가 추구하는 성향의 개발자는 Development만이 아닌 Operation까지도 생각하는 개발자이기 때문에 그에 따른 다양한 툴과 언어를 편식없이 학습하고 있습니다.&lt;/p&gt;
&lt;p&gt;최근에는 가장 활발한 발전을 이루고 있는 웹 프론트엔드에 매력을 느껴 이를 이용하여 React를 활용한 &lt;a href=&quot;https://github.com/teamthesol/boggler&quot;&gt;프로젝트1&lt;/a&gt;과 Node를 활용한 &lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech&quot;&gt;프로젝트 2&lt;/a&gt;를 진행했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;선호하는 개발 환경: MacOS(Zsh, Bash), Linux(Ubuntu), Opensource&lt;br&gt;
선호하는 도구: AWS, React, Node&lt;br&gt;
최근 관심있는 도구: CI(TravisCI, CircleCI 등), Container(Docker, Kubernetes)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 다양한 도구를 사용하고, 이것저것 공부하는 이유는 제가 생각하는 개발자라는 직업은 배움을 게을리하지 않고, 무언가를 만들기 위해 다양한 경험을 해야 한다고 생각하기 때문입니다. 그래서 때로는 잡다하게 공부했다는 생각이 들 때가 있었습니다.&lt;/p&gt;
&lt;p&gt;하지만 그 생각도 잠시 배움을 즐기고 있는 저 자신의 모습이 행복하기 때문에 지금까지, 그리고 앞으로도 후회없이 다양한 기술을 학습하고자 합니다.&lt;/p&gt;
&lt;h3&gt;참여 중인 대외활동&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2018. 04. 01 ~ 현재&lt;/strong&gt;: Djangogirls Seoul - Organizer&lt;br&gt;
&lt;strong&gt;2018. 08. 12 ~ 현재&lt;/strong&gt;: AWS(KRUG) University Student Group - Member&lt;/p&gt;
&lt;h3&gt;공모전 및 수상 경력&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2017. 09. 28 ~ 12. 21&lt;/strong&gt;: (비공식) 컨트리뷰톤, uftrace/perf – 오픈소스 Contributor, 우수상(2등)&lt;br&gt;
&lt;strong&gt;2018. 08. 16 ~ 10. 25&lt;/strong&gt;: (공식) 컨트리뷰톤, gitShare – 오픈소스 Contributor, 우수상(2등)&lt;br&gt;
&lt;strong&gt;2019. 01. 08 ~ 02. 27&lt;/strong&gt;: (공식) 네이버 D2 CAMPUS FEST, boggler – 오픈소스 Maintainer로써 결승 진출&lt;/p&gt;
&lt;h3&gt;근무 이력&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2017. 03. 04 ~ 08. 11&lt;/strong&gt;: 홍구 - 기술 담당, 공동 창업 및 웹 개발 담당(DJANGO)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2018. 08. 20 ~ 11. 20&lt;/strong&gt;: 나인브이알 - 컨텐츠 소프트웨어 엔지니어, PC 기반 게임 개발 및 웹 개발 담당(PHP, JQUERY), 스타팅 멤버&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2019. 03. 04 ~ 06. 21&lt;/strong&gt;: 위플래닛 - 웹 프론트엔드 인턴, 웹 프론트엔드 개발 담당(React - NextJS, Redux-Form)&lt;/p&gt;
&lt;h2&gt;최근에 진행한 프로젝트 3개(맡은 역할, 인원 수, 기간, 내용 등)&lt;/h2&gt;
&lt;h3&gt;2018. 04. 01 ~ 2018. 11. 21: 강의 공유 플랫폼, 오픈 소스(4명) - Front-end(일부), Back-end(일부)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: React(Mobx), Node(Express, SocketIO), AWS(EC2, Route53, RDS), Git(GitKraken, Gitlab)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 프로젝트의 시작은 수강했던 강의의 한 학생의 불편함이었습니다. 그 학생은 장애를 가지고 있어 수업을 듣기 위해서는 누군가의 도움이 필요했고, 그 도움조차 그 학생의 학습을 완벽히 도울 수는 없었습니다.&lt;/p&gt;
&lt;p&gt;그래서 그 학생에게 도움이 되고자 그를 위한 프로젝트를 만들었습니다. - 3주 정도 서비스 후 서비스 유지비를 고려해 무기한 폐지하게 되었습니다.&lt;/p&gt;
&lt;p&gt;작업물의 완성도는 낮았지만, 프로젝트를 진행하며 DevOps를 위해서는 안정적인 Development가 선행되어야 한다는 것을 깨닫게 되었습니다. 그래야 Operation을 위한 제대로 된 서비스를 제공할 수 있다는 것을 깨닫게 되었습니다.&lt;/p&gt;
&lt;p&gt;뿐만 아니라 작업물의 완성을 목표로 진행했기 때문에 소스코드의 질이 떨어졌습니다. 이에 리펙토링의 필요성을 느꼈고, 프로젝트를 하나하나 수정하는 것보다 새로운 프로젝트를 만드는 것이 나을 것 같다고 생각해 새로운 프로젝트(Boggle)를 만들게 되었습니다.&lt;/p&gt;
&lt;p&gt;결과적으로는 운영에 실패해 접게 되었지만, 생애 처음으로 구현부터 서비스 운영까지 진행하는 프로젝트를 경험했다는 중요한 경험이었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 소스코드 주소&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/athena&quot;&gt;https://github.com/rayleighChild/athena&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;진행 간 부족한 점 피드백&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/athena_FAQ&quot;&gt;https://github.com/rayleighChild/athena_FAQ&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2018. 12. 26 ~ 2019. 02. 20: 음성인식 기반 메모 플랫폼, 오픈 소스(3명) - Front-end(주도), Design(주도)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: React(Redux, ...), Node(Express, ...), Git(GitKraken, GitHub, Git-Bash, ...), Editor(VSCode), Mozilla/DeepSpeech 등 여러 오픈소스 프로젝트 참고&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;보글러의 가장 큰 핵심은 스트리밍 혹은 파일로 입력받은 음성 정보를 분석해 이를 텍스트로 변환시킨다는 점입니다. 가령 미팅에서의 가벼운 대화 혹은 강연자의 음성을 텍스트로 변환해 보다 나은 필사(글을 옮겨 적는) 환경을 제공합니다.&lt;/p&gt;
&lt;p&gt;때때로 우리는 강의를 듣거나 중요한 일을 녹음합니다. 하지만, 이렇게 녹음된 자료는 텍스트로 옮겨 적어야 하는 불편함이 있었습니다. 더불어 이런 작업은 꼭 필요한 일이 아니라면 쉽게 잊혀지곤 합니다. 더불어 유료로 서비스를 이용해야 하기도 하죠!&lt;/p&gt;
&lt;p&gt;이런 문제를 보완하기 위해 보글러는 음성을 텍스트로 변환하기 위한 작업의 피로를 줄이기 위한 도구로 만들어졌습니다.&lt;/p&gt;
&lt;p&gt;저는 팀 내에서 프론트 엔드와 디자인을 담당했고, 전체적인 프로젝트 진행 방향과 구성원의 일정관리와 프로젝트 이슈 관리, 문서화 등을 주도적으로 진행하며 프로젝트 관리를 병행했습니다.&lt;/p&gt;
&lt;p&gt;위의 두 프로젝트(Athena, Boggler)를 진행하며 느낀 핵심 키워드는 “사용하는 기술에는 정당한 이유가 필요하며, 회사에서 사용하는 모든 기술에는 정당한 이유가 있다”라는 깨달음이었습니다.&lt;/p&gt;
&lt;p&gt;이를 통해 프로젝트를 진행하기 전에는 마냥 트랜드를 따라 개발하는 것이 옳은 줄 알았지만, 사실은 기본에 충실해 기능과 구현에 적절한 기술을 사용하는 것이 옳다는 것을 깨닳았고 기본에 충실해야 좋은 서비스를 만들 수 있다는 것을 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 주소&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rayleighChild/boggler&quot;&gt;https://github.com/rayleighChild/boggler&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2018. 01. 23 ~ 01. 28: Mozilla/DeepSpeech 기반 Node Packcage, 오픈 소스(2명) - 프로젝트 설계 및 주도&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;사용한 도구: Node, Mozilla/DeepSpeech&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞서 설명한 보글러에서 편하게 사용하기 위해 오픈 소스 기반 Speech Recognition(음성 인식) 서비스인 Mozilla/DeepSpeech의 기능을 Node 모듈로 만든 프로젝트입니다. 또한, 기존의 Mozilla/DeepSpeech에서 제공하는 NPM 모듈이 있었지만 터미널 기반으로 사용해야 했기에 이를 코드로 사용하면 좋겠다고 생각해 진행하게 되었습니다.&lt;/p&gt;
&lt;p&gt;해당 프로젝트를 진행하면서 처음으로 package에 대한 전 과정을 설계, 구현했기 때문에 Node Package 퍼블리싱 경험을 통해 사용자의 피드백을 받을 수 있었으며, 사용자로부터의 요구사항에 맞게 프로젝트의 기능을 수정했던 경험이 기억에 남습니다. 가령 사용자의 요구였던 동기적으로 함수가 호출되어 결과를 반환하는 방식을 체택한 사례(&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/issues/2&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/issues/2&lt;/a&gt;)는 개인 프로젝트로 진행하는 것과는 또다른 경험을 얻을 수 있는 계기가 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;현 기준(2019. 03. 11) 총 다운로드 수: 990회&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트 주소&lt;/strong&gt;:　&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech&quot;&gt;https://github.com/teamthesol/node-DeepSpeech&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;가장 기억에 남는 문제 해결 사례 소개&lt;/h2&gt;
&lt;h3&gt;1. 기능 구현 - 비동기적으로 구현되어 있는 함수를 동기적으로 구현하기 위해 수정한 사례&lt;/h3&gt;
&lt;h4&gt;문제 정의&lt;/h4&gt;
&lt;p&gt;: 앞서 소개한 STT 기반 프로젝트인 Node-DeepSpeech라는 프로젝트는 처음에 구현될 때(0.2.4 버전)만 해도 비동기적으로 사용자에게 제공되었습니다.&lt;/p&gt;
&lt;p&gt;그래서 사용자의 입장에서는 인식된 음성 데이터의 전달은 원하고자 할 때 성공적으로 서버에 전달할 수 있었지만, 분석되어 전달받은 문자 데이터의 반환 시기를 알 수 없었습니다(&lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/issues/2&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/issues/2&lt;/a&gt;).&lt;/p&gt;
&lt;h4&gt;문제 해결 과정&lt;/h4&gt;
&lt;p&gt;: 우선적으로 Node라는 언어의 메커니즘 자체가 단일 스레드 기반으로 클러스터링을 통해 마치 멀티 스레드 환경에서처럼 한 번에 여러 작업을 동시에 수행하고 있었기 때문에 일반적인 함수를 사용한다 하더라도 비동기적으로 사용되고 있었습니다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 별도의 함수 혹은 키워드가 필요했고, 이를 해결하기 위해 구글에서 동기적으로 함수를 구현하는 방법을 찾아 결국에는 Stackoverflow를 통해 callback function, Promise, async/await의 3가지 문법을 활용하는 방법이 있다는 것을 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;첫 번째 방법인 callback function의 경우에는 callback hell이라고 부르는 고전적인 문제를 안고 있었기 때문에 체택할 수 없어 나머지 두 방법 중 하나인 Promise로 함수를 구현하는 방식을 체택하게 되었습니다.&lt;/p&gt;
&lt;h4&gt;결론&lt;/h4&gt;
&lt;p&gt;: 이번 사례를 통해 로컬에서만 개발하고 개인의 요구에 맞춰 기능을 구현하던 과거를 반성하게 되었고, 사용자의 요구를 실현한다는 것에 대한 안목이 생겼습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크&lt;/strong&gt;
: &lt;a href=&quot;https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df&quot;&gt;https://github.com/teamthesol/node-DeepSpeech/commit/f6d56fc853abcb3cf85737ba04615ee8264867df&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. FrontEnd - 오디오 파일 분석을 통한 기능 구현 및 스타일링 사례&lt;/h3&gt;
&lt;h4&gt;문제 정의&lt;/h4&gt;
&lt;p&gt;: 링크를 통해 미디어(유튜브, 트위치, 음성 파일 등)를 제공하는 형태였던 기존의 방식을 사용자의 파일을 통해 이를 분석하여 웨이브(frequency wave)를 그려야했고, DeepSpeech를 적용하여 텍스트를 분석하는 로직이 필요했습니다.(&lt;a href=&quot;https://github.com/teamthesol/boggler/issues/18&quot;&gt;https://github.com/teamthesol/boggler/issues/18&lt;/a&gt;)&lt;/p&gt;
&lt;h4&gt;문제 해결 과정&lt;/h4&gt;
&lt;p&gt;: 우선적으로 문제를 정의하는 과정에서 하나의 문제가 아닌 여러 개의 문제를 한 번에 해결하려 하는 것 같다고 느껴 이를 여러 문제로 정의할 필요성을 느끼게 되었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Audio Frequency wave 그리기(기본 뼈대 제작): &lt;a href=&quot;https://github.com/teamthesol/boggler/issues/31&quot;&gt;https://github.com/teamthesol/boggler/issues/31&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 그리기(기본 뼈대 및 참고할 예시 코드 삽입): &lt;a href=&quot;https://github.com/teamthesol/boggler/issues/30&quot;&gt;https://github.com/teamthesol/boggler/issues/30&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각 과정에서는 기능을 나눠 기능과 스타일링을 구현했고, 우선적으로 기능 구현을 먼저 해결하려 했습니다. 1번 기능인 Audio Frequency wave의 틀을 먼저 만들고, 기능을 구현한 이후에 스타일링을 구현했습니다.&lt;/p&gt;
&lt;p&gt;1번에서는 오픈 소스 중 하나인 waveform-react를 사용했고, 여기에 사용되는 오디오 파일을 버퍼로 디코드하는 로직과 이를 반환할 시점이 디코딩이 끝난 이후여야 했기에 동기적으로 구현되어야 했습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 async/await 방식을 체택해 기능을 동기적으로 구현했고, 이에 따라 분석된 버퍼 데이터를 waveform-react에 삽입해 Audio Frequency wave를 그릴 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이어서 2번 기능인 Editor에서는 에디터의 기능을 하게 될 textarea와 여기에 들어온 텍스트를 바탕으로 사용자에게 텍스트를 보여줄 Article 기능이 필요했습니다.&lt;/p&gt;
&lt;p&gt;더불어 텍스트는 state로 관리해 사용자의 변경에 따라 해당 state가 변하게 구현해야 했고, 변화되는 것과 동시에 사용자에게 보여주는 Article에서도 rerender가 일어나야 했기 때문에 이에 대해서도 고려해야 했습니다.&lt;/p&gt;
&lt;h4&gt;결론&lt;/h4&gt;
&lt;p&gt;: 이번 사례를 통해 하나의 메서드는 하나의 문제만 해결해야 한다는 것을 깨닫게 되었고, 여러 문제가 섞인 이슈를 해결하기 위해서는 문제를 기능 단위로 나누는 것이 효율적이라는 것을 깨닫게 되었습니다.&lt;/p&gt;
&lt;p&gt;더불어 문제를 해결할 때 어느정도의 설계가 있어야 효율적으로 기능을 구현할 수 있다는 알게되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기능 구현: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7&quot;&gt;https://github.com/teamthesol/boggler/commit/491cff00c1d6f74398925bc52239b14a46fe06d7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3&quot;&gt;https://github.com/teamthesol/boggler/commit/675c795b4bf51083fb3db255e2528d93821bb5c3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해결된 문제 링크 2&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Article 컴포넌트 구현: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f&quot;&gt;https://github.com/teamthesol/boggler/commit/9484f33c017e540159d914499421a4bc5c1aa86f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 기능 구현1: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628&quot;&gt;https://github.com/teamthesol/boggler/commit/ae44c65dc76dc182b26093882007b0b8b6765628&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor 기능 구현2: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1&quot;&gt;https://github.com/teamthesol/boggler/commit/d670aad2975081b771cc0bfd857fa8df1800b6f1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Editor의 버튼 기능 구현&lt;br&gt;
: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c&quot;&gt;https://github.com/teamthesol/boggler/commit/705b3c61d6b99439b4f989a4286275ac4099710c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50&quot;&gt;https://github.com/teamthesol/boggler/commit/09aaa346b5202fbdb519c2e239e327c564b2ee50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스타일링: &lt;a href=&quot;https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148&quot;&gt;https://github.com/teamthesol/boggler/commit/38712adcb82b7ab4a623c521760c0d822668f148&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;기타 내용&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;2018년 회고: https://bit.ly/2FmPAaL
Github: https://github.com/rayleighko
Mail: gmj1197@gmail.com
Djangogirls, seoul: https://djangogirls.org/seoul/  
AUSG: https://www.facebook.com/AUSG-311547172765852/
Facebook page: https://www.facebook.com/RaykoDev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_04]]></title><description><![CDATA[<h1>대댓글 만들기</h1>
<p>이번에는 NextJS를 활용한 프로젝트에서 대댓글 만들기를 진행했다. 대댓글이라 하면 해당 게시글의 댓글에 달리는 답글을 말한다. 이런 대댓글을 만들기 전에는 NextJS 프로젝트가 생소할 뿐더러 Form을 Redux-Form을 이용하고 있기 때문에, 써본 적도 없는 Redux-Form을 이용한 데이터 관리를 잘 해낼 수 있을지 의문이었다.</p>
<p>그래서인지 처음에는 구현 방향을 잃고 어떻게 하면 좋을지를 계속 고민했다. 하물며 이런 고민은 이번만이 아닐 것 같아 이렇게 글을 통해 공유하고자 한다.</p>
<p>우선 나에게 주어진 상황은 다음과 같았다.</p>
<ol>
<li>NextJS 기반 프로젝트</li>
<li>Redux-Form을 활용한 Form처리</li>
<li>Redux-Form의 Field를 이용한 컴포넌트 단위 이벤트 처리(?)</li>
<li>이미 구현되어 있는 댓글 기능</li>
<li>퍼블리셔가 구현해놓은 정적 웹사이트</li>
</ol>
<p>사실 준비물은 모두 갖춰진 상황이었다. 더불어 끝나고 보니 이미 설계가 되어있었기 때문에 나는 그 속에서 기능만 구현하면 되는 상황이었다. 하지만 처음 프로젝트를 받았을 당시에는 이런 상황에 대한 이해도 없었기 때문에 어떻게 구현해야 할까 고민이었다. 그래서 이러한 고민을 순서대로 이 문서에 공유해보도록 하겠다.</p>
<h2>자, 이제 시작이야 뭐부터 하지?</h2>
<p>단순히 "대댓글을 만들어라!"라는 요구사항만 나에게 주어졌기 때문에 이걸 어떻게 구현할지는 내 주관에 따라 진행할 수 있었다. 우선적으로 Redux의 action을 이용해 API 서버에 request를 보내고, 그 결과로 response를 받는다. 그렇기 때문에  action 함수를 import해서 비동기적으로 사용해야 할 것이다.</p>
<blockquote>
<p>만약 비동기가 아닌 동기로 request를 보내거나 respense를 받는다면, 반환 시점을 명확하게 알 수 없어 데이터에 대한 신뢰도가 떨어진다. 아니, 떨어지는 수준이 아니라 신뢰할 수 없다고 할 수 있다.</p>
</blockquote>
<p>또한, 대댓글의 state는 해당 페이지에서만 가지고 있어도 된다. 따라서 redux를 통해 global하게 관리하지 않아도 될 것이다. 더불어 퍼블리셔가 있기 때문에 HTML과 CSS에 대한 고민은 하지 않아도 되는 상황이고, 이미 구현되어 있는 댓글과 다른 페이지들을 참고할 수 있었기 때문에 상대적으로 상황이 좋다고 판단했다.</p>
<p>다음과 같은 진행 상황을 통해 문제를 해결했다.</p>
<ol>
<li>Swagger UI를 통해 API 서버에서 넘어오는 값 확인</li>
<li>넘겨받은 값을 활용해 브라우저의 View를 구현하기로 결심</li>
<li>댓글이 어떤 형태로 View에 뿌려지는 지를 보고 어떻게 추가할지 결정(댓글은 props의 map으로 뿌려주고 있었음)</li>
</ol>
<p>머리 속으로 어느정도 윤곽이 잡히자 천천히 문제를 해결해 나갔다. 하지만, 예상했던 것과 달리 원하는 결과를 출력할 수 없었는데, 그 이유는 Redux-Form을 이용해 액션 함수로 Request를 전달해야 하는데 그 과정이 익숙하지 않았기 때문이었다. 물론 이 문제말고도 팀 내에서도 결정되지 않은 댓글과 답글의 순서 및 형태(스타일 코드는 있었지만, 그걸 사용해 어떻게 뿌려줄지에 대한 의논이 필요했음), API 서버로 전달할 Request의 형식(어떻게 뿌려줄지를 결정하고, 이것을 효율적으로 구현하기 위해(브라우저에서는 연산을 최소한으로) Request와 Response의 형태를 결정해야 했음) 등이 구현에 문제가 되었지만 결론적으로 단시간의 토론을 통해 해결할 수 있었음.</p>
<p>마찬가지로 다음과 같은 어려움을 겪기도 했다.</p>
<ol>
<li>props를 통해 response를 받아오는 상황에서 props를 state에 넣어 state를 변경해가며 브라우저의 View를 계속적으로 렌더링해야 했음.</li>
<li>더불어 Props를 이용하지 않고, 대입된 state를 활용하고 이를 setState를 활용해 브라우저의 View를 렌더링해줘야 했음(직접 props를 변경할 수 없기 때문)</li>
<li>Redux-Form의 textarea의 input 값과 이를 전달하기 위해 props로 제공하는 onSubmit 인터페이스에 대한 스터디가 필요했음</li>
<li>'더보기' 기능이 필요한데, 이 더보기는 API 서버에서 전달받은 limit만큼 댓글과 답글을 기존의 댓글과 답글 배열에 붙여주는 작업이 필요했음</li>
<li>또한, state를 limit만큼 mapping하기 때문에 답글을 추가할 때 리스트의 처음(더보기 바로 위에 있는 댓글 혹은 답글) 값이 댓글일 경우 그 댓글의 답글을 입력해 등록하면 짤리는 현상이 있었음. 예를 들어 현재는 80개의 댓글과 답글을 보여주는데, 마지막 댓글에 답글을 달면 81개의 댓글과 답글이 존재하지만, 여전히 80개의 정보를 보여주고 있기 때문에 이를 해결해야 했음. -> 리스트의 처음이 댓글이고, 이 댓글의 답글을 작성할 경우 더보기 기능을 실행(80개씩 보여주다가 81개째가 되면 100개를 보여줌, 물론 100개를 보여준다고 했지만, 100개는 최댓값이고 그냥 81개가 보여짐)</li>
</ol>]]></description><link>https://rayleighko.github.io/blog/2019-03-08-weplanet_project_04</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-08-weplanet_project_04</guid><pubDate>Fri, 08 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;대댓글 만들기&lt;/h1&gt;
&lt;p&gt;이번에는 NextJS를 활용한 프로젝트에서 대댓글 만들기를 진행했다. 대댓글이라 하면 해당 게시글의 댓글에 달리는 답글을 말한다. 이런 대댓글을 만들기 전에는 NextJS 프로젝트가 생소할 뿐더러 Form을 Redux-Form을 이용하고 있기 때문에, 써본 적도 없는 Redux-Form을 이용한 데이터 관리를 잘 해낼 수 있을지 의문이었다.&lt;/p&gt;
&lt;p&gt;그래서인지 처음에는 구현 방향을 잃고 어떻게 하면 좋을지를 계속 고민했다. 하물며 이런 고민은 이번만이 아닐 것 같아 이렇게 글을 통해 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;우선 나에게 주어진 상황은 다음과 같았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NextJS 기반 프로젝트&lt;/li&gt;
&lt;li&gt;Redux-Form을 활용한 Form처리&lt;/li&gt;
&lt;li&gt;Redux-Form의 Field를 이용한 컴포넌트 단위 이벤트 처리(?)&lt;/li&gt;
&lt;li&gt;이미 구현되어 있는 댓글 기능&lt;/li&gt;
&lt;li&gt;퍼블리셔가 구현해놓은 정적 웹사이트&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사실 준비물은 모두 갖춰진 상황이었다. 더불어 끝나고 보니 이미 설계가 되어있었기 때문에 나는 그 속에서 기능만 구현하면 되는 상황이었다. 하지만 처음 프로젝트를 받았을 당시에는 이런 상황에 대한 이해도 없었기 때문에 어떻게 구현해야 할까 고민이었다. 그래서 이러한 고민을 순서대로 이 문서에 공유해보도록 하겠다.&lt;/p&gt;
&lt;h2&gt;자, 이제 시작이야 뭐부터 하지?&lt;/h2&gt;
&lt;p&gt;단순히 &quot;대댓글을 만들어라!&quot;라는 요구사항만 나에게 주어졌기 때문에 이걸 어떻게 구현할지는 내 주관에 따라 진행할 수 있었다. 우선적으로 Redux의 action을 이용해 API 서버에 request를 보내고, 그 결과로 response를 받는다. 그렇기 때문에  action 함수를 import해서 비동기적으로 사용해야 할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 비동기가 아닌 동기로 request를 보내거나 respense를 받는다면, 반환 시점을 명확하게 알 수 없어 데이터에 대한 신뢰도가 떨어진다. 아니, 떨어지는 수준이 아니라 신뢰할 수 없다고 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;또한, 대댓글의 state는 해당 페이지에서만 가지고 있어도 된다. 따라서 redux를 통해 global하게 관리하지 않아도 될 것이다. 더불어 퍼블리셔가 있기 때문에 HTML과 CSS에 대한 고민은 하지 않아도 되는 상황이고, 이미 구현되어 있는 댓글과 다른 페이지들을 참고할 수 있었기 때문에 상대적으로 상황이 좋다고 판단했다.&lt;/p&gt;
&lt;p&gt;다음과 같은 진행 상황을 통해 문제를 해결했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Swagger UI를 통해 API 서버에서 넘어오는 값 확인&lt;/li&gt;
&lt;li&gt;넘겨받은 값을 활용해 브라우저의 View를 구현하기로 결심&lt;/li&gt;
&lt;li&gt;댓글이 어떤 형태로 View에 뿌려지는 지를 보고 어떻게 추가할지 결정(댓글은 props의 map으로 뿌려주고 있었음)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;머리 속으로 어느정도 윤곽이 잡히자 천천히 문제를 해결해 나갔다. 하지만, 예상했던 것과 달리 원하는 결과를 출력할 수 없었는데, 그 이유는 Redux-Form을 이용해 액션 함수로 Request를 전달해야 하는데 그 과정이 익숙하지 않았기 때문이었다. 물론 이 문제말고도 팀 내에서도 결정되지 않은 댓글과 답글의 순서 및 형태(스타일 코드는 있었지만, 그걸 사용해 어떻게 뿌려줄지에 대한 의논이 필요했음), API 서버로 전달할 Request의 형식(어떻게 뿌려줄지를 결정하고, 이것을 효율적으로 구현하기 위해(브라우저에서는 연산을 최소한으로) Request와 Response의 형태를 결정해야 했음) 등이 구현에 문제가 되었지만 결론적으로 단시간의 토론을 통해 해결할 수 있었음.&lt;/p&gt;
&lt;p&gt;마찬가지로 다음과 같은 어려움을 겪기도 했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;props를 통해 response를 받아오는 상황에서 props를 state에 넣어 state를 변경해가며 브라우저의 View를 계속적으로 렌더링해야 했음.&lt;/li&gt;
&lt;li&gt;더불어 Props를 이용하지 않고, 대입된 state를 활용하고 이를 setState를 활용해 브라우저의 View를 렌더링해줘야 했음(직접 props를 변경할 수 없기 때문)&lt;/li&gt;
&lt;li&gt;Redux-Form의 textarea의 input 값과 이를 전달하기 위해 props로 제공하는 onSubmit 인터페이스에 대한 스터디가 필요했음&lt;/li&gt;
&lt;li&gt;&apos;더보기&apos; 기능이 필요한데, 이 더보기는 API 서버에서 전달받은 limit만큼 댓글과 답글을 기존의 댓글과 답글 배열에 붙여주는 작업이 필요했음&lt;/li&gt;
&lt;li&gt;또한, state를 limit만큼 mapping하기 때문에 답글을 추가할 때 리스트의 처음(더보기 바로 위에 있는 댓글 혹은 답글) 값이 댓글일 경우 그 댓글의 답글을 입력해 등록하면 짤리는 현상이 있었음. 예를 들어 현재는 80개의 댓글과 답글을 보여주는데, 마지막 댓글에 답글을 달면 81개의 댓글과 답글이 존재하지만, 여전히 80개의 정보를 보여주고 있기 때문에 이를 해결해야 했음. -&gt; 리스트의 처음이 댓글이고, 이 댓글의 답글을 작성할 경우 더보기 기능을 실행(80개씩 보여주다가 81개째가 되면 100개를 보여줌, 물론 100개를 보여준다고 했지만, 100개는 최댓값이고 그냥 81개가 보여짐)&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_03]]></title><description><![CDATA[<h1>NextJS 실습하기 - 기본 예제 따라하기</h1>
<p>먼저 NextJS에서 제공하는 기본 튜토리얼을 따라 NextJS를 이해하도록 하자. 기본 튜토리얼은 NextJS의 문서에서 Learn을 통해 진행할 수 있으며, GitHub 로그인을 통한 연동이 가능하기 때문에 어렵지않게 진행할 수 있을 것이다.</p>
<p><a href="https://nextjs.org/learn/basics/getting-started/">NextJS 기본 튜토리얼</a>에서 로그인 후 실습을 진행하도록 하자. 실습 진행은 각자의 몫이기 때문에 여기에 별도의 글을 작성하지는 않고, 그저 후기를 작성하도록 할 것이다.</p>
<blockquote>
<p>후기: NextJS의 튜토리얼은 단순히 NextJS를 이해하는 것을 넘어 SSR 그 자체를 이해할 수 있는 튜토리얼이었다. 물론 앞으로도 NextJS의 문서를 많이 살펴봐야겠지만, 이번에 진행한 튜토리얼을 통해 얻은 지식 혹은 의문의 해결을 바탕으로 React에서의 SSR에 대해 보다 깊이 이해할 수 있었다.</p>
<p>또한, SSR을 이해함과 동시에 React의 심화 기술(HOC, Hooks 등)에 대한 관심이 생겼고, 이를 공부하는 과정에서 얻은 인사이트는 웹 프론트 엔드 엔지니어로 한걸음 더 성장할 수 있는 동력이 되었다고 말할 수 있을 것이다.</p>
<p>아무튼 문서에 나오는 것처럼 꽤 괜찮은 튜토리얼이었다.</p>
</blockquote>
<p><a href="https://nextjs.org/learn">참고자료 1 - NextJS Learn</a></p>
<p><a href="https://reactjs.org/docs/higher-order-components.html">참고자료 2 - React HOC</a></p>
<p><a href="https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component">참고자료 3 - 리액트(React) 이해 4 - Higher Order Component(HOC)로 컴포넌트 재사용 하기</a> </p>
<p>이번에 실습을 진행하며 다음과 같은 키워드에 주목했고, 이 키워드를 공부하며 한걸음 더 성장할 수 있었다. 그 키워드는 다음과 같다.</p>
<h2>Navigate Between Pages - HOC(Higher-order component)</h2>
<p>Link에 대한 이야기를 하기 전에 고차원 컴포넌트라고 부를 수 있는 HOC에 대해 알아보도록 하자. HOC는 컴포넌트 로직을 재사용하기 위한 React의 응용(고급) 기술이다. 이 기술은 하나의 React API가 아닌 하나의 패턴으로 사용된다. 조금 더 설명하면, HOC는 컴포넌트를 가져와 다음과 같이 다시 반환하는 기술(패턴)이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>이는 일반적으로 함수를 반환하는 <a href="https://en.wikipedia.org/wiki/Higher-order_function">HOF</a>와 유사하지만, 함수 대신 컴포넌트를 반환한다고 할 수 있다. 이렇게 함으로써 HOC는 리앧ㄱ트 컴포넌트를 인자로 받아서 모종의 처리를 한 후 새로운 리액트 컴포넌트를 리턴하는 컴포넌트라고 할 수 있다.</p>
<p>HOC는 다음과 같이 활용할 수 있다(<a href="https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component">참고자료2의 내용</a>)</p>
<ul>
<li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0"><strong>Container 컴포넌트와 Presentational 컴포넌트</strong></a> <strong>분리</strong>: 비지니스 로직을 담당하는 컴포넌트(Container 컴포넌트)와 디스플레이를 담당하는 컴포넌트(Presentational 컴포넌트)를 분리하여 사용 할 때, 컨테이너 컴포넌트를 HOC로 만들어서 사용 할 수 있다.  </li>
<li><strong>로딩 중 화면 표시</strong>: 보통 SPA(Single Page App)에서 화면이 로딩 중일 때, Skeleton 화면을 보여주고, 로딩이 완료되면 데이터를 보여줄 때 사용 할 수 있다.</li>
<li><strong>유저 인증 로직 처리</strong>: 컴포넌트 내에서 권한 체크나 로그인 상태를 체크하기 보다는 인증 로직을 HOC로 분리하면 컴포넌트 재사용성도 높일 수 있고, 컴포넌트에서 역할 분리도 쉽게 할 수 있다.</li>
<li><strong>에러 메세지 표시</strong>: 컴포넌트 내에서 분기문(if/else 등)을 통해 처리 할 수도 있지만, 분기문을 HOC로 만들어 처리 하면 컴포넌트를 더욱 깔끔하게 사용 할 수 있다.</li>
</ul>
<h2>Navigate Between Pages - Link</h2>
<blockquote>
<p>Link is Just a Higher Order Component (HOC)</p>
<p>Actually, the style prop on <code class="language-text">next/link</code> has no effect. That's because <code class="language-text">next/link</code>is just a <a href="https://facebook.github.io/react/docs/higher-order-components.html">higher order component</a> which only accepts the "href" and some similar props. If you need to style it, you need to do it to the underlying component.</p>
</blockquote>
<p>NextJS의 Link는 HOC이다. 위와 같은 문서의 내용에서도 알 수 있듯이 Link는 단순히 HOC이기 때문에 이미 지정된 props에 대해서만 반응한다. 그래서 <code class="language-text">&lt;a&gt; 태그</code>와 같은 일종의 테그로 인식해 사전에 지정된 props가 아닌 style 등의 props를 전달한다면 Link에서 그 결과를 기대하기는 힘들다.</p>
<h2>Create Dynamic Pages - Passing Data via Query Strings</h2>
<p>Link에서는 문자열 매개변수(string parameter)를 통해 데이터를 전달한다. NextJS에서는 다음과 같이 질의 문자열(query strings)을 통해 어떤 데이터던지 전달할 수 있다. </p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">PostLink</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>li<span class="token operator">></span>
    <span class="token operator">&lt;</span>Link href<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`/post?title=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">.</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>a<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>
<span class="token punctuation">)</span></code></pre></div>
<p>반대로 데이터를 받는 입장은 다음과 같이 <code class="language-text">withRouter</code> 메서드를 사용해서 값을 전달받는다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>withRouter<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'next/router'</span>
<span class="token keyword">import</span> Layout <span class="token keyword">from</span> <span class="token string">'../components/MyLayout.js'</span>

<span class="token keyword">const</span> Page <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Layout<span class="token operator">></span>
       <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>router<span class="token punctuation">.</span>query<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
       <span class="token operator">&lt;</span>p<span class="token operator">></span>This is the blog post content<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Layout<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Page</code></pre></div>
<p>위 코드는 서로 문서에서 다음과 같은 동작을 주고받고 있다고 한다.</p>
<blockquote>
<ul>
<li>We import and use the "withRouter" function from "next/router" this will inject the Next.js router as a property</li>
<li>In this case, we are using the router's “query” object, which has the query string params.</li>
<li>Therefore, we get the title with <code class="language-text">props.router.query.title</code>.</li>
</ul>
</blockquote>
<p>이처럼 NextJS에서는 <code class="language-text">Link</code>와 <code class="language-text">withRouter</code> 통해 클라이언트 측 라우팅을 진행하고, 질의(query) 객체를 이용해 매개변수를 주고받는다. </p>
<h2>Clean URLs with Route Masking - Route Masking</h2>
<p>Route Masking은 사용자의 입장에서 URL을 보다 깔끔하게(Clean) 받을 수 있는 기법이다. 두 URL을 비교해보자.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">3000</span><span class="token operator">/</span>post<span class="token operator">?</span>title<span class="token operator">=</span>Hello<span class="token operator">%</span><span class="token number">20</span>Next<span class="token punctuation">.</span>js</code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">3000</span><span class="token operator">/</span>p<span class="token operator">/</span>hello<span class="token operator">-</span>nextjs</code></pre></div>
<p>두 URL은 같은 곳을 라우팅하고 있지만, 서로 다른 모습을 가진다. 이렇게 변화한 것은 Route Masking을 통해 앞선 Link의 예제가 다음과 같이 수정되어 제공됐기 때문이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">PostLink</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>li<span class="token operator">></span>
    <span class="token operator">&lt;</span>Link <span class="token keyword">as</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`/p/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span> href<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`/post?title=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">.</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>a<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>
<span class="token punctuation">)</span></code></pre></div>
<p><code class="language-text">as</code> 키워드를 통해 href의 질의 문자열(query string)의 별명을 지어준 것이라고 이해하면 되겠다.</p>
<h2>Server Side Support for Clean URLs - Create our Custom Route</h2>
<p>여기서부터 본격적으로 서버 측(Server Side)에 대한 설명이 시작된다. 우선적으로 이번 파트에서 주목한 키워드는 다음 3가지이다.</p>
<ul>
<li>next({ dev }).prepare(): App의 이벤트 리스너</li>
<li>next({ dev }).render(): App의 렌더링</li>
<li>next({ dev }).getRequestHandler(): 리퀘스트 핸들러</li>
</ul>
<p>위 3가지 키워드는 보통  <code class="language-text">const app = next({ dev })</code>을 통해 사용된다. 위 함수 중 prepare의 내용은 <a href="https://github.com/zeit/next.js/blob/fb08e8a1fc452ed4d9d7bda747964cd5c4a7e661/packages/next/server/next-dev-server.js#L54">여기</a>를 살펴보자. 잠깐 살펴보면 이전 버전과의 호환성을 위해 <a href="https://github.com/zeit/next.js/blob/e52508fbf655872085d10904f77eaf35846a0ea2/packages/next-server/server/next-server.ts#L142">next-server.ts의 prepare</a>을 상속받아 사용되고, NextJS를 사용하기 위한 이벤트 리스너의 개념이라고 볼 수 있다. 일명 '사전 준비'를 위해 사용되며 <code class="language-text">then</code>과 <code class="language-text">catch</code>를 이용할 수 있고, then에서 http server의 동작을 수행할 수 있고, catch를 통해 에러를 받을 수 있다.</p>
<p>다른 메서드는 다음에 NextJS의 코드를 까보도록 하자.</p>
<h2>Fetching Data for Pages - getInitialProps</h2>
<p>NextJS에서는 getInitialProps라는 비동기 함수를 통해 페이지의 데이터를 가져올 수 있다. 즉, 렌더링된 정적 페이지의 데이터를 가져오기 위해 사용되는 것이다. 이렇게 얻어진 데이터는 당연히 서버와 통신(axios)할 수도 있으니 아마도 가장 많이 사용될 함수라고 생각했다.</p>
<p>이는 다음과 같이 사용할 수 있다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> Layout <span class="token keyword">from</span> <span class="token string">'../components/MyLayout.js'</span>
<span class="token keyword">import</span> fetch <span class="token keyword">from</span> <span class="token string">'isomorphic-unfetch'</span>

<span class="token keyword">const</span> <span class="token function-variable function">Post</span> <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Layout<span class="token operator">></span>
       <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>show<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
       <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>show<span class="token punctuation">.</span>summary<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;[/]?p>/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
       <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>show<span class="token punctuation">.</span>image<span class="token punctuation">.</span>medium<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Layout<span class="token operator">></span>
<span class="token punctuation">)</span>

Post<span class="token punctuation">.</span>getInitialProps <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> context<span class="token punctuation">.</span>query
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.tvmaze.com/shows/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> show <span class="token operator">=</span> <span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Fetched show: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>show<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> show <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Export into a Static HTML App</h2>
<p>-> No Need to Always Build</p>
<p>한 번 빌드를 해놓으면 그 안의 내용(contents)만 달라질 경우 따로 빌드할 필요가 없기 때문. 따라서 전체 빌드를 진행하는 것이 아니라 'export'를 이용해 내용을 내보내는 것이다. 하지만, 내용만 달라지는 게 아니라 앱 자체가 바뀌는 경우에는 따로 빌드를 해줘야 함.</p>
<h2>Lazy Loading Modules</h2>
<blockquote>
<p>Next.js does automatic code splitting and it is based on the pages in your app. For example, if one of your modules is used at-least in half of your pages, then it moves into the main JavaScript bundle. If not, that module stays inside the page's bundle.</p>
</blockquote>
<p>기본적으로 SPA는 싱글 페이지이기 때문에 모든 모듈이 하나로 합쳐진다. 그래서 이를 해결하기 위해 '코드 스플리팅'이라는 작업을 진행한다는 것을 앞선 문서에서 살펴보았을 것이다. 하지만, 이 코드 스플리팅은 기본적으로 사용자가 정의하지 않기 때문에 SPA를 처음 만들거나 코드 스플리팅을 의식하지 않는다면 코드를 적절하게 나누지 못해 모듈의 크기가 커짐에 따라 페이지의 로딩 속도가 느려질 수 있다.</p>
<p>그래서 NextJS에서는 <a href="https://github.com/zeit/next.js#dynamic-import">'동적 불러오기(dynamic import)</a>'를 통해 크기가 큰 모듈에 대해 따로 번들링을 시킬 수 있다.</p>
<blockquote>
<p>이때 동적 불러오기를 통해 불려진 모듈을 '게으르게 로드된 모듈(Lazy loaded module)'이라고 부른다. </p>
</blockquote>
<p>물론 기본적인 설정만 가지고도 자동 코드 스플리팅이 되지만, NextJS가 똑똑하게 스플리팅을 하지 않기 때문에 사용자의 dynamic import를 활용한 코드 스플리팅이 필요하다고 생각한다. </p>
<blockquote>
<p>기본적으로 NextJS가 모듈을 스플리팅하는 기준은 절반 이상의 페이지에서 사용되는 모듈은 app.js, main.js 혹은 common.js의 번들 파일로 스플리팅되고, 한 페이지 정도의 작은 규모로 사용되는 모듈은 해당 페이지의 번들 파일로 스플리팅한다.</p>
</blockquote>
<p>그래서 다음의 코드를 보고 둘의 차이를 확인해보도록 하자.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> firebase <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'firebase'</span><span class="token punctuation">)</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    firebase<span class="token punctuation">.</span><span class="token function">initializeApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      databaseURL<span class="token punctuation">:</span> <span class="token string">'https://hacker-news.firebaseio.com'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// we skip the "already exists" message which is</span>
    <span class="token comment">// not an actual error when we're hot-reloading</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex">/already exists/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Firebase initialization error'</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>stack<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> firebase<span class="token punctuation">.</span><span class="token function">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'v0'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// const firebase = require('firebase')</span>
    <span class="token keyword">const</span> firebase <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'firebase'</span><span class="token punctuation">)</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    firebase<span class="token punctuation">.</span><span class="token function">initializeApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      databaseURL<span class="token punctuation">:</span> <span class="token string">'https://hacker-news.firebaseio.com'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// we skip the "already exists" message which is</span>
    <span class="token comment">// not an actual error when we're hot-reloading</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex">/already exists/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Firebase initialization error'</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>stack<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> firebase<span class="token punctuation">.</span><span class="token function">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'v0'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이 두 코드는 db를 로드하기 위해 사용되는데, 코드 상으로는 이 둘의 실행 결과가 크게 다를 것 없는 것처럼 보인다. 하지만, 하단의 모듈과 같이 동적으로 불러오기(import)를 하면, 해당 모듈이 필요할 때만 불러와서 사용할 수 있다. </p>
<p>그렇기 때문에 페이지의 로딩 속도를 개선할 수 있는 것이다. 추가적으로 하단의 경우는 번들링될 때 <code class="language-text">chunks/firebase-[a-random-string].js</code>의 형태로 저장되기 때문에 청크된 모듈이 필요해질 때마다 불려간다고 이해하면 될 것이다.</p>
<p>하지만, 이 예제는 Lazy loading을 위한 완벽한 사례는 아니라고 설명한다. 다음의 설명을 보자.</p>
<blockquote>
<p>Frankly, this example is not the perfect use case for lazy loading. That is simply because,</p>
<ul>
<li>You need the <code class="language-text">firebase</code> module in all of the pages.</li>
<li>Lazy loaded firebase module reduces the size of the main JavaScript bundle <code class="language-text">app.js</code>,
but it doesn't affect the initial page loading time since the page is server rendered.</li>
<li>Loading of the main JavaScript bundle doesn't block the initial HTML rendering</li>
</ul>
</blockquote>
<p>그 이유를 정리하면, 게으르게 로드된 firebase 모듈(Lazy loaded firebase module)은 app.js의 크기를 줄이긴 했지만, 이 동작이 초기 페이지 로딩에 영향을 주는 것이 아니고 줄어든 app.js가 더 빨리 로드되기 때문에 빠른 상호작용을 제공하는 것이라고 이야기한다. 그렇기 때문에 게으른 로딩을 위한 사례는 아니라고 이야기하는 것이다.</p>
<p>어찌됐든, 이것은 완벽하지는 않지만, 괘 괜찮은 예제임에 틀림없으니 지금은 이정도만 이해하고 넘어가도록 하자.</p>
<h2>Lazy Loading Components</h2>
<p>앞선 Lazy Loading Modules의 사례와 마찬가지로 이번에는 꽤 큰 모듈이 아닌 꽤 큰 컴포넌트를 불러오는 것에 대한 이야기이다. 이번 예제는 HOC가 적용된 예제이기 때문에 HOC가 익숙하지 않다면 상대적으로 어렵게 느낄 수 있다. 그렇기 때문에 최대한 HOC에 대한 내용은 배제하고 Lazy Loading Components 개념에 대해 알아보도록 할 것이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> MyLayout <span class="token keyword">from</span> <span class="token string">'../components/MyLayout'</span>
<span class="token keyword">import</span> marked <span class="token keyword">from</span> <span class="token string">'marked'</span>
<span class="token keyword">import</span> Highlight <span class="token keyword">from</span> <span class="token string">'react-highlight'</span>

marked<span class="token punctuation">.</span><span class="token function">setOptions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  gfm<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  tables<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  breaks<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">WithPost</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">PostPage</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>MyLayout<span class="token operator">></span>
          <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>options<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
          <span class="token operator">&lt;</span>div<span class="token operator">></span>
            <span class="token operator">&lt;</span>Highlight innerHTML<span class="token operator">></span>
              <span class="token punctuation">{</span><span class="token function">marked</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">}</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>Highlight<span class="token operator">></span>
          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>MyLayout<span class="token operator">></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>위의 코드에서 다음과 같이 선언부를 수정해보자.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">//import Highlight from 'react-highlight'</span>
<span class="token keyword">import</span> dynamic <span class="token keyword">from</span> <span class="token string">'next/dynamic'</span>

<span class="token keyword">const</span> Highlight <span class="token operator">=</span> <span class="token function">dynamic</span><span class="token punctuation">(</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'react-highlight'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div>
<p>이것은 NextJS의 dynamic을 이용한 import 방식으로, 이렇게 하면 <code class="language-text">react-highlight</code>가 별도의 파일(chunks/react-hightlight-[a-random-string].js)로 번들링된다.</p>
<p>하지만, 이것에는 문제가 있다. 원하지 않을 때(코드를 하이라이팅 하지 않는 상황)에도 로드되는 것이 그 원인인데, 이를 해결하기 위해서는 HOC를 통해 조건 검사를 하고, 조건에 맞을 때에만 하이라이트를 시켜줘야 한다. 그래서 다음과 같이 HOC를 구성하면 이를 해결할 수 있다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> MyLayout <span class="token keyword">from</span> <span class="token string">'../components/MyLayout'</span>
<span class="token keyword">import</span> marked <span class="token keyword">from</span> <span class="token string">'marked'</span>
<span class="token keyword">import</span> Highlight <span class="token keyword">from</span> <span class="token string">'react-highlight'</span>

marked<span class="token punctuation">.</span><span class="token function">setOptions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  gfm<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  tables<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  breaks<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">WithPost</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">PostPage</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
        <span class="token function">renderMarkdown</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// If a code snippet contains in the markdown content</span>
            <span class="token comment">// then use Highlight component</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/~~~/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>
                    <span class="token operator">&lt;</span>div<span class="token operator">></span>
                        <span class="token operator">&lt;</span>Highlight innerHTML<span class="token operator">></span>
                            <span class="token punctuation">{</span><span class="token function">marked</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">}</span>
                        <span class="token operator">&lt;</span><span class="token operator">/</span>Highlight<span class="token operator">></span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// If not, simply render the generated HTML from markdown</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>
                <span class="token operator">&lt;</span>div
                    dangerouslySetInnerHTML<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>__html<span class="token punctuation">:</span> <span class="token function">marked</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
                <span class="token operator">/</span><span class="token operator">></span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>
                <span class="token operator">&lt;</span>MyLayout<span class="token operator">></span>
                    <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>options<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
                    <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renderMarkdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>MyLayout<span class="token operator">></span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이처럼 정규표현식 검사 코드<code class="language-text">/~~~/.test(options.content</code>를 활용해 하이라이트 여부를 지정해주면 앞선 문제가 해결된다. 앞서 언급한 것처럼 이제 애플리케이션이 필요할 때에만 클라이언트에서 react-hightlight를 다운로드하고, 로드하는 동안 로딩 컴포넌트가 표시된다.</p>
<p>지금까지 설명한 Lazy loading dynamic components는 고성능 애플리케이션에서 꽤 중요한 역할을 한다. 필요할 때마다 컴포넌트를 로드하고, 그 결과 페이지가 다운로드 하는 JS의 양이 줄어들고 애플리케이션을 더 빨리 로드할 수 있으며, 보다 나은 사용자 경험을 제공할 수 있는 것이다.</p>
<p>더불어 NextJS는 동적 컴포넌트에 대해서도 SSR을 제공하기 때문에 동적 컴포넌트로 인한 자원 손실은 우려하지 않아도 되기 때문에 앞선 HOC의 활용 가능한 사례처럼 이용할 수 있을 것이다.</p>
<p>지금까지 NextJS 문서의 아주 기본적인 내용을 알아보았다. 지금까지 설명한 것은 정말로 NextJS에서 제공하는 가장 기본적이고 핵심적인 내용이기 때문에 NextJS에 입문하고자 한다면 위의 내용을 포함한 기본적인 메커니즘을 이해하는 것이 효율적일 것이다.</p>
<p>그러면 다음에는 NextJS를 활용한 실습을 통해 보다 NextJS에 빠져보는 시간을 갖도록 하겠다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-06-weplanet_project_03</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-06-weplanet_project_03</guid><pubDate>Wed, 06 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;NextJS 실습하기 - 기본 예제 따라하기&lt;/h1&gt;
&lt;p&gt;먼저 NextJS에서 제공하는 기본 튜토리얼을 따라 NextJS를 이해하도록 하자. 기본 튜토리얼은 NextJS의 문서에서 Learn을 통해 진행할 수 있으며, GitHub 로그인을 통한 연동이 가능하기 때문에 어렵지않게 진행할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nextjs.org/learn/basics/getting-started/&quot;&gt;NextJS 기본 튜토리얼&lt;/a&gt;에서 로그인 후 실습을 진행하도록 하자. 실습 진행은 각자의 몫이기 때문에 여기에 별도의 글을 작성하지는 않고, 그저 후기를 작성하도록 할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;후기: NextJS의 튜토리얼은 단순히 NextJS를 이해하는 것을 넘어 SSR 그 자체를 이해할 수 있는 튜토리얼이었다. 물론 앞으로도 NextJS의 문서를 많이 살펴봐야겠지만, 이번에 진행한 튜토리얼을 통해 얻은 지식 혹은 의문의 해결을 바탕으로 React에서의 SSR에 대해 보다 깊이 이해할 수 있었다.&lt;/p&gt;
&lt;p&gt;또한, SSR을 이해함과 동시에 React의 심화 기술(HOC, Hooks 등)에 대한 관심이 생겼고, 이를 공부하는 과정에서 얻은 인사이트는 웹 프론트 엔드 엔지니어로 한걸음 더 성장할 수 있는 동력이 되었다고 말할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;아무튼 문서에 나오는 것처럼 꽤 괜찮은 튜토리얼이었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://nextjs.org/learn&quot;&gt;참고자료 1 - NextJS Learn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;참고자료 2 - React HOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component&quot;&gt;참고자료 3 - 리액트(React) 이해 4 - Higher Order Component(HOC)로 컴포넌트 재사용 하기&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;이번에 실습을 진행하며 다음과 같은 키워드에 주목했고, 이 키워드를 공부하며 한걸음 더 성장할 수 있었다. 그 키워드는 다음과 같다.&lt;/p&gt;
&lt;h2&gt;Navigate Between Pages - HOC(Higher-order component)&lt;/h2&gt;
&lt;p&gt;Link에 대한 이야기를 하기 전에 고차원 컴포넌트라고 부를 수 있는 HOC에 대해 알아보도록 하자. HOC는 컴포넌트 로직을 재사용하기 위한 React의 응용(고급) 기술이다. 이 기술은 하나의 React API가 아닌 하나의 패턴으로 사용된다. 조금 더 설명하면, HOC는 컴포넌트를 가져와 다음과 같이 다시 반환하는 기술(패턴)이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; EnhancedComponent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;higherOrderComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;WrappedComponent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 일반적으로 함수를 반환하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;HOF&lt;/a&gt;와 유사하지만, 함수 대신 컴포넌트를 반환한다고 할 수 있다. 이렇게 함으로써 HOC는 리앧ㄱ트 컴포넌트를 인자로 받아서 모종의 처리를 한 후 새로운 리액트 컴포넌트를 리턴하는 컴포넌트라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;HOC는 다음과 같이 활용할 수 있다(&lt;a href=&quot;https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%9D%B4%ED%95%B4-4-higher-order-component&quot;&gt;참고자료2의 내용&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;&lt;strong&gt;Container 컴포넌트와 Presentational 컴포넌트&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;분리&lt;/strong&gt;: 비지니스 로직을 담당하는 컴포넌트(Container 컴포넌트)와 디스플레이를 담당하는 컴포넌트(Presentational 컴포넌트)를 분리하여 사용 할 때, 컨테이너 컴포넌트를 HOC로 만들어서 사용 할 수 있다.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로딩 중 화면 표시&lt;/strong&gt;: 보통 SPA(Single Page App)에서 화면이 로딩 중일 때, Skeleton 화면을 보여주고, 로딩이 완료되면 데이터를 보여줄 때 사용 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유저 인증 로직 처리&lt;/strong&gt;: 컴포넌트 내에서 권한 체크나 로그인 상태를 체크하기 보다는 인증 로직을 HOC로 분리하면 컴포넌트 재사용성도 높일 수 있고, 컴포넌트에서 역할 분리도 쉽게 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;에러 메세지 표시&lt;/strong&gt;: 컴포넌트 내에서 분기문(if/else 등)을 통해 처리 할 수도 있지만, 분기문을 HOC로 만들어 처리 하면 컴포넌트를 더욱 깔끔하게 사용 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Navigate Between Pages - Link&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Link is Just a Higher Order Component (HOC)&lt;/p&gt;
&lt;p&gt;Actually, the style prop on &lt;code class=&quot;language-text&quot;&gt;next/link&lt;/code&gt; has no effect. That&apos;s because &lt;code class=&quot;language-text&quot;&gt;next/link&lt;/code&gt;is just a &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;higher order component&lt;/a&gt; which only accepts the &quot;href&quot; and some similar props. If you need to style it, you need to do it to the underlying component.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NextJS의 Link는 HOC이다. 위와 같은 문서의 내용에서도 알 수 있듯이 Link는 단순히 HOC이기 때문에 이미 지정된 props에 대해서만 반응한다. 그래서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;a&amp;gt; 태그&lt;/code&gt;와 같은 일종의 테그로 인식해 사전에 지정된 props가 아닌 style 등의 props를 전달한다면 Link에서 그 결과를 기대하기는 힘들다.&lt;/p&gt;
&lt;h2&gt;Create Dynamic Pages - Passing Data via Query Strings&lt;/h2&gt;
&lt;p&gt;Link에서는 문자열 매개변수(string parameter)를 통해 데이터를 전달한다. NextJS에서는 다음과 같이 질의 문자열(query strings)을 통해 어떤 데이터던지 전달할 수 있다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;PostLink&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;li&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link href&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token string&quot;&gt;`/post?title=&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;li&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;반대로 데이터를 받는 입장은 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;withRouter&lt;/code&gt; 메서드를 사용해서 값을 전달받는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;withRouter&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;next/router&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Layout &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../components/MyLayout.js&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Page &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;withRouter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Layout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
       &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;router&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;query&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
       &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;This is the blog post content&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Layout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; Page&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 서로 문서에서 다음과 같은 동작을 주고받고 있다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;We import and use the &quot;withRouter&quot; function from &quot;next/router&quot; this will inject the Next.js router as a property&lt;/li&gt;
&lt;li&gt;In this case, we are using the router&apos;s “query” object, which has the query string params.&lt;/li&gt;
&lt;li&gt;Therefore, we get the title with &lt;code class=&quot;language-text&quot;&gt;props.router.query.title&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;이처럼 NextJS에서는 &lt;code class=&quot;language-text&quot;&gt;Link&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;withRouter&lt;/code&gt; 통해 클라이언트 측 라우팅을 진행하고, 질의(query) 객체를 이용해 매개변수를 주고받는다. &lt;/p&gt;
&lt;h2&gt;Clean URLs with Route Masking - Route Masking&lt;/h2&gt;
&lt;p&gt;Route Masking은 사용자의 입장에서 URL을 보다 깔끔하게(Clean) 받을 수 있는 기법이다. 두 URL을 비교해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;http&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;localhost&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;post&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;title&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;Hello&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;Next&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;http&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;localhost&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;hello&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;nextjs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 URL은 같은 곳을 라우팅하고 있지만, 서로 다른 모습을 가진다. 이렇게 변화한 것은 Route Masking을 통해 앞선 Link의 예제가 다음과 같이 수정되어 제공됐기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;PostLink&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;li&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token string&quot;&gt;`/p/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; href&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token string&quot;&gt;`/post?title=&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Link&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;li&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;as&lt;/code&gt; 키워드를 통해 href의 질의 문자열(query string)의 별명을 지어준 것이라고 이해하면 되겠다.&lt;/p&gt;
&lt;h2&gt;Server Side Support for Clean URLs - Create our Custom Route&lt;/h2&gt;
&lt;p&gt;여기서부터 본격적으로 서버 측(Server Side)에 대한 설명이 시작된다. 우선적으로 이번 파트에서 주목한 키워드는 다음 3가지이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next({ dev }).prepare(): App의 이벤트 리스너&lt;/li&gt;
&lt;li&gt;next({ dev }).render(): App의 렌더링&lt;/li&gt;
&lt;li&gt;next({ dev }).getRequestHandler(): 리퀘스트 핸들러&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 3가지 키워드는 보통  &lt;code class=&quot;language-text&quot;&gt;const app = next({ dev })&lt;/code&gt;을 통해 사용된다. 위 함수 중 prepare의 내용은 &lt;a href=&quot;https://github.com/zeit/next.js/blob/fb08e8a1fc452ed4d9d7bda747964cd5c4a7e661/packages/next/server/next-dev-server.js#L54&quot;&gt;여기&lt;/a&gt;를 살펴보자. 잠깐 살펴보면 이전 버전과의 호환성을 위해 &lt;a href=&quot;https://github.com/zeit/next.js/blob/e52508fbf655872085d10904f77eaf35846a0ea2/packages/next-server/server/next-server.ts#L142&quot;&gt;next-server.ts의 prepare&lt;/a&gt;을 상속받아 사용되고, NextJS를 사용하기 위한 이벤트 리스너의 개념이라고 볼 수 있다. 일명 &apos;사전 준비&apos;를 위해 사용되며 &lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;를 이용할 수 있고, then에서 http server의 동작을 수행할 수 있고, catch를 통해 에러를 받을 수 있다.&lt;/p&gt;
&lt;p&gt;다른 메서드는 다음에 NextJS의 코드를 까보도록 하자.&lt;/p&gt;
&lt;h2&gt;Fetching Data for Pages - getInitialProps&lt;/h2&gt;
&lt;p&gt;NextJS에서는 getInitialProps라는 비동기 함수를 통해 페이지의 데이터를 가져올 수 있다. 즉, 렌더링된 정적 페이지의 데이터를 가져오기 위해 사용되는 것이다. 이렇게 얻어진 데이터는 당연히 서버와 통신(axios)할 수도 있으니 아마도 가장 많이 사용될 함수라고 생각했다.&lt;/p&gt;
&lt;p&gt;이는 다음과 같이 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Layout &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../components/MyLayout.js&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; fetch &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;isomorphic-unfetch&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Post&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Layout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
       &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
       &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;summary&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;/&amp;lt;[/]?p&gt;/g&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
       &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;img src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;show&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;image&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;medium&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Layout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

Post&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;getInitialProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;context&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;query
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token string&quot;&gt;`https://api.tvmaze.com/shows/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;id&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; show &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token string&quot;&gt;`Fetched show: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;show&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; show &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Export into a Static HTML App&lt;/h2&gt;
&lt;p&gt;-&gt; No Need to Always Build&lt;/p&gt;
&lt;p&gt;한 번 빌드를 해놓으면 그 안의 내용(contents)만 달라질 경우 따로 빌드할 필요가 없기 때문. 따라서 전체 빌드를 진행하는 것이 아니라 &apos;export&apos;를 이용해 내용을 내보내는 것이다. 하지만, 내용만 달라지는 게 아니라 앱 자체가 바뀌는 경우에는 따로 빌드를 해줘야 함.&lt;/p&gt;
&lt;h2&gt;Lazy Loading Modules&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Next.js does automatic code splitting and it is based on the pages in your app. For example, if one of your modules is used at-least in half of your pages, then it moves into the main JavaScript bundle. If not, that module stays inside the page&apos;s bundle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;기본적으로 SPA는 싱글 페이지이기 때문에 모든 모듈이 하나로 합쳐진다. 그래서 이를 해결하기 위해 &apos;코드 스플리팅&apos;이라는 작업을 진행한다는 것을 앞선 문서에서 살펴보았을 것이다. 하지만, 이 코드 스플리팅은 기본적으로 사용자가 정의하지 않기 때문에 SPA를 처음 만들거나 코드 스플리팅을 의식하지 않는다면 코드를 적절하게 나누지 못해 모듈의 크기가 커짐에 따라 페이지의 로딩 속도가 느려질 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 NextJS에서는 &lt;a href=&quot;https://github.com/zeit/next.js#dynamic-import&quot;&gt;&apos;동적 불러오기(dynamic import)&lt;/a&gt;&apos;를 통해 크기가 큰 모듈에 대해 따로 번들링을 시킬 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이때 동적 불러오기를 통해 불려진 모듈을 &apos;게으르게 로드된 모듈(Lazy loaded module)&apos;이라고 부른다. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;물론 기본적인 설정만 가지고도 자동 코드 스플리팅이 되지만, NextJS가 똑똑하게 스플리팅을 하지 않기 때문에 사용자의 dynamic import를 활용한 코드 스플리팅이 필요하다고 생각한다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기본적으로 NextJS가 모듈을 스플리팅하는 기준은 절반 이상의 페이지에서 사용되는 모듈은 app.js, main.js 혹은 common.js의 번들 파일로 스플리팅되고, 한 페이지 정도의 작은 규모로 사용되는 모듈은 해당 페이지의 번들 파일로 스플리팅한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래서 다음의 코드를 보고 둘의 차이를 확인해보도록 하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firebase &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;firebase&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    firebase&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;initializeApp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      databaseURL&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://hacker-news.firebaseio.com&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// we skip the &quot;already exists&quot; message which is&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// not an actual error when we&apos;re hot-reloading&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;/already exists/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Firebase initialization error&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stack&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; firebase&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;v0&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const firebase = require(&apos;firebase&apos;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firebase &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;firebase&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    firebase&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;initializeApp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      databaseURL&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://hacker-news.firebaseio.com&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// we skip the &quot;already exists&quot; message which is&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// not an actual error when we&apos;re hot-reloading&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;/already exists/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Firebase initialization error&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stack&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; firebase&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;v0&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 두 코드는 db를 로드하기 위해 사용되는데, 코드 상으로는 이 둘의 실행 결과가 크게 다를 것 없는 것처럼 보인다. 하지만, 하단의 모듈과 같이 동적으로 불러오기(import)를 하면, 해당 모듈이 필요할 때만 불러와서 사용할 수 있다. &lt;/p&gt;
&lt;p&gt;그렇기 때문에 페이지의 로딩 속도를 개선할 수 있는 것이다. 추가적으로 하단의 경우는 번들링될 때 &lt;code class=&quot;language-text&quot;&gt;chunks/firebase-[a-random-string].js&lt;/code&gt;의 형태로 저장되기 때문에 청크된 모듈이 필요해질 때마다 불려간다고 이해하면 될 것이다.&lt;/p&gt;
&lt;p&gt;하지만, 이 예제는 Lazy loading을 위한 완벽한 사례는 아니라고 설명한다. 다음의 설명을 보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Frankly, this example is not the perfect use case for lazy loading. That is simply because,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You need the &lt;code class=&quot;language-text&quot;&gt;firebase&lt;/code&gt; module in all of the pages.&lt;/li&gt;
&lt;li&gt;Lazy loaded firebase module reduces the size of the main JavaScript bundle &lt;code class=&quot;language-text&quot;&gt;app.js&lt;/code&gt;,
but it doesn&apos;t affect the initial page loading time since the page is server rendered.&lt;/li&gt;
&lt;li&gt;Loading of the main JavaScript bundle doesn&apos;t block the initial HTML rendering&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 이유를 정리하면, 게으르게 로드된 firebase 모듈(Lazy loaded firebase module)은 app.js의 크기를 줄이긴 했지만, 이 동작이 초기 페이지 로딩에 영향을 주는 것이 아니고 줄어든 app.js가 더 빨리 로드되기 때문에 빠른 상호작용을 제공하는 것이라고 이야기한다. 그렇기 때문에 게으른 로딩을 위한 사례는 아니라고 이야기하는 것이다.&lt;/p&gt;
&lt;p&gt;어찌됐든, 이것은 완벽하지는 않지만, 괘 괜찮은 예제임에 틀림없으니 지금은 이정도만 이해하고 넘어가도록 하자.&lt;/p&gt;
&lt;h2&gt;Lazy Loading Components&lt;/h2&gt;
&lt;p&gt;앞선 Lazy Loading Modules의 사례와 마찬가지로 이번에는 꽤 큰 모듈이 아닌 꽤 큰 컴포넌트를 불러오는 것에 대한 이야기이다. 이번 예제는 HOC가 적용된 예제이기 때문에 HOC가 익숙하지 않다면 상대적으로 어렵게 느낄 수 있다. 그렇기 때문에 최대한 HOC에 대한 내용은 배제하고 Lazy Loading Components 개념에 대해 알아보도록 할 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; MyLayout &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../components/MyLayout&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; marked &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;marked&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Highlight &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react-highlight&apos;&lt;/span&gt;

marked&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setOptions&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  gfm&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  tables&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  breaks&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;WithPost&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PostPage&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;MyLayout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Highlight innerHTML&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
              &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;marked&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Highlight&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
          &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;MyLayout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드에서 다음과 같이 선언부를 수정해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//import Highlight from &apos;react-highlight&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; dynamic &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;next/dynamic&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Highlight &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dynamic&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;react-highlight&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것은 NextJS의 dynamic을 이용한 import 방식으로, 이렇게 하면 &lt;code class=&quot;language-text&quot;&gt;react-highlight&lt;/code&gt;가 별도의 파일(chunks/react-hightlight-[a-random-string].js)로 번들링된다.&lt;/p&gt;
&lt;p&gt;하지만, 이것에는 문제가 있다. 원하지 않을 때(코드를 하이라이팅 하지 않는 상황)에도 로드되는 것이 그 원인인데, 이를 해결하기 위해서는 HOC를 통해 조건 검사를 하고, 조건에 맞을 때에만 하이라이트를 시켜줘야 한다. 그래서 다음과 같이 HOC를 구성하면 이를 해결할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; MyLayout &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;../components/MyLayout&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; marked &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;marked&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Highlight &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react-highlight&apos;&lt;/span&gt;

marked&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setOptions&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  gfm&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  tables&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  breaks&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;WithPost&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PostPage&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;renderMarkdown&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;// If a code snippet contains in the markdown content&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;// then use Highlight component&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;/~~~/&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Highlight innerHTML&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                            &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;marked&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Highlight&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;// If not, simply render the generated HTML from markdown&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div
                    dangerouslySetInnerHTML&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;__html&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;marked&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;MyLayout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h1&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
                    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;renderMarkdown&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;MyLayout&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이처럼 정규표현식 검사 코드&lt;code class=&quot;language-text&quot;&gt;/~~~/.test(options.content&lt;/code&gt;를 활용해 하이라이트 여부를 지정해주면 앞선 문제가 해결된다. 앞서 언급한 것처럼 이제 애플리케이션이 필요할 때에만 클라이언트에서 react-hightlight를 다운로드하고, 로드하는 동안 로딩 컴포넌트가 표시된다.&lt;/p&gt;
&lt;p&gt;지금까지 설명한 Lazy loading dynamic components는 고성능 애플리케이션에서 꽤 중요한 역할을 한다. 필요할 때마다 컴포넌트를 로드하고, 그 결과 페이지가 다운로드 하는 JS의 양이 줄어들고 애플리케이션을 더 빨리 로드할 수 있으며, 보다 나은 사용자 경험을 제공할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;더불어 NextJS는 동적 컴포넌트에 대해서도 SSR을 제공하기 때문에 동적 컴포넌트로 인한 자원 손실은 우려하지 않아도 되기 때문에 앞선 HOC의 활용 가능한 사례처럼 이용할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;지금까지 NextJS 문서의 아주 기본적인 내용을 알아보았다. 지금까지 설명한 것은 정말로 NextJS에서 제공하는 가장 기본적이고 핵심적인 내용이기 때문에 NextJS에 입문하고자 한다면 위의 내용을 포함한 기본적인 메커니즘을 이해하는 것이 효율적일 것이다.&lt;/p&gt;
&lt;p&gt;그러면 다음에는 NextJS를 활용한 실습을 통해 보다 NextJS에 빠져보는 시간을 갖도록 하겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - Js study_계획]]></title><description><![CDATA[<h1>WePlanet Intern - study</h1>
<h3>앞으로의 계획 및 목표</h3>
<ul>
<li>익숙하지 않은 Javascript(ES6, ES7, ES8) 문법 이해, React, Node(Express) 문법 및 각종 라이브러리의 메서드(파리미터, 결과 중심) 이해</li>
<li>매일 어제와 오늘의 스터디 내용 (일일 회의(매일 10시 예정) 시) 공유</li>
<li>모든 스터디 내용은 마크다운으로 작성, 블로그에 기재</li>
</ul>
<h3>스터디 초점 및 유의사항</h3>
<ul>
<li>나의 기술에 대한 이해도 향상(문법적으로 어떤 문장을 적음에 있어 '왜 이 문장을 사용해야 했는지'에 대한 명쾌한 해답을 내릴 수 있을 정도) 및 Front-end 개발에 있어 필요한 덕목을 갖추도록 하자.</li>
<li>리펙터링 생각해보기(코드는 완성된 그 순간 레거시, 그렇기 때문에 나라면 어떻게 구현했을지 혹은 어떻게 하면 질좋은 코드를 만들 수 있을지 생각해보기)</li>
<li>
<p>동료의 시간을 낭비시키지 말자.</p>
<ul>
<li>검색이 가능한 것에 대해서는 질문을 하지않고 스스로(구글링, 서적 열람 등) 해결하도록 하자.</li>
<li>만약 질문이 필요하다면 어떻게 해서 그런 질문을 하게 됐는지에 대해서도 말해야 할 것이다.</li>
<li>질문을 잘하는 개발자 - <a href="https://jbee.io/essay/good_questionor/">https://jbee.io/essay/good_questionor/</a> 참고</li>
</ul>
</li>
<li>참고자료는 링크 및 URI로 해당 문서에 공유하도록 하자.</li>
</ul>
<h3>스터디 목차 및 설정 이유(중점적으로 살펴볼 내용 명시)</h3>
<ol>
<li>
<p>JS 문법 학습: 구현만 가능하다고 적재적소에 원하는 코드를 삽입할 수는 없을 것이라는 생각이 있었기 때문에, 이를 해결하기 위해서 JS의 문법을 다시 한 번 학습하고자 하는 필요성을 느꼈다. 하지만 아주 기본적인 단계를 다시 학습하는 건 불필요하다는 생각이 있기 때문에 기본 문법 및 매커니즘 등의 이해는 건너뛴다.</p>
<ol>
<li>ES3(ES1999): 기본적인 문법을 제외한 함수 단위의 스코프, 호이스팅, 클로저, 프로토타입 등</li>
<li>ES5(ES2009): forEach, map, reduce, filter, some, every와 같은 순환 메소드, 객체의 프로퍼티 설정(생성, 수정, 복사하는 표준 메소드&#x3C;Object.Create(), Object.defineProperty(), Object.freeze(), Object.assign()> 등과 getter, setter, Object.key() 메소드), strict 모드(use strict), bind() 메소드 등</li>
<li>ES6(ES2015): 호이스팅이 사라진 것 같은 효과, 함수 단위 스코프에서 블록 단위 스코프로 변경됨, this를 동적으로 바인딩하지 않는 화살표 함수, 모듈화 지원, 콜백 지옥에서 구원해줄 Promise, Default와 Rest 파라미터, 해체 할당, Spread 연산자, 템플릿 리터럴, 클래스, 기타 여러 사항(브라우저에서 지원하지 않는 문법 등을 처리하는 트랜스파일러(Babel)과 모듈화를 사용하기 위한 모듈 번들러(WebPack)의 등장, Nodejs의 부상 JS 진영의 생태계 진화에 따라 만들어진 문법) 등</li>
<li>ES7(ES2016): 제곱 연산자(**), Array.includes 배열에 해당 요소가 존재하는지 확인하는 메소드</li>
<li>ES8(ES2017): async와 await, 객체의 심화된 메소드(Object.entries(), Object.getOwnPropertDescriptors()(Object.getOwnPropertyDescriptor의 복수 형태), 문자열(편의 기능 추가 -> 문자열 앞부분에 공백을 넣어 자리수를 맞추는 String.padStart(), 문자열 뒷부분에 공백을 넣어 자리를 맞추는 String.padEnd()), 매개변수 마지막에 콤마를 붙이는 걸 허용</li>
<li>ES9(ES2018): 구조 분해 할당(Spread)(… 키워드), Promise finally(then과 catch 외에도 finally가 추가되었다. 성공, 실패 여부와 상관없이 무조건 실행되는 메서드), Async iteration(async 문법을 생성기랑 for of 문에서도 사용 가능해졌다.), 정규표현식의 강화(lookbehind가 생기고 캡쳐링 그룹에 이름을 지정해 줄 수 있다.), </li>
</ol>
</li>
<li>
<p>리펙터링을 한다는 마음으로 사내 코드 읽기: 사내 코드의 규율 적응 및 모르는 라이브러리의 메서드 및 컴포넌트의 학습이 필요하다고 느꼈기 때문에, 이를 해결하기 위해 사내의 코드를 읽고, 읽은 코드를 바탕으로 학습할 내용을 정리할 것이다. 물론 사내의 코드를 공유하지는 않을 것이다.</p>
</li>
</ol>]]></description><link>https://rayleighko.github.io/blog/2019-03-05-weplanet_study_plan</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-05-weplanet_study_plan</guid><pubDate>Tue, 05 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;WePlanet Intern - study&lt;/h1&gt;
&lt;h3&gt;앞으로의 계획 및 목표&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;익숙하지 않은 Javascript(ES6, ES7, ES8) 문법 이해, React, Node(Express) 문법 및 각종 라이브러리의 메서드(파리미터, 결과 중심) 이해&lt;/li&gt;
&lt;li&gt;매일 어제와 오늘의 스터디 내용 (일일 회의(매일 10시 예정) 시) 공유&lt;/li&gt;
&lt;li&gt;모든 스터디 내용은 마크다운으로 작성, 블로그에 기재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;스터디 초점 및 유의사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 기술에 대한 이해도 향상(문법적으로 어떤 문장을 적음에 있어 &apos;왜 이 문장을 사용해야 했는지&apos;에 대한 명쾌한 해답을 내릴 수 있을 정도) 및 Front-end 개발에 있어 필요한 덕목을 갖추도록 하자.&lt;/li&gt;
&lt;li&gt;리펙터링 생각해보기(코드는 완성된 그 순간 레거시, 그렇기 때문에 나라면 어떻게 구현했을지 혹은 어떻게 하면 질좋은 코드를 만들 수 있을지 생각해보기)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동료의 시간을 낭비시키지 말자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;검색이 가능한 것에 대해서는 질문을 하지않고 스스로(구글링, 서적 열람 등) 해결하도록 하자.&lt;/li&gt;
&lt;li&gt;만약 질문이 필요하다면 어떻게 해서 그런 질문을 하게 됐는지에 대해서도 말해야 할 것이다.&lt;/li&gt;
&lt;li&gt;질문을 잘하는 개발자 - &lt;a href=&quot;https://jbee.io/essay/good_questionor/&quot;&gt;https://jbee.io/essay/good_questionor/&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;참고자료는 링크 및 URI로 해당 문서에 공유하도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;스터디 목차 및 설정 이유(중점적으로 살펴볼 내용 명시)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;JS 문법 학습: 구현만 가능하다고 적재적소에 원하는 코드를 삽입할 수는 없을 것이라는 생각이 있었기 때문에, 이를 해결하기 위해서 JS의 문법을 다시 한 번 학습하고자 하는 필요성을 느꼈다. 하지만 아주 기본적인 단계를 다시 학습하는 건 불필요하다는 생각이 있기 때문에 기본 문법 및 매커니즘 등의 이해는 건너뛴다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES3(ES1999): 기본적인 문법을 제외한 함수 단위의 스코프, 호이스팅, 클로저, 프로토타입 등&lt;/li&gt;
&lt;li&gt;ES5(ES2009): forEach, map, reduce, filter, some, every와 같은 순환 메소드, 객체의 프로퍼티 설정(생성, 수정, 복사하는 표준 메소드&amp;#x3C;Object.Create(), Object.defineProperty(), Object.freeze(), Object.assign()&gt; 등과 getter, setter, Object.key() 메소드), strict 모드(use strict), bind() 메소드 등&lt;/li&gt;
&lt;li&gt;ES6(ES2015): 호이스팅이 사라진 것 같은 효과, 함수 단위 스코프에서 블록 단위 스코프로 변경됨, this를 동적으로 바인딩하지 않는 화살표 함수, 모듈화 지원, 콜백 지옥에서 구원해줄 Promise, Default와 Rest 파라미터, 해체 할당, Spread 연산자, 템플릿 리터럴, 클래스, 기타 여러 사항(브라우저에서 지원하지 않는 문법 등을 처리하는 트랜스파일러(Babel)과 모듈화를 사용하기 위한 모듈 번들러(WebPack)의 등장, Nodejs의 부상 JS 진영의 생태계 진화에 따라 만들어진 문법) 등&lt;/li&gt;
&lt;li&gt;ES7(ES2016): 제곱 연산자(**), Array.includes 배열에 해당 요소가 존재하는지 확인하는 메소드&lt;/li&gt;
&lt;li&gt;ES8(ES2017): async와 await, 객체의 심화된 메소드(Object.entries(), Object.getOwnPropertDescriptors()(Object.getOwnPropertyDescriptor의 복수 형태), 문자열(편의 기능 추가 -&gt; 문자열 앞부분에 공백을 넣어 자리수를 맞추는 String.padStart(), 문자열 뒷부분에 공백을 넣어 자리를 맞추는 String.padEnd()), 매개변수 마지막에 콤마를 붙이는 걸 허용&lt;/li&gt;
&lt;li&gt;ES9(ES2018): 구조 분해 할당(Spread)(… 키워드), Promise finally(then과 catch 외에도 finally가 추가되었다. 성공, 실패 여부와 상관없이 무조건 실행되는 메서드), Async iteration(async 문법을 생성기랑 for of 문에서도 사용 가능해졌다.), 정규표현식의 강화(lookbehind가 생기고 캡쳐링 그룹에 이름을 지정해 줄 수 있다.), &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리펙터링을 한다는 마음으로 사내 코드 읽기: 사내 코드의 규율 적응 및 모르는 라이브러리의 메서드 및 컴포넌트의 학습이 필요하다고 느꼈기 때문에, 이를 해결하기 위해 사내의 코드를 읽고, 읽은 코드를 바탕으로 학습할 내용을 정리할 것이다. 물론 사내의 코드를 공유하지는 않을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_02]]></title><description><![CDATA[<h1>(아마도)NextJS를 사용하기 위한 사전 지식</h1>
<p>앞선 내용에서 NextJS를 왜 사용하는지, 언제 사용하면 좋을지를 살펴봤다. 하지만, 아직까지 NextJS에서 제공하는 기능을 전부 이해하지 못했기 때문에 이번에는 NextJS에서 제공하는 기능을 하나하나 살펴보도록 하자.</p>
<p><a href="https://velopert.com/3293">참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기</a></p>
<p><a href="https://nextjs.org/learn/basics/getting-started">참고자료 2 - NextJS Getting Started</a></p>
<p><a href="https://velog.io/@velopert/react-code-splitting">참고자료 3 - 리액트 프로젝트 코드 스플리팅 정복하기</a></p>
<p><a href="http://happycodebox.blogspot.com/2017/03/title_4.html">참고자료 4 - Webpack2 에서 React HMR(Hot Module Replacement) 설정하기</a></p>
<p><a href="https://webpack.js.org/concepts/">참고자료 5 - Webpack Concepts</a></p>
<p><a href="https://webpack.js.org/concepts/hot-module-replacement/">참고자료 6 - Hot Module Replacement</a></p>
<p>우선 앞선 글에서 적은 NextJS가 제공하는 기능을 가져오자.</p>
<div class="gatsby-highlight" data-language="markdown"><pre class="language-markdown"><code class="language-markdown"><span class="token list punctuation">*</span> Server-rendered by default  
<span class="token list punctuation">*</span> Automatic code splitting for faster page loads
<span class="token list punctuation">*</span> Simple client-side routing (page based)
<span class="token list punctuation">*</span> Webpack-based dev environment which supports <span class="token url">[Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/)</span>(HMR)
<span class="token list punctuation">*</span> Able to implement with Express or any other Node.js HTTP server
<span class="token list punctuation">*</span> Customizable with your own Babel and Webpack configurations</code></pre></div>
<p>위의 내용을 한글로 보고 싶다면 이전 글을 참고하도록 하자. 그렇다면 가장 첫 번째, 우리가 익히 알고 있던 'Server-rendered by default'에 대해 살펴보자. 말그대로 "NextJS는 서버 사이드 렌더링을 기본적으로 제공한다"라고 할 수 있을 것이다. 이제는 당연한 이야기지만, NextJS는 리액트기반의 SPA에서 SSR을 하기 위한 도구이기 때문에 이 부분은 이견없이 넘어갈 수 있었다.</p>
<p>하지만 다음 문장에 명시된 'Automatic code splitting for faster page loads'에서 'code splitting'이라는 익숙하지 않은 단어가 등장했다. 그 해답은 <a href="https://velopert.com/3293">참고자료 1</a>에서 어렴풋이 찾을 수 있었다.</p>
<h2>코드 스플리팅(Code Splitting)</h2>
<p>코드 스플리팅(나누기)이란 일반적인 SPA는 어플리케이션이 Single Page로 구성되어 있기 때문에 예를 들어 A라는 페이지를 보고 싶었을 뿐인데도 페이지를 로딩하면서 사용자가 원하지도 않는 B라는 페이지에 대한 정보도 함께 딸려온다. 이때 코드 스플리팅을 이용하면 새 페이지를 불러오지 않으면서 유동적으로 문제를 해결할 수 있다.</p>
<p>조금 더 디테일하게 설명하자면, 우리가 JS로 애플리케이션을 개발하면, 웹 브라우저의 입장에서는 기본적으로 하나의 파일에 모든 로직이 들어가게 된다. 그렇기 때문에 프로젝트의 규모가 커지면 JS의 용량도 커질 것이고 이와 마찬가지로 페이지 로드를 처리하기 위한 작업도 느려질 것이다. 하지만 코드 스플리팅을 하게 되면, 지금 당장 필요한 코드가 아니라면 다른 파일로 분리시켜서, 필요할 때 로드할 수 있다. 따라서 코드 스플리팅을 하게 되면 페이지의 로딩 속도를 개선할 수 있을 것이다.</p>
<p>여기까지 적고 난 다음 드는 생각은 지금까지의 모든 내용이 귀결된다는 것이었다. 우리는 지금까지 SSR과 CSR에 대해 살펴보았고, SPA에서는 기본적으로 CSR을 체택하지만, NextJS를 통해 쉽게 SSR도 가능하다. 또한, NextJS를 쓰면 SSR의 단점이었던 View를 로드하는 시간을 코드 스플리팅으로 극복할 수 있다는 것이 그것이다.</p>
<p>이제 어느정도 코드 스플리팅에 대해 이해할 수 있었다. 이론적인 이해는 여기까지 진행하도록 하고, 이번 글 이후에 실습을 통해 코드 스플리팅에 대해 더 자세히 알아보도록 하자.</p>
<p>다음 문장인 'Simple client-side routing (page based)'는 말 그대로 페이지 기반 간단한 클라이언트 측 라우팅을 제공한다는 것이다. 이는 NextJS를 써보지 않고 들었을 때는 이해하기 어려울 수 있다. 하지만, 입문자의 입장에서 간단하게 이해하면 NextJS는 기본적으로 pages라는 디렉터리에 각각의 페이지를 저장하고 각각의 페이지를 기반으로 클라이언트에서 (react-router를 이용하는 등) 별도의 라우팅 설정 없이 간단하게 라우팅을 제공한다고 이해하면 된다. 즉, 파일만 만들어도 자동으로 라우팅된다!</p>
<p>다음으로 넘어가서, 'Webpack-based dev environment which supports [Hot Module Replacement(HMR)'을 이해해보자. HMR을 지원하는 웹팩 기반의 개발 환경을 제공한다는 의미로 해석할 수 있을 것이다. 하지만 HMR에 대한 기본적인 이해가 없다면 이 문장이 가지는 진정한 의미를 파악하기는 어려울 것이다. 그래서 이번에는 HMR에 대해 살펴보도록 하자.</p>
<h3>HMR(Hot Module Replacement)</h3>
<p>우선 HMR을 이해하기 위해서는 Webpack을 이해해야 한다. 일반적으로 Webpack은 JS 애플리케이션을 위한 정적 모듈 번들러이다. 백 엔드에서는 OS가 별도의 모듈 시스템을 제공하지만, 프론트 엔드 환경에서는 별도의 모듈 시스템이 없기 때문에 Webpack을 통해 모든 assets(HTML, CSS, JS, 이미지, … 등)을 하나 이상의 번들(bundle.js) 파일로 통합하고, 그 과정에서 Webpack은 import나 require를 이용해 프로젝트의 의존성 관리를 하기도 한다.</p>
<p><a href="https://webpack.js.org/concepts/">Webpack Concepts</a>에 따르면, Webpack은 다음과 같은 Core Concepts(핵심 개념)을 가지고 있다.</p>
<ul>
<li><a href="https://webpack.js.org/concepts/#entry">Entry</a></li>
<li><a href="https://webpack.js.org/concepts/#output">Output</a></li>
<li><a href="https://webpack.js.org/concepts/#loaders">Loaders</a></li>
<li><a href="https://webpack.js.org/concepts/#plugins">Plugins</a></li>
<li><a href="https://webpack.js.org/concepts/#mode">Mode</a></li>
<li><a href="https://webpack.js.org/concepts/#browser-compatibility">Browser Compatibility</a></li>
</ul>
<p>우리는 Webpack을 다룰 일이 거의 없고, 지금 당장 필요하지 않기 때문에 여기서는 짧게 설명하고, 다음에 기회가 되면 다른 글을 통해 살펴보도록 하자. 우선 <strong>Entry</strong>는 Webpack이 번들링을 위해 애플리케이션을 읽어들일 첫 번째 시작점을 의미한다. 다음으로 <strong>OutPut</strong>은 번들링이 끝난 후 결과물을 저장할 경로와 파일 이름에 대한 설정을 의미하고, <strong>Loaders</strong>는 정적 파일을 번들링하기 위한 Webpack의 다양한 로더에 대한 설정을 입력할 수 있다. 다음으로 <strong>Plugins</strong>는 Webpack의 확장 기능을 의미한다. 즉, 원하는 <a href="https://webpack.js.org/plugins/">Plugin</a>을 추가하면 해당 Plugin을 사용할 수 있다. <strong>Mode</strong>는 production, development, none으로 설정 가능하며, 각각 의미 그대로 프로젝트의 배포 상태를 의미한다. 마지막으로 <strong>Browser Compatibility</strong>는 Webpack이 ES5와 호환되는 모든 브라우저를 지원한다는 것을 의미한다.</p>
<p>핵심 개념을 살펴보았지만, 우리가 원한 HMR에 대한 설명은 어디에서도 찾을 수 없었다. 그래서 나는 Webpack에서 제공하는 <a href="https://webpack.js.org/concepts/hot-module-replacement/">Hot Module Replacement</a>를 살펴봐야 했고, 그제서야 HMR을 이해할 수 있었다.</p>
<p>HMR은 '(뜨거울 정도로)빠른 모듈 교체'라고 이해해도 좋을 것이다. 왜냐하면 HMR은 애플리케이션이 동작하는 동안 모듈을 더하고, 지우는 작업을 풀 리로드하지 않고 진행한다. 이렇게 하면 다음과 같은 몇 가지 방법으로 개발 속도를 높일 수 있다.</p>
<ul>
<li>Retain application state which is lost during a full reload.</li>
<li>Save valuable development time by only updating what's changed.</li>
<li>Modifications made to CSS/JS in the source code results in an instant browser update which is almost comparable to changing styles directly in the browser's dev tools.</li>
</ul>
<p>이를 한글로 번역하면 다음과 같다.</p>
<ul>
<li>풀 리로드되는 동안 손실되는 애플리케이션 상태를 유지한다.</li>
<li>변경된 내용만 업데이트하여 개발 시간을 절약한다.</li>
<li>소스 코드에서 CSS/JS를 수정하면, 브라우저의 개발(dev) 도구에서 직접 스타일을 변경하는 것과 거의 유사한 브라우저 업데이트가 이루어진다. (즉, 코드의 변경과 함께 브라우저의 스타일이 실시간으로 변경된다.)</li>
</ul>
<p>즉, HMR을 통해 개발 속도를 향상시킬 수 있는 것이다. 이로써 HMR을 왜, 언제 사용해야 하는지도 알았다. 이제 다음 문장인 'Able to implement with Express or any other Node.js HTTP server'에 대해서 살펴볼 수 있겠다. 이는 간단하게 'Express 혹은 다른 Node.js HTTP 서버의 지원이 가능하다'는 의미이다. 즉, NextJS는 Express나 NginX 등 어떤 Node.js HTTP 서버 환경에서든 동작한다고 이해하고 넘어가도록 하자.</p>
<p>마지막으로 'Customizable with your own Babel and Webpack configurations'은 NextJS가 바벨과 웹펙 설정으로 NextJS의 설정을 사용자 임의대로 변경할 수 있다고 이해하면 될 것이다. 이에 대해서는 직접적으로 사용해보지 않았기 때문에 확실하게 이해했다고 보기는 어렵지만, 지금은 그렇게 깊은 단계까지 이해할 필요는 없다고 생각하고 넘어가도록 하자.</p>
<p>여기까지 NextJS를 사용하기 위한 사전 준비가 끝났다. 이제 우리는 NextJS를 왜, 언제, 어떻게 사용하면 좋을지를 이론적으로 이해할 수 있었다. 이제부터는 이론적인 내용은 차치하고, 실습 위주로 문서를 작성해보도록 하자.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-05-weplanet_project_02</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-05-weplanet_project_02</guid><pubDate>Tue, 05 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;(아마도)NextJS를 사용하기 위한 사전 지식&lt;/h1&gt;
&lt;p&gt;앞선 내용에서 NextJS를 왜 사용하는지, 언제 사용하면 좋을지를 살펴봤다. 하지만, 아직까지 NextJS에서 제공하는 기능을 전부 이해하지 못했기 때문에 이번에는 NextJS에서 제공하는 기능을 하나하나 살펴보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velopert.com/3293&quot;&gt;참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nextjs.org/learn/basics/getting-started&quot;&gt;참고자료 2 - NextJS Getting Started&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@velopert/react-code-splitting&quot;&gt;참고자료 3 - 리액트 프로젝트 코드 스플리팅 정복하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://happycodebox.blogspot.com/2017/03/title_4.html&quot;&gt;참고자료 4 - Webpack2 에서 React HMR(Hot Module Replacement) 설정하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.js.org/concepts/&quot;&gt;참고자료 5 - Webpack Concepts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;참고자료 6 - Hot Module Replacement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;우선 앞선 글에서 적은 NextJS가 제공하는 기능을 가져오자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;markdown&quot;&gt;&lt;pre class=&quot;language-markdown&quot;&gt;&lt;code class=&quot;language-markdown&quot;&gt;&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Server-rendered by default  
&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Automatic code splitting for faster page loads
&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Simple client-side routing (page based)
&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Webpack-based dev environment which supports &lt;span class=&quot;token url&quot;&gt;[Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/)&lt;/span&gt;(HMR)
&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Able to implement with Express or any other Node.js HTTP server
&lt;span class=&quot;token list punctuation&quot;&gt;*&lt;/span&gt; Customizable with your own Babel and Webpack configurations&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 내용을 한글로 보고 싶다면 이전 글을 참고하도록 하자. 그렇다면 가장 첫 번째, 우리가 익히 알고 있던 &apos;Server-rendered by default&apos;에 대해 살펴보자. 말그대로 &quot;NextJS는 서버 사이드 렌더링을 기본적으로 제공한다&quot;라고 할 수 있을 것이다. 이제는 당연한 이야기지만, NextJS는 리액트기반의 SPA에서 SSR을 하기 위한 도구이기 때문에 이 부분은 이견없이 넘어갈 수 있었다.&lt;/p&gt;
&lt;p&gt;하지만 다음 문장에 명시된 &apos;Automatic code splitting for faster page loads&apos;에서 &apos;code splitting&apos;이라는 익숙하지 않은 단어가 등장했다. 그 해답은 &lt;a href=&quot;https://velopert.com/3293&quot;&gt;참고자료 1&lt;/a&gt;에서 어렴풋이 찾을 수 있었다.&lt;/p&gt;
&lt;h2&gt;코드 스플리팅(Code Splitting)&lt;/h2&gt;
&lt;p&gt;코드 스플리팅(나누기)이란 일반적인 SPA는 어플리케이션이 Single Page로 구성되어 있기 때문에 예를 들어 A라는 페이지를 보고 싶었을 뿐인데도 페이지를 로딩하면서 사용자가 원하지도 않는 B라는 페이지에 대한 정보도 함께 딸려온다. 이때 코드 스플리팅을 이용하면 새 페이지를 불러오지 않으면서 유동적으로 문제를 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;조금 더 디테일하게 설명하자면, 우리가 JS로 애플리케이션을 개발하면, 웹 브라우저의 입장에서는 기본적으로 하나의 파일에 모든 로직이 들어가게 된다. 그렇기 때문에 프로젝트의 규모가 커지면 JS의 용량도 커질 것이고 이와 마찬가지로 페이지 로드를 처리하기 위한 작업도 느려질 것이다. 하지만 코드 스플리팅을 하게 되면, 지금 당장 필요한 코드가 아니라면 다른 파일로 분리시켜서, 필요할 때 로드할 수 있다. 따라서 코드 스플리팅을 하게 되면 페이지의 로딩 속도를 개선할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;여기까지 적고 난 다음 드는 생각은 지금까지의 모든 내용이 귀결된다는 것이었다. 우리는 지금까지 SSR과 CSR에 대해 살펴보았고, SPA에서는 기본적으로 CSR을 체택하지만, NextJS를 통해 쉽게 SSR도 가능하다. 또한, NextJS를 쓰면 SSR의 단점이었던 View를 로드하는 시간을 코드 스플리팅으로 극복할 수 있다는 것이 그것이다.&lt;/p&gt;
&lt;p&gt;이제 어느정도 코드 스플리팅에 대해 이해할 수 있었다. 이론적인 이해는 여기까지 진행하도록 하고, 이번 글 이후에 실습을 통해 코드 스플리팅에 대해 더 자세히 알아보도록 하자.&lt;/p&gt;
&lt;p&gt;다음 문장인 &apos;Simple client-side routing (page based)&apos;는 말 그대로 페이지 기반 간단한 클라이언트 측 라우팅을 제공한다는 것이다. 이는 NextJS를 써보지 않고 들었을 때는 이해하기 어려울 수 있다. 하지만, 입문자의 입장에서 간단하게 이해하면 NextJS는 기본적으로 pages라는 디렉터리에 각각의 페이지를 저장하고 각각의 페이지를 기반으로 클라이언트에서 (react-router를 이용하는 등) 별도의 라우팅 설정 없이 간단하게 라우팅을 제공한다고 이해하면 된다. 즉, 파일만 만들어도 자동으로 라우팅된다!&lt;/p&gt;
&lt;p&gt;다음으로 넘어가서, &apos;Webpack-based dev environment which supports [Hot Module Replacement(HMR)&apos;을 이해해보자. HMR을 지원하는 웹팩 기반의 개발 환경을 제공한다는 의미로 해석할 수 있을 것이다. 하지만 HMR에 대한 기본적인 이해가 없다면 이 문장이 가지는 진정한 의미를 파악하기는 어려울 것이다. 그래서 이번에는 HMR에 대해 살펴보도록 하자.&lt;/p&gt;
&lt;h3&gt;HMR(Hot Module Replacement)&lt;/h3&gt;
&lt;p&gt;우선 HMR을 이해하기 위해서는 Webpack을 이해해야 한다. 일반적으로 Webpack은 JS 애플리케이션을 위한 정적 모듈 번들러이다. 백 엔드에서는 OS가 별도의 모듈 시스템을 제공하지만, 프론트 엔드 환경에서는 별도의 모듈 시스템이 없기 때문에 Webpack을 통해 모든 assets(HTML, CSS, JS, 이미지, … 등)을 하나 이상의 번들(bundle.js) 파일로 통합하고, 그 과정에서 Webpack은 import나 require를 이용해 프로젝트의 의존성 관리를 하기도 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.js.org/concepts/&quot;&gt;Webpack Concepts&lt;/a&gt;에 따르면, Webpack은 다음과 같은 Core Concepts(핵심 개념)을 가지고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#entry&quot;&gt;Entry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#output&quot;&gt;Output&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#loaders&quot;&gt;Loaders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#plugins&quot;&gt;Plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#mode&quot;&gt;Mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/#browser-compatibility&quot;&gt;Browser Compatibility&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 Webpack을 다룰 일이 거의 없고, 지금 당장 필요하지 않기 때문에 여기서는 짧게 설명하고, 다음에 기회가 되면 다른 글을 통해 살펴보도록 하자. 우선 &lt;strong&gt;Entry&lt;/strong&gt;는 Webpack이 번들링을 위해 애플리케이션을 읽어들일 첫 번째 시작점을 의미한다. 다음으로 &lt;strong&gt;OutPut&lt;/strong&gt;은 번들링이 끝난 후 결과물을 저장할 경로와 파일 이름에 대한 설정을 의미하고, &lt;strong&gt;Loaders&lt;/strong&gt;는 정적 파일을 번들링하기 위한 Webpack의 다양한 로더에 대한 설정을 입력할 수 있다. 다음으로 &lt;strong&gt;Plugins&lt;/strong&gt;는 Webpack의 확장 기능을 의미한다. 즉, 원하는 &lt;a href=&quot;https://webpack.js.org/plugins/&quot;&gt;Plugin&lt;/a&gt;을 추가하면 해당 Plugin을 사용할 수 있다. &lt;strong&gt;Mode&lt;/strong&gt;는 production, development, none으로 설정 가능하며, 각각 의미 그대로 프로젝트의 배포 상태를 의미한다. 마지막으로 &lt;strong&gt;Browser Compatibility&lt;/strong&gt;는 Webpack이 ES5와 호환되는 모든 브라우저를 지원한다는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;핵심 개념을 살펴보았지만, 우리가 원한 HMR에 대한 설명은 어디에서도 찾을 수 없었다. 그래서 나는 Webpack에서 제공하는 &lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Hot Module Replacement&lt;/a&gt;를 살펴봐야 했고, 그제서야 HMR을 이해할 수 있었다.&lt;/p&gt;
&lt;p&gt;HMR은 &apos;(뜨거울 정도로)빠른 모듈 교체&apos;라고 이해해도 좋을 것이다. 왜냐하면 HMR은 애플리케이션이 동작하는 동안 모듈을 더하고, 지우는 작업을 풀 리로드하지 않고 진행한다. 이렇게 하면 다음과 같은 몇 가지 방법으로 개발 속도를 높일 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Retain application state which is lost during a full reload.&lt;/li&gt;
&lt;li&gt;Save valuable development time by only updating what&apos;s changed.&lt;/li&gt;
&lt;li&gt;Modifications made to CSS/JS in the source code results in an instant browser update which is almost comparable to changing styles directly in the browser&apos;s dev tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 한글로 번역하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;풀 리로드되는 동안 손실되는 애플리케이션 상태를 유지한다.&lt;/li&gt;
&lt;li&gt;변경된 내용만 업데이트하여 개발 시간을 절약한다.&lt;/li&gt;
&lt;li&gt;소스 코드에서 CSS/JS를 수정하면, 브라우저의 개발(dev) 도구에서 직접 스타일을 변경하는 것과 거의 유사한 브라우저 업데이트가 이루어진다. (즉, 코드의 변경과 함께 브라우저의 스타일이 실시간으로 변경된다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, HMR을 통해 개발 속도를 향상시킬 수 있는 것이다. 이로써 HMR을 왜, 언제 사용해야 하는지도 알았다. 이제 다음 문장인 &apos;Able to implement with Express or any other Node.js HTTP server&apos;에 대해서 살펴볼 수 있겠다. 이는 간단하게 &apos;Express 혹은 다른 Node.js HTTP 서버의 지원이 가능하다&apos;는 의미이다. 즉, NextJS는 Express나 NginX 등 어떤 Node.js HTTP 서버 환경에서든 동작한다고 이해하고 넘어가도록 하자.&lt;/p&gt;
&lt;p&gt;마지막으로 &apos;Customizable with your own Babel and Webpack configurations&apos;은 NextJS가 바벨과 웹펙 설정으로 NextJS의 설정을 사용자 임의대로 변경할 수 있다고 이해하면 될 것이다. 이에 대해서는 직접적으로 사용해보지 않았기 때문에 확실하게 이해했다고 보기는 어렵지만, 지금은 그렇게 깊은 단계까지 이해할 필요는 없다고 생각하고 넘어가도록 하자.&lt;/p&gt;
&lt;p&gt;여기까지 NextJS를 사용하기 위한 사전 준비가 끝났다. 이제 우리는 NextJS를 왜, 언제, 어떻게 사용하면 좋을지를 이론적으로 이해할 수 있었다. 이제부터는 이론적인 내용은 차치하고, 실습 위주로 문서를 작성해보도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - JS study_01 ES3(스코프, 호이스팅)]]></title><description><![CDATA[<h1>WePlanet Intern - study - ES3(스코프, 호이스팅)</h1>
<h2>이번 스터디 목표</h2>
<p><strong>JS 문법 학습</strong>: 구현만 가능하다고 적재적소에 원하는 코드를 삽입할 수는 없을 것이라는 생각이 있었기 때문에, 이를 해결하기 위해서 JS의 문법을 다시 한 번 학습하고자 하는 필요성을 느꼈다. 하지만 아주 기본적인 단계를 다시 학습하는 건 불필요하다는 생각이 있기 때문에 기본 문법 및 매커니즘 등의 이해는 건너뛴다.</p>
<ol>
<li>
<p>ES3(ES1999): 기본적인 문법을 제외한 함수 단위의 스코프, 호이스팅, 클로저, 프로토타입 등</p>
<ul>
<li><a href="http://www.incodom.kr/ECMAScript_5_%EC%A0%95%EC%9D%98#h_a4098c75da114a2ee7591548f11e4a10">참고자료1 - ES3 vs ES5</a></li>
<li><a href="http://www.nextree.co.kr/p7363/">참고자료2 - Scope 이해</a></li>
</ul>
</li>
<li>
<p>ES5(ES2009): forEach, map, reduce, filter, some, every와 같은 순환 메소드, 객체의 프로퍼티 설정(생성, 수정, 복사하는 표준 메소드&#x3C;Object.Create(), Object.defineProperty(), Object.freeze(), Object.assign()> 등과 getter, setter, Object.key() 메소드), strict 모드(use strict), bind() 메소드 등</p>
<ul>
<li><a href="http://www.incodom.kr/ECMAScript_5_%EC%A0%95%EC%9D%98#h_a4098c75da114a2ee7591548f11e4a10">참고자료1 - ES3 vs ES5</a></li>
</ul>
</li>
<li>
<p>ES6(ES2015): 호이스팅이 사라진 것 같은 효과, 함수 단위 스코프에서 블록 단위 스코프로 변경됨, this를 동적으로 바인딩하지 않는 화살표 함수, 모듈화 지원, 콜백 지옥에서 구원해줄 Promise, Default와 Rest 파라미터, 해체 할당, Spread 연산자, 템플릿 리터럴, 클래스, 기타 여러 사항(브라우저에서 지원하지 않는 문법 등을 처리하는 트랜스파일러(Babel)과 모듈화를 사용하기 위한 모듈 번들러(WebPack)의 등장, Nodejs의 부상 JS 진영의 생태계 진화에 따라 만들어진 문법) 등</p>
</li>
<li>
<p>ES7(ES2016): 제곱 연산자(**), Array.includes 배열에 해당 요소가 존재하는지 확인하는 메소드</p>
</li>
<li>
<p>ES8(ES2017): async와 await, 객체의 심화된 메소드(Object.entries(), Object.getOwnPropertDescriptors()(Object.getOwnPropertyDescriptor의 복수 형태), 문자열(편의 기능 추가 -> 문자열 앞부분에 공백을 넣어 자리수를 맞추는 String.padStart(), 문자열 뒷부분에 공백을 넣어 자리를 맞추는 String.padEnd()), 매개변수 마지막에 콤마를 붙이는 걸 허용</p>
</li>
<li>
<p>ES9(ES2018): 구조 분해 할당(Spread)(… 키워드), Promise finally(then과 catch 외에도 finally가 추가되었다. 성공, 실패 여부와 상관없이 무조건 실행되는 메서드), Async iteration(async 문법을 생성기랑 for of 문에서도 사용 가능해졌다.), 정규표현식의 강화(lookbehind가 생기고 캡쳐링 그룹에 이름을 지정해 줄 수 있다.)</p>
</li>
</ol>
<p>나는 자바스크립트로 개발을 해왔지만 아직도 ES3조차 익숙하지 않다. 이 스터디는 본격적으로 JS로 개발한지 6개월이 되지 않았다는 점을 빌미로 그동안 미뤄왔던 주제이지만, 이번 기회에 ES3부터 ES9까지의 문법을 학습 및 정리하고, 이를 치트시트의 형태로 사용하면 좋을 것이라고 생각해 결심을 하게 됐다.</p>
<p>추가적으로 각 문법의 특성에 맞게 서술하려고 했기 때문에, 현재에는 다른 방식으로 쓰이는 문법 혹은 더이상 쓰이지 않는 문법들에 대한 해설이 불편할 수 있다. 그래서 이는 시대적 흐름에 맞춰 결론에 이르러서는 어떤 문법을 써야 하고, 쓰지 말아야 하는지를 알게 하기 위함이기 때문에 모든 것을 아는 사람이 읽기에는 다소 불편할 수 있음을 미리 경고한다.</p>
<h2>ES3(ES1999)</h2>
<p>우선 ES3는 우리가 흔히 알고있는 JS(이하 JS는 ES3의 문법을 나타냄)라고 이해하면 쉽다. 그렇기 때문에 가장 기본적이라고 할 수 있으며, 그만큼 많은 이들이 사용하고 있다. 물론 필자처럼 사용한다고 아는 것은 아니기 때문에 이번 기회에 같이 학습해보도록 하자.</p>
<h3>함수단위 스코프(Scope)</h3>
<p>Scope은 '유효범위'(이하 스코프)라고 해석할 수 있다. 유효범위는 JS뿐만 아니라 모든 프로그래밍 언어의 가장 기본적인 개념의 하나로 반드시 이해해야 하는 개념이다. 더불어 JS의 유효범위는 조금 특별하다. 이것은 언어적인 특성과 더불어 JS를 JS답게 사용할 수 있도록 하는 중요한 요소이기 때문에 각자 자신이 자신있는 언어와 비교하며 살펴보도록 하자.</p>
<p>일반적인 프로그래밍 언어에서의 스코프는 참조의 범위를 나타낸다. 즉, 변수와 매개변수(parameters)의 접근성과 생존기간을 의미한다. 따라서 스코프를 통해 변수와 매개변수의 접근성과 생존기간을 제어할 수도 있다. 그리고, 일반적인 언어에서의 유효범위는 크게 '<strong>전역 유효범위(global scope)</strong>'와 '<strong>지역 유효범위(local scope)</strong>'의 2가지로 나눌 수 있다.</p>
<p>이 두 가지는 각각 다음과 같은 의미를 지닌다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">전역 유효범위: 스크립트의 스코프 가장 바깥쪽에서 정의하며, 스크립트 내 어느 곳에서든 참조될 수 있다.
지역 유효범위: 하나의 메서드 안에서 정의하며, 정의된 메서드 안에서만 참조될 수 있다.</code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> global_scope<span class="token operator">=</span><span class="token string">"global"</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span>a_scope_param<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> local_scope_a <span class="token operator">=</span> <span class="token string">"local_a"</span>
    
    <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> local_scope_b <span class="token operator">=</span> <span class="token string">"local_b"</span>
        <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> local_scope_c <span class="token operator">=</span> <span class="token string">"local_c"</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local_scope_a<span class="token punctuation">)</span> <span class="token comment">// false</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local_scope_b<span class="token punctuation">)</span> <span class="token comment">// false</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local_scope_c<span class="token punctuation">)</span> <span class="token comment">// true -> local_c 출력</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global_scope<span class="token punctuation">)</span> <span class="token comment">// true -> global 출력</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>1. JS 스코프만의 특징</h3>
<p>앞선 개념은 JS를 제외한 대부분의 프로그래밍 언어에서 갖는 스코프의 형태이다. 더불어 JS(ES3)의 스코프는 다음과 같은 추가적인 이해가 필요하다.</p>
<ul>
<li>함수 단위의 유효범위</li>
<li>변수명의 중복 허용</li>
<li>var 키워드의 생략</li>
<li>렉시컬 특성</li>
</ul>
<p>이제부터 천천히 위의 특성들을 살펴보도록 하자.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 함수 단위의 유효범위</span>
<span class="token keyword">function</span> <span class="token function">scopeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"c="</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"c="</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"b="</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">scopeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">/* 실행결과
c = 0  
c = 1  
c = 2  
c = 3  
c = 4  
c = 5  
b = 0  
*/</span></code></pre></div>
<p>위 코드에서는 JS의 유효범위가 블록 단위가 아닌 함수 단위로 정의된다는 것을 보여주기 위한 코드이다. 다른 프로그래밍 언어들은 유효범위의 단위가 블록 단위이기 대문에 위의 코드와 같은 if문, for문 등 구문들이 사용되었을 때 중괄호 밖의 범위에서는 그 안의 변수를 사용할 수 없다.</p>
<p>하지만, JS의 유효 범위는 함수 단위이기 때문에 예제코드의 변수 a, b, c 모두 같은 유효범위를 갖는다. 그 결과 실행화면처럼 모든 변수가 정상적으로 출력되는 것을 알 수 있다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 변수 명 중복</span>
<span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">scopeExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"scope = "</span> <span class="token operator">+</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">scopeExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">/* 실행결과
scope =20  
*/</span></code></pre></div>
<p>JS는 다른 프로그래밍 언어와는 달리 변수명이 중복되어도 에러를 발생하지 않는다. 단, 중복된 변수명을 참조할 때는 가장 가까운 범위의 변수를 참조하도록 한다. 그래서 위의 코드처럼 scope를 호출했을 때, 전역 변수가 아닌 가까이에 있는 지역 변수를 참조한 것이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// var 키워드 생략</span>
<span class="token keyword">function</span> <span class="token function">scopeExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    scope <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"scope = "</span> <span class="token operator">+</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">scopeExam2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"scope = "</span> <span class="token operator">+</span> scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">scopeExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">scopeExam2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">/* 실행결과
scope=20  
scope=20  
*/</span></code></pre></div>
<p>대부분의 컴파일 언어의 경우에는 변수를 선언할 때 int나 char과 같이 타입을 명시적으로 선언해줘야 한다. 하지만 JS는 컴파일링을 거치지 않는 스크립트 언어이기 때문에  모든 변수가 명시적으로 선언되지 않더라도 인터프리터를 거친 후에 값에 따라 자동적으로 변수의 타입이 정해진다. 그래서 변수의 자료형이 하나(var)로 통일될 수 있는 것이고, 이는 '생략'해도 무관하다는 것과 동일한 의미를 지닌다. </p>
<p>그래서 위와 같이 'var' 키워드를 생략하더라도 정상적으로 동작할 수 있는 것이다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 렉시컬 특성 Code1</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> a<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"호출 실행"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 실행결과
호출실행
*/</span></code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 렉시컬 특성 Code2</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> a<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 실행결과
Uncaught Reference Error  
: a is not defined
*/</span></code></pre></div>
<p>렉시컬 특성이란 함수 실행 시 유효범위를 함수 실행 환경이 아닌 함수 정의 환경으로 참조하는 특성을 말한다. Code1의 경우에는 f1에서 f2를 호출하면 정상적으로 실행된다. 이는 f1과 f2 모두 전역에서 생성된 함수이기 때문에 서로를 참조할 수 있는 것이다.</p>
<p>하지만 Code2처럼 함수 f1안에서 f2를 호출했다고 해서 f2가 f1안에 들어온 것처럼 f1의 내부 변수 a를 참조할 수 없다. 이는 렉시컬 특성으로 인해 f2가 실행될 때가 아닌 정의 될 대의 환경을 보고 a라는 변수를 참조하기 때문에 찾을 수 없는 것이다.</p>
<p>다음으로는 또다른 ES3의 특성 중 하나인 호이스팅(Hoisting)을 살펴보도록 하자.</p>
<h3>호이스팅(Hoisting)</h3>
<p>직역하면 '끌어올리기' 혹은 '들어 올려 나르기'라고 부를 수 있다. JS에서의 호이스팅도 이와 유사한 의미를 가지고 있다. 간단히 JS의 호이스팅은 변수 선언문을 끌어올린다는 뜻으로 이해하면 된다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 호이스팅 Code1</span>
<span class="token keyword">function</span> <span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 실행결과
value= undefined  
value= 10  
*/</span></code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 호이스팅 Code2</span>
<span class="token keyword">function</span> <span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> value<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    value <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">/* 실행결과
value= undefined  
value= 10  
*/</span></code></pre></div>
<p>위 두 예제를 통해 호이스팅을 간단하게 이해해보도록 하자. Code1을 보면 hoistingExam 안에서 변수 value의 호출이 2번 일어난다. 한 번은 변수 선언문 전에, 또 한 번은 변수 선언 후에 호출되는데, 다른 프로그래밍 언어의 경우에는 선언문 전에 호출됐을 때 에러가 발생하지만, Js의 경우에는 호이스팅을 통해 Code2와 같은 의미로 구동된다. 즉, 변수 선언문이 유효범위 안의 제일 상단부로 끌어올려지게 되고, 선언문이 있던 자리에서 초기화가 이루어지는 결과를 갖는 것이다. 이때 선언에서는 따로 값을 정해주지 않았기 때문에 undefined가 출력된다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> value<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">var</span> value <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"value="</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">/* 실행결과
value= undefined  
value= 10  
*/</span></code></pre></div>
<p>그렇다면 위 코드에서는 어떤 결과가 나타날까? 다른 프로그래밍 언어에 익숙하다면 첫 번째 호출에서는 전역 변수의 값인 '30'이, 두 번째 호출에서는 지역 변수의 값인 '10'이 들어간다고 생각할 수 있다. 하지만 이 경우에는 JS의 호이스팅으로 인해서 선언 부가 함수 hoistingExam의 최 상단에서 끌어올려 짐으로써 전역변수가 아닌 지역변수를 참조하게 되는 것이다.</p>
<p>다음으로는 함수의 호이스팅을 살펴보도록 하자. 이때는 여러 가지의 함수 정의 방법 중 '오직 함수 선언문 방식만 호이스팅이 가능하다'라는 점을 기억하도록 하자. 다음을 살펴보자.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 함수 호이스팅 - 함수 선언문</span>
<span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">hoistingExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> hoisting_val <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hoisting_val ="</span><span class="token operator">+</span>hoisting_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 실행결과
hoisting_val =10  
*/</span></code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 함수 호이스팅 - 함수 표현식</span>
<span class="token function">hoistingExam2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">var</span> <span class="token function-variable function">hoistingExam2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> hoisting_val <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hoisting_val ="</span><span class="token operator">+</span>hoisting_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 실행결과
hoistingExam2 of object is not a function  
*/</span></code></pre></div>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// 함수 호이스팅 - Function 생성자</span>
<span class="token function">hoistingExam3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">var</span> hoistingExam3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"return console.log('Ya-ho!!');"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">/* 실행결과
hoistingExam3 of object is not a function  
*/</span></code></pre></div>
<p>오직 함수 선언문 방식만 호이스팅이 되고 함수 표현식과 function 생성자 방식은 호이스팅되지 않는다. 그 이유는 함수 표현식과 Function 생성자를 통한 함수 정의 방법은 변수에 함수를 초기화시키기 때문에 선언문이 호이스팅되어 상단으로 올려진다 하더라도 함수가 아닌 변수로써 인지하기 때문이다.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-05-weplanet_study_es3_01</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-05-weplanet_study_es3_01</guid><pubDate>Tue, 05 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;WePlanet Intern - study - ES3(스코프, 호이스팅)&lt;/h1&gt;
&lt;h2&gt;이번 스터디 목표&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JS 문법 학습&lt;/strong&gt;: 구현만 가능하다고 적재적소에 원하는 코드를 삽입할 수는 없을 것이라는 생각이 있었기 때문에, 이를 해결하기 위해서 JS의 문법을 다시 한 번 학습하고자 하는 필요성을 느꼈다. 하지만 아주 기본적인 단계를 다시 학습하는 건 불필요하다는 생각이 있기 때문에 기본 문법 및 매커니즘 등의 이해는 건너뛴다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ES3(ES1999): 기본적인 문법을 제외한 함수 단위의 스코프, 호이스팅, 클로저, 프로토타입 등&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.incodom.kr/ECMAScript_5_%EC%A0%95%EC%9D%98#h_a4098c75da114a2ee7591548f11e4a10&quot;&gt;참고자료1 - ES3 vs ES5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nextree.co.kr/p7363/&quot;&gt;참고자료2 - Scope 이해&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES5(ES2009): forEach, map, reduce, filter, some, every와 같은 순환 메소드, 객체의 프로퍼티 설정(생성, 수정, 복사하는 표준 메소드&amp;#x3C;Object.Create(), Object.defineProperty(), Object.freeze(), Object.assign()&gt; 등과 getter, setter, Object.key() 메소드), strict 모드(use strict), bind() 메소드 등&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.incodom.kr/ECMAScript_5_%EC%A0%95%EC%9D%98#h_a4098c75da114a2ee7591548f11e4a10&quot;&gt;참고자료1 - ES3 vs ES5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES6(ES2015): 호이스팅이 사라진 것 같은 효과, 함수 단위 스코프에서 블록 단위 스코프로 변경됨, this를 동적으로 바인딩하지 않는 화살표 함수, 모듈화 지원, 콜백 지옥에서 구원해줄 Promise, Default와 Rest 파라미터, 해체 할당, Spread 연산자, 템플릿 리터럴, 클래스, 기타 여러 사항(브라우저에서 지원하지 않는 문법 등을 처리하는 트랜스파일러(Babel)과 모듈화를 사용하기 위한 모듈 번들러(WebPack)의 등장, Nodejs의 부상 JS 진영의 생태계 진화에 따라 만들어진 문법) 등&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES7(ES2016): 제곱 연산자(**), Array.includes 배열에 해당 요소가 존재하는지 확인하는 메소드&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES8(ES2017): async와 await, 객체의 심화된 메소드(Object.entries(), Object.getOwnPropertDescriptors()(Object.getOwnPropertyDescriptor의 복수 형태), 문자열(편의 기능 추가 -&gt; 문자열 앞부분에 공백을 넣어 자리수를 맞추는 String.padStart(), 문자열 뒷부분에 공백을 넣어 자리를 맞추는 String.padEnd()), 매개변수 마지막에 콤마를 붙이는 걸 허용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES9(ES2018): 구조 분해 할당(Spread)(… 키워드), Promise finally(then과 catch 외에도 finally가 추가되었다. 성공, 실패 여부와 상관없이 무조건 실행되는 메서드), Async iteration(async 문법을 생성기랑 for of 문에서도 사용 가능해졌다.), 정규표현식의 강화(lookbehind가 생기고 캡쳐링 그룹에 이름을 지정해 줄 수 있다.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나는 자바스크립트로 개발을 해왔지만 아직도 ES3조차 익숙하지 않다. 이 스터디는 본격적으로 JS로 개발한지 6개월이 되지 않았다는 점을 빌미로 그동안 미뤄왔던 주제이지만, 이번 기회에 ES3부터 ES9까지의 문법을 학습 및 정리하고, 이를 치트시트의 형태로 사용하면 좋을 것이라고 생각해 결심을 하게 됐다.&lt;/p&gt;
&lt;p&gt;추가적으로 각 문법의 특성에 맞게 서술하려고 했기 때문에, 현재에는 다른 방식으로 쓰이는 문법 혹은 더이상 쓰이지 않는 문법들에 대한 해설이 불편할 수 있다. 그래서 이는 시대적 흐름에 맞춰 결론에 이르러서는 어떤 문법을 써야 하고, 쓰지 말아야 하는지를 알게 하기 위함이기 때문에 모든 것을 아는 사람이 읽기에는 다소 불편할 수 있음을 미리 경고한다.&lt;/p&gt;
&lt;h2&gt;ES3(ES1999)&lt;/h2&gt;
&lt;p&gt;우선 ES3는 우리가 흔히 알고있는 JS(이하 JS는 ES3의 문법을 나타냄)라고 이해하면 쉽다. 그렇기 때문에 가장 기본적이라고 할 수 있으며, 그만큼 많은 이들이 사용하고 있다. 물론 필자처럼 사용한다고 아는 것은 아니기 때문에 이번 기회에 같이 학습해보도록 하자.&lt;/p&gt;
&lt;h3&gt;함수단위 스코프(Scope)&lt;/h3&gt;
&lt;p&gt;Scope은 &apos;유효범위&apos;(이하 스코프)라고 해석할 수 있다. 유효범위는 JS뿐만 아니라 모든 프로그래밍 언어의 가장 기본적인 개념의 하나로 반드시 이해해야 하는 개념이다. 더불어 JS의 유효범위는 조금 특별하다. 이것은 언어적인 특성과 더불어 JS를 JS답게 사용할 수 있도록 하는 중요한 요소이기 때문에 각자 자신이 자신있는 언어와 비교하며 살펴보도록 하자.&lt;/p&gt;
&lt;p&gt;일반적인 프로그래밍 언어에서의 스코프는 참조의 범위를 나타낸다. 즉, 변수와 매개변수(parameters)의 접근성과 생존기간을 의미한다. 따라서 스코프를 통해 변수와 매개변수의 접근성과 생존기간을 제어할 수도 있다. 그리고, 일반적인 언어에서의 유효범위는 크게 &apos;&lt;strong&gt;전역 유효범위(global scope)&lt;/strong&gt;&apos;와 &apos;&lt;strong&gt;지역 유효범위(local scope)&lt;/strong&gt;&apos;의 2가지로 나눌 수 있다.&lt;/p&gt;
&lt;p&gt;이 두 가지는 각각 다음과 같은 의미를 지닌다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;전역 유효범위: 스크립트의 스코프 가장 바깥쪽에서 정의하며, 스크립트 내 어느 곳에서든 참조될 수 있다.
지역 유효범위: 하나의 메서드 안에서 정의하며, 정의된 메서드 안에서만 참조될 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; global_scope&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;global&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a_scope_param&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; local_scope_a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;local_a&quot;&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; local_scope_b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;local_b&quot;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; local_scope_c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;local_c&quot;&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;local_scope_a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;local_scope_b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;local_scope_c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true -&gt; local_c 출력&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;global_scope&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true -&gt; global 출력&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1. JS 스코프만의 특징&lt;/h3&gt;
&lt;p&gt;앞선 개념은 JS를 제외한 대부분의 프로그래밍 언어에서 갖는 스코프의 형태이다. 더불어 JS(ES3)의 스코프는 다음과 같은 추가적인 이해가 필요하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 단위의 유효범위&lt;/li&gt;
&lt;li&gt;변수명의 중복 허용&lt;/li&gt;
&lt;li&gt;var 키워드의 생략&lt;/li&gt;
&lt;li&gt;렉시컬 특성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제부터 천천히 위의 특성들을 살펴보도록 하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 함수 단위의 유효범위&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scopeTest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c=&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
         console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c=&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b=&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;scopeTest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
c = 0  
c = 1  
c = 2  
c = 3  
c = 4  
c = 5  
b = 0  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서는 JS의 유효범위가 블록 단위가 아닌 함수 단위로 정의된다는 것을 보여주기 위한 코드이다. 다른 프로그래밍 언어들은 유효범위의 단위가 블록 단위이기 대문에 위의 코드와 같은 if문, for문 등 구문들이 사용되었을 때 중괄호 밖의 범위에서는 그 안의 변수를 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;하지만, JS의 유효 범위는 함수 단위이기 때문에 예제코드의 변수 a, b, c 모두 같은 유효범위를 갖는다. 그 결과 실행화면처럼 모든 변수가 정상적으로 출력되는 것을 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 변수 명 중복&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; scope &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scopeExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; scope &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;scope = &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;scope&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;scopeExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
scope =20  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS는 다른 프로그래밍 언어와는 달리 변수명이 중복되어도 에러를 발생하지 않는다. 단, 중복된 변수명을 참조할 때는 가장 가까운 범위의 변수를 참조하도록 한다. 그래서 위의 코드처럼 scope를 호출했을 때, 전역 변수가 아닌 가까이에 있는 지역 변수를 참조한 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// var 키워드 생략&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scopeExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    scope &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;scope = &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;scope&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scopeExam2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;scope = &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; scope&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;scopeExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token function&quot;&gt;scopeExam2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
scope=20  
scope=20  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분의 컴파일 언어의 경우에는 변수를 선언할 때 int나 char과 같이 타입을 명시적으로 선언해줘야 한다. 하지만 JS는 컴파일링을 거치지 않는 스크립트 언어이기 때문에  모든 변수가 명시적으로 선언되지 않더라도 인터프리터를 거친 후에 값에 따라 자동적으로 변수의 타입이 정해진다. 그래서 변수의 자료형이 하나(var)로 통일될 수 있는 것이고, 이는 &apos;생략&apos;해도 무관하다는 것과 동일한 의미를 지닌다. &lt;/p&gt;
&lt;p&gt;그래서 위와 같이 &apos;var&apos; 키워드를 생략하더라도 정상적으로 동작할 수 있는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 렉시컬 특성 Code1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;호출 실행&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
호출실행
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 렉시컬 특성 Code2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
Uncaught Reference Error  
: a is not defined
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;렉시컬 특성이란 함수 실행 시 유효범위를 함수 실행 환경이 아닌 함수 정의 환경으로 참조하는 특성을 말한다. Code1의 경우에는 f1에서 f2를 호출하면 정상적으로 실행된다. 이는 f1과 f2 모두 전역에서 생성된 함수이기 때문에 서로를 참조할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;하지만 Code2처럼 함수 f1안에서 f2를 호출했다고 해서 f2가 f1안에 들어온 것처럼 f1의 내부 변수 a를 참조할 수 없다. 이는 렉시컬 특성으로 인해 f2가 실행될 때가 아닌 정의 될 대의 환경을 보고 a라는 변수를 참조하기 때문에 찾을 수 없는 것이다.&lt;/p&gt;
&lt;p&gt;다음으로는 또다른 ES3의 특성 중 하나인 호이스팅(Hoisting)을 살펴보도록 하자.&lt;/p&gt;
&lt;h3&gt;호이스팅(Hoisting)&lt;/h3&gt;
&lt;p&gt;직역하면 &apos;끌어올리기&apos; 혹은 &apos;들어 올려 나르기&apos;라고 부를 수 있다. JS에서의 호이스팅도 이와 유사한 의미를 가지고 있다. 간단히 JS의 호이스팅은 변수 선언문을 끌어올린다는 뜻으로 이해하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 호이스팅 Code1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
value= undefined  
value= 10  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 호이스팅 Code2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
value= undefined  
value= 10  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 두 예제를 통해 호이스팅을 간단하게 이해해보도록 하자. Code1을 보면 hoistingExam 안에서 변수 value의 호출이 2번 일어난다. 한 번은 변수 선언문 전에, 또 한 번은 변수 선언 후에 호출되는데, 다른 프로그래밍 언어의 경우에는 선언문 전에 호출됐을 때 에러가 발생하지만, Js의 경우에는 호이스팅을 통해 Code2와 같은 의미로 구동된다. 즉, 변수 선언문이 유효범위 안의 제일 상단부로 끌어올려지게 되고, 선언문이 있던 자리에서 초기화가 이루어지는 결과를 갖는 것이다. 이때 선언에서는 따로 값을 정해주지 않았기 때문에 undefined가 출력된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;value=&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
value= undefined  
value= 10  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그렇다면 위 코드에서는 어떤 결과가 나타날까? 다른 프로그래밍 언어에 익숙하다면 첫 번째 호출에서는 전역 변수의 값인 &apos;30&apos;이, 두 번째 호출에서는 지역 변수의 값인 &apos;10&apos;이 들어간다고 생각할 수 있다. 하지만 이 경우에는 JS의 호이스팅으로 인해서 선언 부가 함수 hoistingExam의 최 상단에서 끌어올려 짐으로써 전역변수가 아닌 지역변수를 참조하게 되는 것이다.&lt;/p&gt;
&lt;p&gt;다음으로는 함수의 호이스팅을 살펴보도록 하자. 이때는 여러 가지의 함수 정의 방법 중 &apos;오직 함수 선언문 방식만 호이스팅이 가능하다&apos;라는 점을 기억하도록 하자. 다음을 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 함수 호이스팅 - 함수 선언문&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hoistingExam&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; hoisting_val &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hoisting_val =&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;hoisting_val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
hoisting_val =10  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 함수 호이스팅 - 함수 표현식&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;hoistingExam2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; hoisting_val &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hoisting_val =&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;hoisting_val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
hoistingExam2 of object is not a function  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 함수 호이스팅 - Function 생성자&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;hoistingExam3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; hoistingExam3 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;return console.log(&apos;Ya-ho!!&apos;);&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token comment&quot;&gt;/* 실행결과
hoistingExam3 of object is not a function  
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;오직 함수 선언문 방식만 호이스팅이 되고 함수 표현식과 function 생성자 방식은 호이스팅되지 않는다. 그 이유는 함수 표현식과 Function 생성자를 통한 함수 정의 방법은 변수에 함수를 초기화시키기 때문에 선언문이 호이스팅되어 상단으로 올려진다 하더라도 함수가 아닌 변수로써 인지하기 때문이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WePlanet Intern - project NextJS_01]]></title><description><![CDATA[<h1>Next 입문하기</h1>
<p>우선 나는 이 글을 쓰기 전에 <a href="https://nextjs.org/">NextJS</a>에서 제공하는 Quick Start를 따라 간단한 <a href="https://github.com/rayleighko/react-nextjs">예제</a>를 구현한 경험이 있다. 하지만, NextJS를 사용하는 법은 알았지만, 억지로 쓰자면 쓸 수 있었지만 왜 써야하고 무엇을 위해 존재하는지를 알지 못했기 때문에 이번 기회를 통해 제대로 NextJS를 이해하고 입문하고자 했다.</p>
<p>더불어 지금 내가 보고있는 코드가 NextJS를 기반으로 이루어진 코드이기 때문에 이를 이해하기 위해서는 필수불가결하게 NextJS를 이해해야만 했다.</p>
<p><a href="https://velopert.com/3293">참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기</a></p>
<p><a href="https://jaroinside.tistory.com/24">참고자료 2 - 11. 서버 사이드 렌더링, 클라이언트 사이드 렌더링</a></p>
<p><a href="https://nextjs.org/learn/basics/getting-started">참고자료 3 - NextJS Getting Started</a></p>
<h2>왜 NextJS인가?</h2>
<p>우선적으로 무언가가 존재하는 이유를 알기 위해서는 그 기술이 왜 만들어졌는지를 이해하면 학습에 큰 도움이 될 것이다. 그렇다면 Next.JS는 왜 만들어진 걸까?</p>
<p>가장 큰 이유는 리액트에서 SSR(Server Side Rendering)을 하기 위함이라고 할 수 있을 것이다. 리액트에서의 SSR이라는 것을 이해하기 위해서는 기존 웹페이지에서 렌더링하던 방식을 알아야 한다. 우리는 먼저 웹페이지를 구동하는 방식에 대한 이해부터 시작하자.</p>
<p>우선적으로 웹페이지가 존재하기 위해서는 어떠한 웹 페이지에 접속할 때, 그 페이지를 사용자 화면에 그려주기 위해 렌더링이라는 작업이 필요하다. 그래서 웹페이지를 구동하는 방식은 "언제, 어떻게 렌더링을 할 것인가?"에 대한 답이기도 하다.</p>
<h3>전통적인 웹페이지 구동 방식</h3>
<p>요청 시마다 새로고침과 함께 서버에 새로운 페이지에 대한 요청을 하는 방식이다. 이때 View가 어떻게 보여질지 또한 서버에서 해석하여 보내주기 때문에 이를 '서버 사이드 렌더링'이라고 이야기한다. 더불어 이는 물건을 쟁여두지않고 필요할 때마다 사러가는 것과 같은 맥락이다. </p>
<p>하지만 기술의 발전으로 웹에서 제공하는 정보량이 많아지고, 이에 따라 여러 문제점이 발견되면서 전통적인 웹페이지 구동 방식과는 다른 SPA(Single Page Application)라는 기법이 등장하게 되었다.</p>
<h3>SPA 구동 방식</h3>
<p>SPA는 이름 그대로 처음에 하나의 빈 페이지만 서버측에 제공하고, View에 대해서는 Client에서 JS를 통해 렌더링하는 방식을 택했다. 이를 CSR(Client Side Rendering), 혹은 '클라이언트 사이드 렌더링'이라고 이야기한다. CSR은 물건을 사러 갈 알바를 고용하고 필요할 때마다 물건을 배송받는 것과 같다.</p>
<p>SSR과 CSR을 비교하여 설명하는 것은 처음에는 이해가 안될 수도 있지만, 간단히 View를 렌더링하는 위치가 서버냐 클라이언트냐에 따라 서버 사이드 혹은 클라이언트 사이드 렌더링이라고 이야기한다는 것을 알고 넘어가도록 하자.</p>
<blockquote>
<p>여기서 주의할 점은 우리가 살펴 볼 SSR과 CSR은 전통적인 웹페이지 구동방식, SPA 구동 방식을 의미하는 것이 아닌 전통적인 웹페이지 구동방식에서는 SSR을 사용하고, SPA 구동 방식에서는 CSR을 사용한다는 것이다.</p>
</blockquote>
<p>그리고 이제부터 SSR과 CSR의 가장 큰 차이인 '초기 View 로딩 속도', 'SEO'에 대해 살펴보고 보다 확실하게 NextJS를 사용해보도록 하자.</p>
<h3>SSR과 CSR의 차이</h3>
<p>먼저 SSR과 CSR의 가장 큰 차이 중 하나인 '초기 View 로딩 속도'를 비교해보도록 하자.</p>
<p>SSR의 경우에는 View를 서버에서 렌더링해 가져오기 때문에, 첫 로딩이 매우 짧다. 물론, JS 파일을 모두 다운로드하고 적용하기 전까지는 각각의 기능이 동작하지 않겠지만, 사용자의 입장에서는 매우 빠른 속도로 로딩이 됐다고 생각할 수 있는 것이다.</p>
<p>반면에 CSR은 서버에서 View를 렌더링하지 않고, 먼저 HTML을 다운로드하고, JS 파일이나 서비스에 필요한 리소스를 다운로드한 후 브라우저에서 렌더링 해 보여주기 때문에 SSR보다는 초기 View를 보기까지의 시간이 길다. 하지만, 보여진 기능 모두 보임과 동시에 동작 가능하다.</p>
<p>물론, 이 두 차이점은 개인의 취향 혹은 서비스의 UX에 따라 달라질 것이기 때문에 어떤 것이 옳다고 이야기할 수 없을 것이다. 그렇기 때문에 두 번째 큰 차이점인 SEO 문제에 대해 살펴봐야 어떤 것을 선택할지를 판단할 수 있을 것이다.</p>
<h3>SEO 문제</h3>
<p>SEO는 Search Engine Optimization의 약자로 검색 엔진 최적화를 의미한다. 즉, SEO 문제는 검색 엔진 최적화 문제를 말하고 검색 엔진의 크롤러들이 웹 페이지의 JS를 해석해 노출시키기 때문에 크롤링을 할 수 없는 시점에서는 검색 엔진에 노출시키지 않는 것이고, 이는 노출 횟수가 줄어듦을 의미한다.</p>
<p>따라서 CSR은 View를 생성하기 위해서는 JS가 필요하고, View를 생성하기 전까지는 검색 엔진 크롤러의 데이터 수집이 제한적이기 때문에 상대적으로 SEO가 잘되지 않아 사용자 유입이 적고, SSR은 View를 서버에서 렌더링해 제공하기 때문에 상대적으로 SEO에 유리해져 사용자 유입이 많을 것이다.</p>
<p>정리하면 SSR은 초기 로딩 속도가 빠르고 SEO에 유리하지만, View 변경 시 서버에 계속적으로 요청해야 하므로 서버에 부담이 크다. 그리고 CSR은 초기 로딩 속도가 느리고 SEO에 대한 문제가 있지만, 초기 로딩 후에는 View를 서버에 요청하는 것이 아닌 Client에서 직접 렌더링하기 때문에 매우 빠르다는 장점이 있다.</p>
<p>또한, 최근에는 이 두 가지 방법을 적절하게 융합한 방법들도 나오고 있다. 즉, 첫 번째 페이지 로딩에서는 서버 사이드 렌더링을 사용하고, 그 후에 모든 페이지 로드에는 클라이언트 사이드 렌더링을 활용하는 방안이 그것이다.</p>
<h2>다시 본론으로..</h2>
<p>우리는 NextJS의 탄생 배경을 이해하기 위해 앞선 것처럼 SSR과 CSR을 알아봤다. 그래서 우리는 NextJS를 리액트에서의 SSR을 위한 '도구'라는 것까지 이해했다. 그럼에도 불구하고 다른 도구가 아닌 NextJS를 사용해야만 하는지에 대해서는 이해하지 못했다. 그래서 우선은 NextJS에서 제공하는 <a href="https://nextjs.org/learn/">문서</a>를 살펴보기로 했다.</p>
<p>문서에 따르면, 최근에 각광받는 Single Page(단일) JavaScript applications에 대한 이야기와 이를 구현하는 것에 대한 어려움을 이야기한다. 더불어 아직도 적절한 어플리케이션을 만들기 위해서는 높은 러닝 커브(client-side routing, page layout 등)를 감수해야 하고, 이는 빠른 페이지 로드를 위해 사용하는 SSR을 적용하기 위한 어려움으로 이어질 수 있다고 이야기한다.</p>
<p>그래서 NextJS 팀은 사용자 설정이 가능하지만 간단한 무언가를 원했고, 이것을 PHP의 그것과 같이 라우팅에 대해서 걱정할 필요없으며 기본적으로 응용 프로그램이 서버에 렌더링되게 만들고자 생각했다고 한다. 그래서 탄생한 것이 NextJS이다.</p>
<p>이제 NextJS의 탄생 배경을 어렴풋이 알게 되었다. 그렇다면, 본격적으로 문서를 통해 NextJS로 무엇을 할 수 있을지를 살펴보자. 왜냐면 우리는 NextJS를 '잘' 사용해야 하기 때문이다.</p>
<ul>
<li>Server-rendered by default</li>
<li>Automatic code splitting for faster page loads</li>
<li>Simple client-side routing (page based)</li>
<li>Webpack-based dev environment which supports <a href="https://webpack.js.org/concepts/hot-module-replacement/">Hot Module Replacement</a>(HMR)</li>
<li>Able to implement with Express or any other Node.js HTTP server</li>
<li>Customizable with your own Babel and Webpack configurations</li>
</ul>
<p>위의 내용을 한글로 살펴보면 다음과 같이 이해할 수 있을 것이다.</p>
<ul>
<li>기본적으로 서버 렌더링</li>
<li>보다 빠른 페이지 로드를 위한 자동 코드 스플리팅</li>
<li>간단한 클라이언트 사이드 라우팅(page 기반)</li>
<li><a href="https://webpack.js.org/concepts/hot-module-replacement/">Hot Module Replacement</a>(HMR)을 지원하는 웹팩 기반 개발 환경</li>
<li>익스프레스 혹은 어떤 Node.js HTTP server로 구현이 가능</li>
<li>바벨과 웹펙 설정으로 사용자 정의 가능</li>
</ul>
<p>이제야 NextJS를 왜 사용하고, 언제 사용하면 좋을지를 알게 되었다. 하지만, 아직까지 코드 스플리팅이 무엇인지, HMR이 무엇인지 이것들이 실제 코드에서 어떻게 구현되고 어떤 도움이 되는지를 알지 못한다. 따라서 다음에는 본격적으로 NextJS를 사용하기 전에 익숙하지 않은 키워드들을 정리해보도록 하자.</p>]]></description><link>https://rayleighko.github.io/blog/2019-03-05-weplanet_project_01</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-03-05-weplanet_project_01</guid><pubDate>Mon, 04 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Next 입문하기&lt;/h1&gt;
&lt;p&gt;우선 나는 이 글을 쓰기 전에 &lt;a href=&quot;https://nextjs.org/&quot;&gt;NextJS&lt;/a&gt;에서 제공하는 Quick Start를 따라 간단한 &lt;a href=&quot;https://github.com/rayleighko/react-nextjs&quot;&gt;예제&lt;/a&gt;를 구현한 경험이 있다. 하지만, NextJS를 사용하는 법은 알았지만, 억지로 쓰자면 쓸 수 있었지만 왜 써야하고 무엇을 위해 존재하는지를 알지 못했기 때문에 이번 기회를 통해 제대로 NextJS를 이해하고 입문하고자 했다.&lt;/p&gt;
&lt;p&gt;더불어 지금 내가 보고있는 코드가 NextJS를 기반으로 이루어진 코드이기 때문에 이를 이해하기 위해서는 필수불가결하게 NextJS를 이해해야만 했다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velopert.com/3293&quot;&gt;참고자료 1 - Next.js 2.0] 간단한 React 전용 서버사이드 프레임워크, 기초부터 본격적으로 파보기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaroinside.tistory.com/24&quot;&gt;참고자료 2 - 11. 서버 사이드 렌더링, 클라이언트 사이드 렌더링&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nextjs.org/learn/basics/getting-started&quot;&gt;참고자료 3 - NextJS Getting Started&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;왜 NextJS인가?&lt;/h2&gt;
&lt;p&gt;우선적으로 무언가가 존재하는 이유를 알기 위해서는 그 기술이 왜 만들어졌는지를 이해하면 학습에 큰 도움이 될 것이다. 그렇다면 Next.JS는 왜 만들어진 걸까?&lt;/p&gt;
&lt;p&gt;가장 큰 이유는 리액트에서 SSR(Server Side Rendering)을 하기 위함이라고 할 수 있을 것이다. 리액트에서의 SSR이라는 것을 이해하기 위해서는 기존 웹페이지에서 렌더링하던 방식을 알아야 한다. 우리는 먼저 웹페이지를 구동하는 방식에 대한 이해부터 시작하자.&lt;/p&gt;
&lt;p&gt;우선적으로 웹페이지가 존재하기 위해서는 어떠한 웹 페이지에 접속할 때, 그 페이지를 사용자 화면에 그려주기 위해 렌더링이라는 작업이 필요하다. 그래서 웹페이지를 구동하는 방식은 &quot;언제, 어떻게 렌더링을 할 것인가?&quot;에 대한 답이기도 하다.&lt;/p&gt;
&lt;h3&gt;전통적인 웹페이지 구동 방식&lt;/h3&gt;
&lt;p&gt;요청 시마다 새로고침과 함께 서버에 새로운 페이지에 대한 요청을 하는 방식이다. 이때 View가 어떻게 보여질지 또한 서버에서 해석하여 보내주기 때문에 이를 &apos;서버 사이드 렌더링&apos;이라고 이야기한다. 더불어 이는 물건을 쟁여두지않고 필요할 때마다 사러가는 것과 같은 맥락이다. &lt;/p&gt;
&lt;p&gt;하지만 기술의 발전으로 웹에서 제공하는 정보량이 많아지고, 이에 따라 여러 문제점이 발견되면서 전통적인 웹페이지 구동 방식과는 다른 SPA(Single Page Application)라는 기법이 등장하게 되었다.&lt;/p&gt;
&lt;h3&gt;SPA 구동 방식&lt;/h3&gt;
&lt;p&gt;SPA는 이름 그대로 처음에 하나의 빈 페이지만 서버측에 제공하고, View에 대해서는 Client에서 JS를 통해 렌더링하는 방식을 택했다. 이를 CSR(Client Side Rendering), 혹은 &apos;클라이언트 사이드 렌더링&apos;이라고 이야기한다. CSR은 물건을 사러 갈 알바를 고용하고 필요할 때마다 물건을 배송받는 것과 같다.&lt;/p&gt;
&lt;p&gt;SSR과 CSR을 비교하여 설명하는 것은 처음에는 이해가 안될 수도 있지만, 간단히 View를 렌더링하는 위치가 서버냐 클라이언트냐에 따라 서버 사이드 혹은 클라이언트 사이드 렌더링이라고 이야기한다는 것을 알고 넘어가도록 하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서 주의할 점은 우리가 살펴 볼 SSR과 CSR은 전통적인 웹페이지 구동방식, SPA 구동 방식을 의미하는 것이 아닌 전통적인 웹페이지 구동방식에서는 SSR을 사용하고, SPA 구동 방식에서는 CSR을 사용한다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그리고 이제부터 SSR과 CSR의 가장 큰 차이인 &apos;초기 View 로딩 속도&apos;, &apos;SEO&apos;에 대해 살펴보고 보다 확실하게 NextJS를 사용해보도록 하자.&lt;/p&gt;
&lt;h3&gt;SSR과 CSR의 차이&lt;/h3&gt;
&lt;p&gt;먼저 SSR과 CSR의 가장 큰 차이 중 하나인 &apos;초기 View 로딩 속도&apos;를 비교해보도록 하자.&lt;/p&gt;
&lt;p&gt;SSR의 경우에는 View를 서버에서 렌더링해 가져오기 때문에, 첫 로딩이 매우 짧다. 물론, JS 파일을 모두 다운로드하고 적용하기 전까지는 각각의 기능이 동작하지 않겠지만, 사용자의 입장에서는 매우 빠른 속도로 로딩이 됐다고 생각할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;반면에 CSR은 서버에서 View를 렌더링하지 않고, 먼저 HTML을 다운로드하고, JS 파일이나 서비스에 필요한 리소스를 다운로드한 후 브라우저에서 렌더링 해 보여주기 때문에 SSR보다는 초기 View를 보기까지의 시간이 길다. 하지만, 보여진 기능 모두 보임과 동시에 동작 가능하다.&lt;/p&gt;
&lt;p&gt;물론, 이 두 차이점은 개인의 취향 혹은 서비스의 UX에 따라 달라질 것이기 때문에 어떤 것이 옳다고 이야기할 수 없을 것이다. 그렇기 때문에 두 번째 큰 차이점인 SEO 문제에 대해 살펴봐야 어떤 것을 선택할지를 판단할 수 있을 것이다.&lt;/p&gt;
&lt;h3&gt;SEO 문제&lt;/h3&gt;
&lt;p&gt;SEO는 Search Engine Optimization의 약자로 검색 엔진 최적화를 의미한다. 즉, SEO 문제는 검색 엔진 최적화 문제를 말하고 검색 엔진의 크롤러들이 웹 페이지의 JS를 해석해 노출시키기 때문에 크롤링을 할 수 없는 시점에서는 검색 엔진에 노출시키지 않는 것이고, 이는 노출 횟수가 줄어듦을 의미한다.&lt;/p&gt;
&lt;p&gt;따라서 CSR은 View를 생성하기 위해서는 JS가 필요하고, View를 생성하기 전까지는 검색 엔진 크롤러의 데이터 수집이 제한적이기 때문에 상대적으로 SEO가 잘되지 않아 사용자 유입이 적고, SSR은 View를 서버에서 렌더링해 제공하기 때문에 상대적으로 SEO에 유리해져 사용자 유입이 많을 것이다.&lt;/p&gt;
&lt;p&gt;정리하면 SSR은 초기 로딩 속도가 빠르고 SEO에 유리하지만, View 변경 시 서버에 계속적으로 요청해야 하므로 서버에 부담이 크다. 그리고 CSR은 초기 로딩 속도가 느리고 SEO에 대한 문제가 있지만, 초기 로딩 후에는 View를 서버에 요청하는 것이 아닌 Client에서 직접 렌더링하기 때문에 매우 빠르다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;또한, 최근에는 이 두 가지 방법을 적절하게 융합한 방법들도 나오고 있다. 즉, 첫 번째 페이지 로딩에서는 서버 사이드 렌더링을 사용하고, 그 후에 모든 페이지 로드에는 클라이언트 사이드 렌더링을 활용하는 방안이 그것이다.&lt;/p&gt;
&lt;h2&gt;다시 본론으로..&lt;/h2&gt;
&lt;p&gt;우리는 NextJS의 탄생 배경을 이해하기 위해 앞선 것처럼 SSR과 CSR을 알아봤다. 그래서 우리는 NextJS를 리액트에서의 SSR을 위한 &apos;도구&apos;라는 것까지 이해했다. 그럼에도 불구하고 다른 도구가 아닌 NextJS를 사용해야만 하는지에 대해서는 이해하지 못했다. 그래서 우선은 NextJS에서 제공하는 &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;문서&lt;/a&gt;를 살펴보기로 했다.&lt;/p&gt;
&lt;p&gt;문서에 따르면, 최근에 각광받는 Single Page(단일) JavaScript applications에 대한 이야기와 이를 구현하는 것에 대한 어려움을 이야기한다. 더불어 아직도 적절한 어플리케이션을 만들기 위해서는 높은 러닝 커브(client-side routing, page layout 등)를 감수해야 하고, 이는 빠른 페이지 로드를 위해 사용하는 SSR을 적용하기 위한 어려움으로 이어질 수 있다고 이야기한다.&lt;/p&gt;
&lt;p&gt;그래서 NextJS 팀은 사용자 설정이 가능하지만 간단한 무언가를 원했고, 이것을 PHP의 그것과 같이 라우팅에 대해서 걱정할 필요없으며 기본적으로 응용 프로그램이 서버에 렌더링되게 만들고자 생각했다고 한다. 그래서 탄생한 것이 NextJS이다.&lt;/p&gt;
&lt;p&gt;이제 NextJS의 탄생 배경을 어렴풋이 알게 되었다. 그렇다면, 본격적으로 문서를 통해 NextJS로 무엇을 할 수 있을지를 살펴보자. 왜냐면 우리는 NextJS를 &apos;잘&apos; 사용해야 하기 때문이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server-rendered by default&lt;/li&gt;
&lt;li&gt;Automatic code splitting for faster page loads&lt;/li&gt;
&lt;li&gt;Simple client-side routing (page based)&lt;/li&gt;
&lt;li&gt;Webpack-based dev environment which supports &lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Hot Module Replacement&lt;/a&gt;(HMR)&lt;/li&gt;
&lt;li&gt;Able to implement with Express or any other Node.js HTTP server&lt;/li&gt;
&lt;li&gt;Customizable with your own Babel and Webpack configurations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 내용을 한글로 살펴보면 다음과 같이 이해할 수 있을 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로 서버 렌더링&lt;/li&gt;
&lt;li&gt;보다 빠른 페이지 로드를 위한 자동 코드 스플리팅&lt;/li&gt;
&lt;li&gt;간단한 클라이언트 사이드 라우팅(page 기반)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Hot Module Replacement&lt;/a&gt;(HMR)을 지원하는 웹팩 기반 개발 환경&lt;/li&gt;
&lt;li&gt;익스프레스 혹은 어떤 Node.js HTTP server로 구현이 가능&lt;/li&gt;
&lt;li&gt;바벨과 웹펙 설정으로 사용자 정의 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제야 NextJS를 왜 사용하고, 언제 사용하면 좋을지를 알게 되었다. 하지만, 아직까지 코드 스플리팅이 무엇인지, HMR이 무엇인지 이것들이 실제 코드에서 어떻게 구현되고 어떤 도움이 되는지를 알지 못한다. 따라서 다음에는 본격적으로 NextJS를 사용하기 전에 익숙하지 않은 키워드들을 정리해보도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 아키텍처 - Web Application Hosting_03]]></title><description><![CDATA[<h1>AWS - Architecture study: WEB APPLICATION HOSTING</h1>
<p>일단 이 글을 읽는 이들은 다음과 같은 조건을 충족했다고 가정한다.</p>
<ul>
<li><a href="https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_2">이전 글(이론)</a>을 읽었다.</li>
<li>AWS 계정이 있다(Free tier가 아니여도 무관하다).</li>
<li>루트 계정이 아닌 유저 계정으로 콘솔에 접속했다(루트 계정은 이메일로 되어있는 계정을 말하고 유저 계정은 관리자가 정한 계정을 말하는데, 루트 계정으로 작업을 하게 되면 보안에 취약할 수 있으니 반드시 유저 계정을 따로 생성하길 바란다).</li>
<li>과금이 발생할 수 있음을 인지하고 있다.</li>
</ul>
<p>여기서 우리는 다음의 5가지(크게 7가지) 서비스를 사용해볼 것이다.</p>
<ul>
<li>EC2(ELB, Auto-Scaling)</li>
<li>RDS</li>
<li>S3</li>
<li>CloudFront</li>
<li>Route 53</li>
</ul>
<p>이제 어떻게 구현하면 좋을지 생각해보자. 먼저 EC2를 만들고, html로 랜딩 페이지를 띄우고, 이를 ELB로 로드밸런싱할 것이다. 더불어 S3에는 이미지를 저장하고, 이를 CloudFront로 정적 이미지를 제공해줄 것이다. 이때 데이터베이스는 RDS에서 MySQL로 제공할 것이고, 결과적으로 오토 스케일링이 가능라도록 구현하고자 한다. 나는 이를 가장 쉽게 설명하고 있는 <a href="https://aws.amazon.com/web-applications/gsg-webapps-linux/">Getting Started with Linux Web Applications in the AWS Cloud</a>을 따라 만들어 볼 것이다!</p>
<p>만약 필자와 같은 선택을 할 것이라면 본격적으로 실습을 진행해보자. 내가 이 글을 쓰는 지금(2019. 02. 26)의 AWS 콘솔의 첫 페이지는 다음과 같다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/9608e87e453c04fc6a5d7f2da593ecca/c2bec/aws-main.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABsklEQVQoz31S7W7UMBC8RweE1PaActeCeuIPT4ZUlct3nNhJnDh2kmF3j6ZqQI00yq7tHe/Mend9+w2fjw+4OTzg6vY77k4/saf4w80R766+4v31QeIt+OyX+x/4dDxJvD+c8HF/hx3oC1NAmqYoVYkojiVWlZI8z3PZf/tb/gLY1VqjqmskRJLlBZqmvaC9/I1p0LYd2u4FpaoQJ4nU5FTD+xcejZ1pGinOqBNVVXDjiNF7zPMsWJZljZ9RUwMxKfkdxaQogXOjXMRcK2FnrSzy3zmHkYjDNGEigi20NtRdhlRpaFLRD4NwrIRM1PeDSBwG93+HlpeYbYiiCJbqQgjSwCtCTmrSzz6w5IFuFNBBhtuAPf/1+IRznKIim1jNKvmZOU4yPD6didSIyU3Xi5fej3SJR08+9dQ9rxljEGeFyJ3oBbCv/3SoDE3Kegx+pq48okKjtYPILDQNre5gx0mGxJJjGkZRlChpbxjD66HwIJIkJR+tEFjKz+dofVspDUCV6uIhE1INn287K0q83xByonQDS53NxOHDBN32cGGW3LSWcrsh5HeYI8pK8tCvhH8AcBk4zjJ6gG8AAAAASUVORK5CYII='); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-main"
        title=""
        src="/static/9608e87e453c04fc6a5d7f2da593ecca/b33e9/aws-main.png"
        srcset="/static/9608e87e453c04fc6a5d7f2da593ecca/f1223/aws-main.png 163w,
/static/9608e87e453c04fc6a5d7f2da593ecca/593bc/aws-main.png 325w,
/static/9608e87e453c04fc6a5d7f2da593ecca/b33e9/aws-main.png 650w,
/static/9608e87e453c04fc6a5d7f2da593ecca/a1e87/aws-main.png 975w,
/static/9608e87e453c04fc6a5d7f2da593ecca/89a59/aws-main.png 1300w,
/static/9608e87e453c04fc6a5d7f2da593ecca/c2bec/aws-main.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>여기서 예제의 처음에 등장하는 S3 버킷을 생성해보자. 예제의 영상은 오래 되었지만, 그 동작은 변함이 없다. 검색란에서 S3를 검색해 'aws-webapp'이라는 bucket을 서울 리전에 만들어보자(S3는 생성 시 리전을 고를 수 있다).</p>
<p><img src="./assets/aws-s3.png" alt="aws-s3"></p>
<p>Create bucket을 눌러 아래와 같이 'aws-webapp'이라는 버킷을 만들자(버킷은 이름의 중복을 피해야 한다. 가령 다른 사람이 aws-webapp을 사용하고 있다면 그 이름을 사용할 수 없다. 그래서 나는 aws-webapp-mj라는 버킷을 만들었다).</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/55a3692a6246c0c11e677f616a78d37d/c2bec/aws-s3-2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACH0lEQVQoz32R+U4aURTGebA2TaFCm6al1ZBitRorUDvDYpCGZQSVTQcG44zKUPZNLWAjmyglvkBfoC+goU36Dl/vHcR00f7xy3fPnHu/fOeMivWF4eDCMHIiJnwynnIp6Nz70KyIeOjcIYjQfZAU1M7RNzXp0b7GJUHrkaFlQ9DOLEH9ygzVQbuPWqsHX/8bXl/8hLF9Cf3JJV42rzDdHWK2N8T82XfMEYyknjkdKr0XBGPnCvr2D5gPvyKWLiORP4IqW2ui1GjDuZ2DYVWEgSa1RxQeO6IKGltEQXddj/tPlqNQW8OwxTKonw5Q6w6gytebKBx3wPh5uEICgmIaPl4CF5MUHZ//qYn6hT1Y/VGw/i1UmueoNs/IyK1zHHW+wLaRACfI2JSL4D+WCRUyBqV6rePzqOYJidwhvPEkmHUB+ZM+qJdiWCNxHcEE7BsCuPg+1nbSCqsJ+U44Ar1D3zBrccWwemNIZreThDRdvt5CstJAjqhUqkEq3o5Y/IRk9RjrZEXM2t8Ju6OEXpJOyFSxlSohTkfKHtwJvUdN/dspvP/dkC6SGrIBHvcMJkzMWfHoDQvN7P+hdx5ML+G+YRFmbwSZz73RT6n3LtAgBMQsLAEBk4wbU4yH6G24b/rPLS6wZE2mcArm4C7KnQGol4pPFhCTC3BvSjC5w3i2YId+cflP3o500rKiMPXOpdQWTwjz3hgWvDwie3lEdrP4BXgVOQ1p1OK3AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/55a3692a6246c0c11e677f616a78d37d/b33e9/aws-s3-2.png"
        srcset="/static/55a3692a6246c0c11e677f616a78d37d/f1223/aws-s3-2.png 163w,
/static/55a3692a6246c0c11e677f616a78d37d/593bc/aws-s3-2.png 325w,
/static/55a3692a6246c0c11e677f616a78d37d/b33e9/aws-s3-2.png 650w,
/static/55a3692a6246c0c11e677f616a78d37d/a1e87/aws-s3-2.png 975w,
/static/55a3692a6246c0c11e677f616a78d37d/89a59/aws-s3-2.png 1300w,
/static/55a3692a6246c0c11e677f616a78d37d/c2bec/aws-s3-2.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>Copy할 버킷이 없으므로 다음으로 넘어가자. 다음으로 넘어가게 되면 다양한 속성들을 설정할 수 있는데, 만약 사용할 기능이 있다면 체크해도 좋지만 나는 여기서 따로 사용할 기능이 없기 때문에 Tags에 Name이라는 key를 webapp으로 만들어주고 다음으로 넘어갈 것이다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/c2f24c16a02dbe2053ee7193fe516139/c2bec/aws-s3-3.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.41666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQoz3WS61JSURiGubLKKdJJ2BxK85BycLNRwA2CbN2bRBFCDuIopWQcdEINyDEYCDVzxgvoBrqAzKY/3cHbtxb2y+nHM2t9a6/9zLu+tXReNQF/JIGhyCYeqgUMaAXolW30Bbdwb24T9wn9fJ7zgNZYzUZGXyiPR4u03xuHfmwafcMidEftL6i3uli5/A7b1R+Mdq5hbv7AcPsnJk9/cWxnPUY/3+BF9wbW1jUsBNtr6fyGu/YN2WIVG3s16Er1JvYaLcTe1SDnD+DOVOBIFiGmSpDSZbgJ51oZDkJKV/h3MVXmsLk9WUJk5wj1DgXrXEBXaZDwYxueaAYuJQaRGJc1QsXzWRWmmQUIYgDClB9GZw827xHAwKQXvmgK1eYZDpqn0B22zvCBjj27msNYYAkOJY5R/xKsXhWPJQV6RwAGMQSD6y5GaR79dj9mltdRaZ7jgFxcyKIGSJjeraJMaXOlQ8R39pHdqyOWL8LsDmNwag5GMUjyIB+NJBRIOGCXSZi9K5RjOWy8P8Hu8SmcC3HYwzG4tSSfW2cU/rNBClOqME/WE4b+L/RTQokEvuUMhmc1zpBPxTNihFpg8WoweFQIhGF6gSflCR105CgJP90KWSNr1EM5to6J0Aq/HBulY8IROQKrT+MCwUUCluofJBt0BtA/4YFLfYXicbd3KY3uV5ycX0GmhE+mgpRKg4Vu1kR9M00rMBMWBq2Zb2sGE/oS27CtvoUUf41q+wKN7iV0a28qyBT24X2ZhFmcg0BHEOhpmOhJmJw9eE1YKaWV+vaUYHslNYVxJQ3H4hri+TISW0X8BXvWH610XH6FAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/c2f24c16a02dbe2053ee7193fe516139/b33e9/aws-s3-3.png"
        srcset="/static/c2f24c16a02dbe2053ee7193fe516139/f1223/aws-s3-3.png 163w,
/static/c2f24c16a02dbe2053ee7193fe516139/593bc/aws-s3-3.png 325w,
/static/c2f24c16a02dbe2053ee7193fe516139/b33e9/aws-s3-3.png 650w,
/static/c2f24c16a02dbe2053ee7193fe516139/a1e87/aws-s3-3.png 975w,
/static/c2f24c16a02dbe2053ee7193fe516139/89a59/aws-s3-3.png 1300w,
/static/c2f24c16a02dbe2053ee7193fe516139/c2bec/aws-s3-3.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>다음으로 넘어가게 되면 다시 한 번 체크 박스가 나온다. 여기서도 사용자의 필요에 따라 체크를 하지 않을 수 있지만, 권장 사항이기 때문에 체크하고 넘어가는 것이 바람직할 것 같다. 더불어 Manage system permissions는 S3 로그 전달 그룹(Delivery group)에 이 버킷의 로그가 쓰여지는 것을 허용할 것이냐는 말인데, 지금 당장 로그 정보가 필요없으니 허용하지 않고 넘어갈 것이다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/52e6474dec63308124774db90162e8bf/9ddb8/aws-s3-4.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.82865168539326%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACc0lEQVQoz22S2VIaQRSG582SWMHEJSKYGFkVFQVUlhkGRkAWkV0FxGUiJZZRXNAqBAUTTVJ5iuQ+idGbPMOf02NSpVVefH1O93R/fU7XcFOzC3AF43gbLOB5QEZ3UMYLaR0dwgqeeIp4yheh8q6gU1xRcrb2jL+D7VH516Fy56AyOtAxaAVXPbtErdFC7Oo79F/+4E3jJ3pOfkBT/wVT6wZDZ79hoDh8cQtj+0ZB27hGX/0ag81raJq3MNS+IVWuYqlyAK58eIqd4ybEQgWD4RLMcRn62AaM8zJMsTXoIqtQS3l08Vn0iTmoxUX0eHPoFnI0X1TWTdFVVBsfcHR+BW6bZLv1NqYj9MEVgDOcxlQooTAsRKCbkWB0StBP+6GnfGjKDx3LCYNzFhqrB0ZXEJWTc+yeXoDbo2G/+RHOeB4jvjgckRxscxnYwlmMhjIwinFoHXTQ7lfo/xcZWoeEXqsAAx/Fu+MWdqlKjpV63P4EPlFQhLa5NCaDKdgpWgNJjEkL0NGB7jEPesf5B7wiWdeom4SRh8Ja654wlMZEgAkzGPEnoLZRNTYf1JM+OuzBS4sLXRY34VJkneaZR4RUoWchT6IkBBKz3E7iUd+8UuE4YzYBszcGE72rSYgqcZjmevccTBTl2vmdkL3hUesK7vgyfKkiFjffI72xjdR6Bcm1LYWsvINCZR/F7YN7HCK/VUWiVIZFjKJUPb0THlG79cuvSsusBY2dtSdSqyL6qdX/KGv3YO834k/DEqFfS8pi86SFw/ZncMvlPZToxplwBv1WHgOTXmgnhEcZsHnxmi5iaGivPZTFdFKGQcohtbGDJXL9BdYdJQBg6TCVAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/52e6474dec63308124774db90162e8bf/b33e9/aws-s3-4.png"
        srcset="/static/52e6474dec63308124774db90162e8bf/f1223/aws-s3-4.png 163w,
/static/52e6474dec63308124774db90162e8bf/593bc/aws-s3-4.png 325w,
/static/52e6474dec63308124774db90162e8bf/b33e9/aws-s3-4.png 650w,
/static/52e6474dec63308124774db90162e8bf/a1e87/aws-s3-4.png 975w,
/static/52e6474dec63308124774db90162e8bf/89a59/aws-s3-4.png 1300w,
/static/52e6474dec63308124774db90162e8bf/9ddb8/aws-s3-4.png 1424w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>마지막으로 지금까지의 설정을 확인하고 되묻는데, 여기서 제대로 설정했는지를 확인하고 생성을 마치도록 하자.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/bfd7adee2c7548bb808b1704a41bb866/c2bec/aws-s3-5.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.27777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABkklEQVQoz62Qy0sCURTG568qInpQLoIkogcRQhgUtK516xatWkQEQX9DQi/LTDMsIiHKsvDZKs2hcWac0Xl9nXvVUqMI6sBvznfO/c6ZmSusrm1gfXMbS8sr6BudwdT8ItyeBbgmZjE47sXAmJdyTbvquZt8HW4Puoan0TPiQS/V/ZNz6ByagoB6lCtVxOIJ3NzF8ZjOIpF5xiORSD9zzUnnOPepHG6TGdw+pRB7SCIaT+LyIUV1GkJRFCESLHTTRraoQNYq+E1UKzocx27pCZL0hnxRhGHZyIgatqI5XGdfYZBZVlWUNQ0qoelUKypUvQLDNEkrHKlUwks+D4W8Fu2gX3a4YAsBG5auQJUlVA0Dtk21ZX3AFrxJJag0XJJlnhXq5QsFqOUyfa3zeYdUwSZMWmyaFj9sD9ZjL2E0dLOPL2QP1qtl58uCZn6KhkdoGNuH2/vfedrPhdr9tN7VXxDwzyEEw1GEIheIRK9wFDzDzq4fvv1j+PaO6tQ19Q4CIRyehOEnDkn7yc8ymwucnnP9Dt5XJ4/nx/LXAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/bfd7adee2c7548bb808b1704a41bb866/b33e9/aws-s3-5.png"
        srcset="/static/bfd7adee2c7548bb808b1704a41bb866/f1223/aws-s3-5.png 163w,
/static/bfd7adee2c7548bb808b1704a41bb866/593bc/aws-s3-5.png 325w,
/static/bfd7adee2c7548bb808b1704a41bb866/b33e9/aws-s3-5.png 650w,
/static/bfd7adee2c7548bb808b1704a41bb866/a1e87/aws-s3-5.png 975w,
/static/bfd7adee2c7548bb808b1704a41bb866/89a59/aws-s3-5.png 1300w,
/static/bfd7adee2c7548bb808b1704a41bb866/c2bec/aws-s3-5.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>다음으로 예제가 설명하고 있는 것은 CloudFront인데, 이 동영상의 링크가 잘못된 것인지 EC2를 생성하는 예제를 설명한다. 따라서 나는 <a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html">CloudFront 시작하기</a>라는 AWS CloudFront 튜토리얼을 읽어야만 했다.</p>
<p>우선은 CloudFront를 사용하기 위해선 앞선 설명처럼 S3의 버킷이 생성되어 있어야 하고, 컨텐츠가 업로드되어 있으며 객체 권한이 부여되어 있어야 한다.</p>
<p>이를 위해 해당 문서의 <strong>Amazon S3에 콘텐츠를 업로드하고 모두에게 읽기 권한을 부여하는 방법</strong>을 따라 S3의 설정을 진행하도록 하자. 우리는 "6. <strong>버킷</strong> 창에서 버킷을 선택하고 <strong>업로드</strong>를 선택합니다."부터 진행하면 될 것이다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/8815065789df870264505531a319bd98/c2bec/aws-s3-6.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACXklEQVQoz2WS61MSYRTG+cOraaYmtQkzSzNrmuky0wdNLS3RLiMoBZIMiiKKyk1gAYGFBXZhF36dfcM+1M48ey7veZ9zznuOZ3xyhrGHs0xMz3PXO8Pcy7fMPn+F9/E8D6ZdPBtB9EdzeEXe8z7h9viUyBkmpp4yNjmr5J3703gYfY7dk1+f4F6MtWCEzR8RfIGf+EJRfGKvi74RjrEaCJMtaurOkP8/j2n1+JVvEcrq7GSaBA5S7MWP2dlPEj1MEjtOEUucEjs6YT95RvQoiVap4jgOpmXRaOiCBp1uF6vXwzMYDtnXOuwVO/zMG5Q6A2zJ1HZAalZ6fySv0ZWzpuUoXBmmgm72VcWK0Og51E0bXQIqnT4lo89lo0O6opOuNslctQTGH1uQq7cpt20qwly1hpQ77j0bl0sR1ro2mpBoRk8C++rQlVrLoiy+kshSw1D6tc+NKUjSrFYV26L6L2FFssQzJWIXBbQRqZtAl/YWlj/yej2AZkFFzqrdAZdS5Y2bt5h8s0TBsLn6SzgYSrtSujkgVaqxFU2QlRarbjsCTbK/W1xiMRgnb4hPnsSNLehdFj6ssRJJid9WRSlCxxmgNbscpQscnGU4PM+RLjfkXWzydYP4eZ7jbJGTdJ5E+lI9Ra7WInaaIZEpkLzIET/LSoIOLpfaQ2OAqqYsmcvmkJa02RZ/U6QuI3YnX+wOaYjeklHWZBBFIcjrJpr4672hilV7GIpE2ZLlDUQOZJF3ee/zs7IZYHnDLwiw+nWbFyvfmVv6hs8f4vNWSOLCbGzvqvhPYrv6l50I/mCY30sFGVrRy2xPAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/8815065789df870264505531a319bd98/b33e9/aws-s3-6.png"
        srcset="/static/8815065789df870264505531a319bd98/f1223/aws-s3-6.png 163w,
/static/8815065789df870264505531a319bd98/593bc/aws-s3-6.png 325w,
/static/8815065789df870264505531a319bd98/b33e9/aws-s3-6.png 650w,
/static/8815065789df870264505531a319bd98/a1e87/aws-s3-6.png 975w,
/static/8815065789df870264505531a319bd98/89a59/aws-s3-6.png 1300w,
/static/8815065789df870264505531a319bd98/c2bec/aws-s3-6.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>업로드 시 유의해야 할 사항은 읽기와 쓰기 권한의 설정이다. 필자의 이미지는 S3를 필자의 AWS계정에서만 사용 가능하도록 설정할 것이다. 더불어 여기서는 암호화 또는 태깅과 같이 객체에 원하는 속성을 설정할 수 있는데, 이는 사용자가 알맞게 사용하면 된다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/afe834832c776264de2bd9968c862d69/c2bec/aws-s3-7.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACcUlEQVQoz22SW08aURSF+WV9qK2VaoNotGm1iRpBURQBYYa7OiPKdUSu4giViyilIl4ASZs2aZs+WPVZrW/9H6t7Bppo0oeVtXdmznf25ShmbTz0Ng7DzgiUrjRUnm0obUk8t8TQtRglj0LJxNBD6rK0825r218wcfTYUxhmw5iz85hmOChKZ59QPmnCcnwN9ekf9Fbu8axwC1X5HuoPUnyDvv07yn/Lrizd4Wn+Bt3FW/SVbvEkf4eZgwuZsXfSgiJXrWM9d4TQ4RdEzn4iVPuBQPUbhNp3xBoXiJ9fIdL4hWjzEsnWFeWXchwjT0hx6xqJ2lfsVo4hsRTFWhPh0inc8V14k7vwRESwgQRswSTs4TQcQhouYQtOckd4S5az49I3WzAln8tWGyjWztvAXK2F2aUgxphVEo83C268M7mhYVYwYnRhxhOA1unDW6MHI6aOKB41L2FIb8e024+d6jkKxJKBGUrmVgRMsDwm7WsEc2GYCWA0XMGgeQ0jC04ZptYxGJiRxGKA4kHyVxqzXEzm6BGwCdPaJphOq6w/Dj0XwVxAhG5ZgJEXYOA3oPME5Wr/SU8gDRUwzwlUYRPFh0CLLw5vfAfBdA7+FM0zJoKPpOBLZhHe2ZMlZB5r8/0+fFs5OhuDeNgBFo4aED/WobV70TthgHraiv4pi+xqXVtSe/+TSruIl+MGaB1ebFfqkFiKA3qH+WNail+Eit2guXRm9EDS7PofwugfFV0qbXkqUIBmdRt5eoPl+mco1hNZajUrt6xx+DFm9mB8cakt2uIE+WuDG0Pz0ta5tlgOk9YVLCyHaJYhGLgNcNEMVqMi/gJN3juep+pe0gAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/afe834832c776264de2bd9968c862d69/b33e9/aws-s3-7.png"
        srcset="/static/afe834832c776264de2bd9968c862d69/f1223/aws-s3-7.png 163w,
/static/afe834832c776264de2bd9968c862d69/593bc/aws-s3-7.png 325w,
/static/afe834832c776264de2bd9968c862d69/b33e9/aws-s3-7.png 650w,
/static/afe834832c776264de2bd9968c862d69/a1e87/aws-s3-7.png 975w,
/static/afe834832c776264de2bd9968c862d69/89a59/aws-s3-7.png 1300w,
/static/afe834832c776264de2bd9968c862d69/c2bec/aws-s3-7.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>다음으로 넘어가면 다시 여러 속성을 만날 수 있는데, 나는 기본 세팅 그대로 설정해주고 넘어가도록 할 것이다(지금 당장 필요가 없는 설정이기도 하고 귀찮기 때문).</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/3ec0d347303704bf9a94f2ed8e825901/c2bec/aws-s3-8.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABuklEQVQoz61RTUscQRCd3xovboK7RvxOgrjGGNcRPyIk8Rd4UW+CMUGTQPCSmwdRQRFk2XV3pudrZ6ane16qeseRCAs5pOB1ve4u3quutuyNT3i3zviM+vImltY+om5vYXbBxvR8AzOc6yt/8bmlNbylmvdUa3/YRoM07M1tLK5uwUIZuVlPTn9j58sP7H/9id3DY+wd/8Lutz7f/36KncMTXN81MSisNJW4vfdw0xa4ajpodly4joOOIxD1YvR6vT7iRx4nCZIkJSSIouKM7mWWwVI6x9Glg4PzLvbOOrhoB5AyRTdKkWYKSmsopZCpPte5NpzBAl0yb7VaxjDPc3oyLTolh9ADtITKJOKUxEiUO2EeUXGr3YbreQijCK4Q5s7zfSPIYgnVGUFeYmrfER4CKjbu5Cwz9diJlAjCsERET+RzFmIDBndbCjIevkUX+6d4Gua8yNyALvaWprnkA0T+FaWBmeF/DisMAwgasuN04fs09CBAEPgGPn2C54kSQriD4fazNb/YwOSrOYxPv8HY1GsMV8fxvDaBCuWhSg3PhqsYYlSqqNTobnTCgPmLl0UencTI2JThfwDGVxs9oLuAmAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-s3"
        title=""
        src="/static/3ec0d347303704bf9a94f2ed8e825901/b33e9/aws-s3-8.png"
        srcset="/static/3ec0d347303704bf9a94f2ed8e825901/f1223/aws-s3-8.png 163w,
/static/3ec0d347303704bf9a94f2ed8e825901/593bc/aws-s3-8.png 325w,
/static/3ec0d347303704bf9a94f2ed8e825901/b33e9/aws-s3-8.png 650w,
/static/3ec0d347303704bf9a94f2ed8e825901/a1e87/aws-s3-8.png 975w,
/static/3ec0d347303704bf9a94f2ed8e825901/89a59/aws-s3-8.png 1300w,
/static/3ec0d347303704bf9a94f2ed8e825901/c2bec/aws-s3-8.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>이로써 필자는 S3에 파일을 업로드할 수 있었다. 이처럼 업로드가 완료된 파일은 URL을 통해 접근할 수 있는데 필자의 경우 다음과 같은 URL로 파일에 접근할 수 있을 것이다.</p>
<blockquote>
<p>s3://aws-webapp-mj/40321838.png</p>
<p>혹은</p>
<p><a href="https://s3.ap-northeast-2.amazonaws.com/aws-webapp-mj/40321838.png">https://s3.ap-northeast-2.amazonaws.com/aws-webapp-mj/40321838.png</a></p>
</blockquote>
<p>다음으로는 CloudFront 배포를 만들 것이다. CloudFront 배포를 만들려면 문서의 과정을 거쳐야 하는데, 그 중 가장 먼저 할 것은 CloudFront의 콘솔을 열어 <strong>[Create Distribution]</strong>을 선택한 후, [<strong>Select a delivery method for your content</strong>]의 [<strong>Web</strong>] 섹션에서 [<strong>Get Started</strong>]를 선택하는 것이다. 이 과정은 내가 따로 적을 필요없이 <a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html">문서</a>에 매우 잘 나와있기 때문에 문서를 참고하도록 하자.</p>
<p>나는 S3를 설정한 것 외에는 전부 기본값을 사용해서 다음과 같은 CloudeFront Distributions(배포판)을 만들었다.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/e3170a7ac6872a024aec5b7487eceffb/c2bec/aws-cloudfront.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABYklEQVQoz62Q60sCURDF7//dhyg0RC0tzSLo38goUCsfSWIQJIbu0i5sWj5287Xr89e9ViB+SujAMIeZueeeGbHtC+IPRogmzgkdHBGLn7IXOmRrN8hOIIo/HMcXiuH/CcV9we8ciJywHzsjfHRG5PicwEECwQpunt9Jli2MZpee02Exn/EnLBa47kgRRL/fp93uMBq5VOom2YcnKi816ppOra6haRq6rtNsNrGsN0zT5NUwMAxzyTVdo1qtUi4/yr6FaLVaNBoNZrMZ04knnXXxXBfro0ur+4njOPLDNoPBQLpwsW2bXq+35I4te3Yb27FROsPhEKEGPM/7ds7mUEY812M8HsvN5cqKTKdT5vP5srBprGPpUNmdTCY/991MbL0mlJC6h7K+OrQJVt+J31WV4H+E4J8hsoUH8sUSxdIjmbt7Lq7SXF5nSK6FqqVucqRv86TvCqRkzqzk21xR9vN8AShnNRcFdpW0AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-cloudfront"
        title=""
        src="/static/e3170a7ac6872a024aec5b7487eceffb/b33e9/aws-cloudfront.png"
        srcset="/static/e3170a7ac6872a024aec5b7487eceffb/f1223/aws-cloudfront.png 163w,
/static/e3170a7ac6872a024aec5b7487eceffb/593bc/aws-cloudfront.png 325w,
/static/e3170a7ac6872a024aec5b7487eceffb/b33e9/aws-cloudfront.png 650w,
/static/e3170a7ac6872a024aec5b7487eceffb/a1e87/aws-cloudfront.png 975w,
/static/e3170a7ac6872a024aec5b7487eceffb/89a59/aws-cloudfront.png 1300w,
/static/e3170a7ac6872a024aec5b7487eceffb/c2bec/aws-cloudfront.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>다음 과정은 링크 테스트인데, 이는 다른 곳에서 클라우드 프론트를 통해 나의 S3안에 있는 파일에 접근할 수 있는지를 확인하는 것이다. 이를 html로 다음과 같이 나타내보자.</p>
<div class="gatsby-highlight" data-language="html"><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    My CloudFront Test
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>My text content goes here.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://domain name/object name<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my test image<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre></div>
<p>My text content goes here.</p>
<p><img src="http://d2wo4ppcmoy2ow.cloudfront.net/440321838.png" alt="my test image"></p>
<p>html의 문법을 마크다운에서도 사용할 수 있으니 직접 삽입해봤는데, 잘 나오지 않는다. 그 이유는 경로가 제대로 설정되지 않았거나, 마크다운에서는 부를 수 없다거나, 처리가 이루어지기 위한 생성 후 20분 ~ 40분의 시간이 지나지 않았기 때문일 것이기 때문에 우선은 가장 후자의 경우를 산정하여 마냥 기다려보기로 하자. 만약 이 글을 읽고 있는 와중에 위의 이미지가 잘 나온다면 제대로 경로를 설정한 것이고, 마크다운에서도 사용 가능하다는 것을 의미한다고 이해하도록 하면 좋을 것이다.</p>
<blockquote>
<p>일정 시간이 흘러도 나타나지 않아 오류 메시지를 확인해보니 "AccessDenied"라는 오류가 발생하고 있었다. 이는 접근할 수 있는 권한이 없다는 의미인데, 이는 설정에서 JSON-based access policy의 설정을 변경해줘야 한다. 하지만 이는 돌이킬 수 없을 수 있으니 그냥 나중에 EC2에서 각자의 AWS 계정에서 파일을 불러오도록 하는 것으로 방향을 바꿔야겠다.</p>
<p>만약 S3의 파일을 공개하고 싶다면 S3 버킷을 설정할 때 봤던 권장사항들의 일부를 변경해주어야 한다. 이 점 참고하길 바란다.</p>
</blockquote>
<p>여기까지 클라우드 프론트를 설정했다. 하지만 우리는 우리의 서비스가 하나의 아키텍처로 동작하는 것을 바라고 있다. 이제부터는 이를 위해 EC2와 RDS를 설정하는 작업을 진행할 것이다.</p>
<p>EC2의 경우에는 웹 서버와 애플리케이션 서버로 나누어줘야 하지만, 서비스가 없는 상황에서는 무리한 것 같아 간단하게 1개의 EC2를 index.html에 위의 문장을 삽입해 띄울 것이기 때문에 크게 어려움을 느끼지 않아도 될 것이다. 더불어 RDS에서는 MySQL을 사용해 데이터베이스에 파일의 id와 S3 주소를 저장하는 것으로 사용을 마무리할 것이기 때문에 역시 어렵지않게 이해할 수 있을 것이다.</p>
<p>우선 Auto Scaling과 ELB를 설정하도록 하자. 이를 위해서는 EC2 인스턴스를 만들어야 하는데, 그 과정은 <a href="https://aws.amazon.com/ko/ec2/getting-started/">Amazon EC2 시작하기</a>의 2번 과정인 "2단계: Amazon EC2 인스턴스 시작"부터 진행하면 된다.</p>
<blockquote>
<p>그 과정에서는 Auto Scailng Group을 만들 수 있는데, 이는 아래의 이미지를 통해 찾아보고 이를 설정하도록 하자.</p>
</blockquote>
<p><a
    class="gatsby-resp-image-link"
    href="/static/4ee2830543a9829f432ba125659b15fe/a21cd/aws-ec2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 9.28923293455313%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAXElEQVQI13WLSwrAIAwFvf8xBVEolLSYpH7g1eeqmy6GhMkkpJRAcs6IMaKUAjNDrRXuBjeiyylUdXvOL3T84R567xCRzRgDc0601jaXPjhvxyErNsdcd/bs/ngBgM+ajtj3XlwAAAAASUVORK5CYII='); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-ec2"
        title=""
        src="/static/4ee2830543a9829f432ba125659b15fe/b33e9/aws-ec2.png"
        srcset="/static/4ee2830543a9829f432ba125659b15fe/f1223/aws-ec2.png 163w,
/static/4ee2830543a9829f432ba125659b15fe/593bc/aws-ec2.png 325w,
/static/4ee2830543a9829f432ba125659b15fe/b33e9/aws-ec2.png 650w,
/static/4ee2830543a9829f432ba125659b15fe/a1e87/aws-ec2.png 975w,
/static/4ee2830543a9829f432ba125659b15fe/89a59/aws-ec2.png 1300w,
/static/4ee2830543a9829f432ba125659b15fe/a21cd/aws-ec2.png 1421w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>저기서 파란색 버튼을 누르게 되면, 인스턴스 생성 이후에 자동으로 Auto Scaling Group 생성으로 넘어갈 수 있다. 여기에서는 그룹 이름과 서브넷을 설정해야 하는데, 서브넷은 되도록 인스턴스와 같은 곳으로 설정하는 것이 좋을 것 같다. 그리고 나서는 Key의 Name을 추가한 뒤 나머지는 기본 설정으로 하고 넘어가도록 하자(Auto Scaling 설정에서 인스턴스 수의 Min과 Max를 조절할 수 있다. 만약 필요하다면 자신에게 맞도록 설정하도록 하자).</p>
<blockquote>
<p>ap-northeast-2a에 EC2 인스턴스가 있다면, ap-northeast-2a로 서브넷을 설정하는 것이 혹시 모를 위험 요소를 배제할 수 있고, 직관적으로 구현할 수 있을 거라고 생각하기 때문이다. AWS의 일부 서비스는 가용 영역이 달라지면 서로 연동되지 않는 것들이 있다는 점을 유의하도록 하자.</p>
<p>더불어 만약 인스턴스를 먼저 만들고, Auto Scaling 그룹을 따로 만들고자 한다면 Security Group에서 Auto Scaling 설정에 대한 그룹을 생성해주면 된다.</p>
</blockquote>
<p><a
    class="gatsby-resp-image-link"
    href="/static/94d1d6c91600ad921e2c3356d16be476/c2bec/aws-auto-scaling.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABUklEQVQoz62QaUsCURSG7w8PohDUNHPLTCP60KcWKcXMLXMBg/5HIDSL4+gs3uvbXZpSshLqMA/3zOGc9ywkmjhEJJZEZD+LWCqPdOEc4WQRoXgOW+E0dvey2I5msMPfUJznJnKSRLaIzPEZUkeniKULiGdOED3IgwAMvmNLLEOD67r4ixHfn2M+p3BcD6PRCJqmwbZtjMdjKU4plTDGOMIX+QFUviLGqPLJsrrv+zAMA47jwDRN6LqOyWQi47MZj9kuHJ8BiwX/1kNEZ9VFTTKdTj8ExZSigWVZ0AwTL68m7Jk6iSheu7LnebJACAUmktWKCrUyxULCvp1OTrisHgR/sx8Fl382KVjN+5pLgttRyvDpb448y7uY8An+2UinN8Tj4AmD4TOanT5uqw2Uay2U75qr8Nh9q4v6Qw8NTr3dRa3dx3WlgYtSGZelCq5uqngDuH08B3M8ZdgAAAAASUVORK5CYII='); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="aws-auto-scaling"
        title=""
        src="/static/94d1d6c91600ad921e2c3356d16be476/b33e9/aws-auto-scaling.png"
        srcset="/static/94d1d6c91600ad921e2c3356d16be476/f1223/aws-auto-scaling.png 163w,
/static/94d1d6c91600ad921e2c3356d16be476/593bc/aws-auto-scaling.png 325w,
/static/94d1d6c91600ad921e2c3356d16be476/b33e9/aws-auto-scaling.png 650w,
/static/94d1d6c91600ad921e2c3356d16be476/a1e87/aws-auto-scaling.png 975w,
/static/94d1d6c91600ad921e2c3356d16be476/89a59/aws-auto-scaling.png 1300w,
/static/94d1d6c91600ad921e2c3356d16be476/c2bec/aws-auto-scaling.png 1440w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
  </span>
  </a></p>
<p>인스턴스를 만들었고, ssh를 이용해 콘솔을 통해 인스턴스에 접근했다면, 홈 디렉터리(ssh로 접속한 바로 그 지점(~))에서 index.html이라는 문서를 만들어 앞선 html을 입력하도록 하고 각자가 원하는 웹 서버(필자는 nodejs로 만들 것이다)를 실행하도로 하자.</p>
<p>이제 대망의 ELB 설정이 남아있다. ELB를 설정하기 위해서는 EC2 내에서 Elastic IPs로 고정 IP를 발급받아 만들어진 인스턴스에 적용하고, Load Balancers로 로드 밸런싱을 통해 유입에 따른 인스턴스 설정을 해주어야 한다. 이 작업은 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/classic/elb-getting-started.html">자습서: 클래식 로드 밸런서 생성</a>를 통해 진행하도록 하자.</p>]]></description><link>https://rayleighko.github.io/blog/2019-02-27-aws_ac_web_03</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-27-aws_ac_web_03</guid><pubDate>Wed, 27 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;AWS - Architecture study: WEB APPLICATION HOSTING&lt;/h1&gt;
&lt;p&gt;일단 이 글을 읽는 이들은 다음과 같은 조건을 충족했다고 가정한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_2&quot;&gt;이전 글(이론)&lt;/a&gt;을 읽었다.&lt;/li&gt;
&lt;li&gt;AWS 계정이 있다(Free tier가 아니여도 무관하다).&lt;/li&gt;
&lt;li&gt;루트 계정이 아닌 유저 계정으로 콘솔에 접속했다(루트 계정은 이메일로 되어있는 계정을 말하고 유저 계정은 관리자가 정한 계정을 말하는데, 루트 계정으로 작업을 하게 되면 보안에 취약할 수 있으니 반드시 유저 계정을 따로 생성하길 바란다).&lt;/li&gt;
&lt;li&gt;과금이 발생할 수 있음을 인지하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 우리는 다음의 5가지(크게 7가지) 서비스를 사용해볼 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EC2(ELB, Auto-Scaling)&lt;/li&gt;
&lt;li&gt;RDS&lt;/li&gt;
&lt;li&gt;S3&lt;/li&gt;
&lt;li&gt;CloudFront&lt;/li&gt;
&lt;li&gt;Route 53&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 어떻게 구현하면 좋을지 생각해보자. 먼저 EC2를 만들고, html로 랜딩 페이지를 띄우고, 이를 ELB로 로드밸런싱할 것이다. 더불어 S3에는 이미지를 저장하고, 이를 CloudFront로 정적 이미지를 제공해줄 것이다. 이때 데이터베이스는 RDS에서 MySQL로 제공할 것이고, 결과적으로 오토 스케일링이 가능라도록 구현하고자 한다. 나는 이를 가장 쉽게 설명하고 있는 &lt;a href=&quot;https://aws.amazon.com/web-applications/gsg-webapps-linux/&quot;&gt;Getting Started with Linux Web Applications in the AWS Cloud&lt;/a&gt;을 따라 만들어 볼 것이다!&lt;/p&gt;
&lt;p&gt;만약 필자와 같은 선택을 할 것이라면 본격적으로 실습을 진행해보자. 내가 이 글을 쓰는 지금(2019. 02. 26)의 AWS 콘솔의 첫 페이지는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9608e87e453c04fc6a5d7f2da593ecca/c2bec/aws-main.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABsklEQVQoz31S7W7UMBC8RweE1PaActeCeuIPT4ZUlct3nNhJnDh2kmF3j6ZqQI00yq7tHe/Mend9+w2fjw+4OTzg6vY77k4/saf4w80R766+4v31QeIt+OyX+x/4dDxJvD+c8HF/hx3oC1NAmqYoVYkojiVWlZI8z3PZf/tb/gLY1VqjqmskRJLlBZqmvaC9/I1p0LYd2u4FpaoQJ4nU5FTD+xcejZ1pGinOqBNVVXDjiNF7zPMsWJZljZ9RUwMxKfkdxaQogXOjXMRcK2FnrSzy3zmHkYjDNGEigi20NtRdhlRpaFLRD4NwrIRM1PeDSBwG93+HlpeYbYiiCJbqQgjSwCtCTmrSzz6w5IFuFNBBhtuAPf/1+IRznKIim1jNKvmZOU4yPD6didSIyU3Xi5fej3SJR08+9dQ9rxljEGeFyJ3oBbCv/3SoDE3Kegx+pq48okKjtYPILDQNre5gx0mGxJJjGkZRlChpbxjD66HwIJIkJR+tEFjKz+dofVspDUCV6uIhE1INn287K0q83xByonQDS53NxOHDBN32cGGW3LSWcrsh5HeYI8pK8tCvhH8AcBk4zjJ6gG8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-main&quot;
        title=&quot;&quot;
        src=&quot;/static/9608e87e453c04fc6a5d7f2da593ecca/b33e9/aws-main.png&quot;
        srcset=&quot;/static/9608e87e453c04fc6a5d7f2da593ecca/f1223/aws-main.png 163w,
/static/9608e87e453c04fc6a5d7f2da593ecca/593bc/aws-main.png 325w,
/static/9608e87e453c04fc6a5d7f2da593ecca/b33e9/aws-main.png 650w,
/static/9608e87e453c04fc6a5d7f2da593ecca/a1e87/aws-main.png 975w,
/static/9608e87e453c04fc6a5d7f2da593ecca/89a59/aws-main.png 1300w,
/static/9608e87e453c04fc6a5d7f2da593ecca/c2bec/aws-main.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서 예제의 처음에 등장하는 S3 버킷을 생성해보자. 예제의 영상은 오래 되었지만, 그 동작은 변함이 없다. 검색란에서 S3를 검색해 &apos;aws-webapp&apos;이라는 bucket을 서울 리전에 만들어보자(S3는 생성 시 리전을 고를 수 있다).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./assets/aws-s3.png&quot; alt=&quot;aws-s3&quot;&gt;&lt;/p&gt;
&lt;p&gt;Create bucket을 눌러 아래와 같이 &apos;aws-webapp&apos;이라는 버킷을 만들자(버킷은 이름의 중복을 피해야 한다. 가령 다른 사람이 aws-webapp을 사용하고 있다면 그 이름을 사용할 수 없다. 그래서 나는 aws-webapp-mj라는 버킷을 만들었다).&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/55a3692a6246c0c11e677f616a78d37d/c2bec/aws-s3-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACH0lEQVQoz32R+U4aURTGebA2TaFCm6al1ZBitRorUDvDYpCGZQSVTQcG44zKUPZNLWAjmyglvkBfoC+goU36Dl/vHcR00f7xy3fPnHu/fOeMivWF4eDCMHIiJnwynnIp6Nz70KyIeOjcIYjQfZAU1M7RNzXp0b7GJUHrkaFlQ9DOLEH9ygzVQbuPWqsHX/8bXl/8hLF9Cf3JJV42rzDdHWK2N8T82XfMEYyknjkdKr0XBGPnCvr2D5gPvyKWLiORP4IqW2ui1GjDuZ2DYVWEgSa1RxQeO6IKGltEQXddj/tPlqNQW8OwxTKonw5Q6w6gytebKBx3wPh5uEICgmIaPl4CF5MUHZ//qYn6hT1Y/VGw/i1UmueoNs/IyK1zHHW+wLaRACfI2JSL4D+WCRUyBqV6rePzqOYJidwhvPEkmHUB+ZM+qJdiWCNxHcEE7BsCuPg+1nbSCqsJ+U44Ar1D3zBrccWwemNIZreThDRdvt5CstJAjqhUqkEq3o5Y/IRk9RjrZEXM2t8Ju6OEXpJOyFSxlSohTkfKHtwJvUdN/dspvP/dkC6SGrIBHvcMJkzMWfHoDQvN7P+hdx5ML+G+YRFmbwSZz73RT6n3LtAgBMQsLAEBk4wbU4yH6G24b/rPLS6wZE2mcArm4C7KnQGol4pPFhCTC3BvSjC5w3i2YId+cflP3o500rKiMPXOpdQWTwjz3hgWvDwie3lEdrP4BXgVOQ1p1OK3AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/55a3692a6246c0c11e677f616a78d37d/b33e9/aws-s3-2.png&quot;
        srcset=&quot;/static/55a3692a6246c0c11e677f616a78d37d/f1223/aws-s3-2.png 163w,
/static/55a3692a6246c0c11e677f616a78d37d/593bc/aws-s3-2.png 325w,
/static/55a3692a6246c0c11e677f616a78d37d/b33e9/aws-s3-2.png 650w,
/static/55a3692a6246c0c11e677f616a78d37d/a1e87/aws-s3-2.png 975w,
/static/55a3692a6246c0c11e677f616a78d37d/89a59/aws-s3-2.png 1300w,
/static/55a3692a6246c0c11e677f616a78d37d/c2bec/aws-s3-2.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Copy할 버킷이 없으므로 다음으로 넘어가자. 다음으로 넘어가게 되면 다양한 속성들을 설정할 수 있는데, 만약 사용할 기능이 있다면 체크해도 좋지만 나는 여기서 따로 사용할 기능이 없기 때문에 Tags에 Name이라는 key를 webapp으로 만들어주고 다음으로 넘어갈 것이다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c2f24c16a02dbe2053ee7193fe516139/c2bec/aws-s3-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.41666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQoz3WS61JSURiGubLKKdJJ2BxK85BycLNRwA2CbN2bRBFCDuIopWQcdEINyDEYCDVzxgvoBrqAzKY/3cHbtxb2y+nHM2t9a6/9zLu+tXReNQF/JIGhyCYeqgUMaAXolW30Bbdwb24T9wn9fJ7zgNZYzUZGXyiPR4u03xuHfmwafcMidEftL6i3uli5/A7b1R+Mdq5hbv7AcPsnJk9/cWxnPUY/3+BF9wbW1jUsBNtr6fyGu/YN2WIVG3s16Er1JvYaLcTe1SDnD+DOVOBIFiGmSpDSZbgJ51oZDkJKV/h3MVXmsLk9WUJk5wj1DgXrXEBXaZDwYxueaAYuJQaRGJc1QsXzWRWmmQUIYgDClB9GZw827xHAwKQXvmgK1eYZDpqn0B22zvCBjj27msNYYAkOJY5R/xKsXhWPJQV6RwAGMQSD6y5GaR79dj9mltdRaZ7jgFxcyKIGSJjeraJMaXOlQ8R39pHdqyOWL8LsDmNwag5GMUjyIB+NJBRIOGCXSZi9K5RjOWy8P8Hu8SmcC3HYwzG4tSSfW2cU/rNBClOqME/WE4b+L/RTQokEvuUMhmc1zpBPxTNihFpg8WoweFQIhGF6gSflCR105CgJP90KWSNr1EM5to6J0Aq/HBulY8IROQKrT+MCwUUCluofJBt0BtA/4YFLfYXicbd3KY3uV5ycX0GmhE+mgpRKg4Vu1kR9M00rMBMWBq2Zb2sGE/oS27CtvoUUf41q+wKN7iV0a28qyBT24X2ZhFmcg0BHEOhpmOhJmJw9eE1YKaWV+vaUYHslNYVxJQ3H4hri+TISW0X8BXvWH610XH6FAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/c2f24c16a02dbe2053ee7193fe516139/b33e9/aws-s3-3.png&quot;
        srcset=&quot;/static/c2f24c16a02dbe2053ee7193fe516139/f1223/aws-s3-3.png 163w,
/static/c2f24c16a02dbe2053ee7193fe516139/593bc/aws-s3-3.png 325w,
/static/c2f24c16a02dbe2053ee7193fe516139/b33e9/aws-s3-3.png 650w,
/static/c2f24c16a02dbe2053ee7193fe516139/a1e87/aws-s3-3.png 975w,
/static/c2f24c16a02dbe2053ee7193fe516139/89a59/aws-s3-3.png 1300w,
/static/c2f24c16a02dbe2053ee7193fe516139/c2bec/aws-s3-3.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음으로 넘어가게 되면 다시 한 번 체크 박스가 나온다. 여기서도 사용자의 필요에 따라 체크를 하지 않을 수 있지만, 권장 사항이기 때문에 체크하고 넘어가는 것이 바람직할 것 같다. 더불어 Manage system permissions는 S3 로그 전달 그룹(Delivery group)에 이 버킷의 로그가 쓰여지는 것을 허용할 것이냐는 말인데, 지금 당장 로그 정보가 필요없으니 허용하지 않고 넘어갈 것이다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/52e6474dec63308124774db90162e8bf/9ddb8/aws-s3-4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.82865168539326%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACc0lEQVQoz22S2VIaQRSG582SWMHEJSKYGFkVFQVUlhkGRkAWkV0FxGUiJZZRXNAqBAUTTVJ5iuQ+idGbPMOf02NSpVVefH1O93R/fU7XcFOzC3AF43gbLOB5QEZ3UMYLaR0dwgqeeIp4yheh8q6gU1xRcrb2jL+D7VH516Fy56AyOtAxaAVXPbtErdFC7Oo79F/+4E3jJ3pOfkBT/wVT6wZDZ79hoDh8cQtj+0ZB27hGX/0ag81raJq3MNS+IVWuYqlyAK58eIqd4ybEQgWD4RLMcRn62AaM8zJMsTXoIqtQS3l08Vn0iTmoxUX0eHPoFnI0X1TWTdFVVBsfcHR+BW6bZLv1NqYj9MEVgDOcxlQooTAsRKCbkWB0StBP+6GnfGjKDx3LCYNzFhqrB0ZXEJWTc+yeXoDbo2G/+RHOeB4jvjgckRxscxnYwlmMhjIwinFoHXTQ7lfo/xcZWoeEXqsAAx/Fu+MWdqlKjpV63P4EPlFQhLa5NCaDKdgpWgNJjEkL0NGB7jEPesf5B7wiWdeom4SRh8Ja654wlMZEgAkzGPEnoLZRNTYf1JM+OuzBS4sLXRY34VJkneaZR4RUoWchT6IkBBKz3E7iUd+8UuE4YzYBszcGE72rSYgqcZjmevccTBTl2vmdkL3hUesK7vgyfKkiFjffI72xjdR6Bcm1LYWsvINCZR/F7YN7HCK/VUWiVIZFjKJUPb0THlG79cuvSsusBY2dtSdSqyL6qdX/KGv3YO834k/DEqFfS8pi86SFw/ZncMvlPZToxplwBv1WHgOTXmgnhEcZsHnxmi5iaGivPZTFdFKGQcohtbGDJXL9BdYdJQBg6TCVAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/52e6474dec63308124774db90162e8bf/b33e9/aws-s3-4.png&quot;
        srcset=&quot;/static/52e6474dec63308124774db90162e8bf/f1223/aws-s3-4.png 163w,
/static/52e6474dec63308124774db90162e8bf/593bc/aws-s3-4.png 325w,
/static/52e6474dec63308124774db90162e8bf/b33e9/aws-s3-4.png 650w,
/static/52e6474dec63308124774db90162e8bf/a1e87/aws-s3-4.png 975w,
/static/52e6474dec63308124774db90162e8bf/89a59/aws-s3-4.png 1300w,
/static/52e6474dec63308124774db90162e8bf/9ddb8/aws-s3-4.png 1424w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 지금까지의 설정을 확인하고 되묻는데, 여기서 제대로 설정했는지를 확인하고 생성을 마치도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bfd7adee2c7548bb808b1704a41bb866/c2bec/aws-s3-5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.27777777777778%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABkklEQVQoz62Qy0sCURTG568qInpQLoIkogcRQhgUtK516xatWkQEQX9DQi/LTDMsIiHKsvDZKs2hcWac0Xl9nXvVUqMI6sBvznfO/c6ZmSusrm1gfXMbS8sr6BudwdT8ItyeBbgmZjE47sXAmJdyTbvquZt8HW4Puoan0TPiQS/V/ZNz6ByagoB6lCtVxOIJ3NzF8ZjOIpF5xiORSD9zzUnnOPepHG6TGdw+pRB7SCIaT+LyIUV1GkJRFCESLHTTRraoQNYq+E1UKzocx27pCZL0hnxRhGHZyIgatqI5XGdfYZBZVlWUNQ0qoelUKypUvQLDNEkrHKlUwks+D4W8Fu2gX3a4YAsBG5auQJUlVA0Dtk21ZX3AFrxJJag0XJJlnhXq5QsFqOUyfa3zeYdUwSZMWmyaFj9sD9ZjL2E0dLOPL2QP1qtl58uCZn6KhkdoGNuH2/vfedrPhdr9tN7VXxDwzyEEw1GEIheIRK9wFDzDzq4fvv1j+PaO6tQ19Q4CIRyehOEnDkn7yc8ymwucnnP9Dt5XJ4/nx/LXAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/bfd7adee2c7548bb808b1704a41bb866/b33e9/aws-s3-5.png&quot;
        srcset=&quot;/static/bfd7adee2c7548bb808b1704a41bb866/f1223/aws-s3-5.png 163w,
/static/bfd7adee2c7548bb808b1704a41bb866/593bc/aws-s3-5.png 325w,
/static/bfd7adee2c7548bb808b1704a41bb866/b33e9/aws-s3-5.png 650w,
/static/bfd7adee2c7548bb808b1704a41bb866/a1e87/aws-s3-5.png 975w,
/static/bfd7adee2c7548bb808b1704a41bb866/89a59/aws-s3-5.png 1300w,
/static/bfd7adee2c7548bb808b1704a41bb866/c2bec/aws-s3-5.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음으로 예제가 설명하고 있는 것은 CloudFront인데, 이 동영상의 링크가 잘못된 것인지 EC2를 생성하는 예제를 설명한다. 따라서 나는 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html&quot;&gt;CloudFront 시작하기&lt;/a&gt;라는 AWS CloudFront 튜토리얼을 읽어야만 했다.&lt;/p&gt;
&lt;p&gt;우선은 CloudFront를 사용하기 위해선 앞선 설명처럼 S3의 버킷이 생성되어 있어야 하고, 컨텐츠가 업로드되어 있으며 객체 권한이 부여되어 있어야 한다.&lt;/p&gt;
&lt;p&gt;이를 위해 해당 문서의 &lt;strong&gt;Amazon S3에 콘텐츠를 업로드하고 모두에게 읽기 권한을 부여하는 방법&lt;/strong&gt;을 따라 S3의 설정을 진행하도록 하자. 우리는 &quot;6. &lt;strong&gt;버킷&lt;/strong&gt; 창에서 버킷을 선택하고 &lt;strong&gt;업로드&lt;/strong&gt;를 선택합니다.&quot;부터 진행하면 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/8815065789df870264505531a319bd98/c2bec/aws-s3-6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACXklEQVQoz2WS61MSYRTG+cOraaYmtQkzSzNrmuky0wdNLS3RLiMoBZIMiiKKyk1gAYGFBXZhF36dfcM+1M48ey7veZ9zznuOZ3xyhrGHs0xMz3PXO8Pcy7fMPn+F9/E8D6ZdPBtB9EdzeEXe8z7h9viUyBkmpp4yNjmr5J3703gYfY7dk1+f4F6MtWCEzR8RfIGf+EJRfGKvi74RjrEaCJMtaurOkP8/j2n1+JVvEcrq7GSaBA5S7MWP2dlPEj1MEjtOEUucEjs6YT95RvQoiVap4jgOpmXRaOiCBp1uF6vXwzMYDtnXOuwVO/zMG5Q6A2zJ1HZAalZ6fySv0ZWzpuUoXBmmgm72VcWK0Og51E0bXQIqnT4lo89lo0O6opOuNslctQTGH1uQq7cpt20qwly1hpQ77j0bl0sR1ro2mpBoRk8C++rQlVrLoiy+kshSw1D6tc+NKUjSrFYV26L6L2FFssQzJWIXBbQRqZtAl/YWlj/yej2AZkFFzqrdAZdS5Y2bt5h8s0TBsLn6SzgYSrtSujkgVaqxFU2QlRarbjsCTbK/W1xiMRgnb4hPnsSNLehdFj6ssRJJid9WRSlCxxmgNbscpQscnGU4PM+RLjfkXWzydYP4eZ7jbJGTdJ5E+lI9Ra7WInaaIZEpkLzIET/LSoIOLpfaQ2OAqqYsmcvmkJa02RZ/U6QuI3YnX+wOaYjeklHWZBBFIcjrJpr4672hilV7GIpE2ZLlDUQOZJF3ee/zs7IZYHnDLwiw+nWbFyvfmVv6hs8f4vNWSOLCbGzvqvhPYrv6l50I/mCY30sFGVrRy2xPAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/8815065789df870264505531a319bd98/b33e9/aws-s3-6.png&quot;
        srcset=&quot;/static/8815065789df870264505531a319bd98/f1223/aws-s3-6.png 163w,
/static/8815065789df870264505531a319bd98/593bc/aws-s3-6.png 325w,
/static/8815065789df870264505531a319bd98/b33e9/aws-s3-6.png 650w,
/static/8815065789df870264505531a319bd98/a1e87/aws-s3-6.png 975w,
/static/8815065789df870264505531a319bd98/89a59/aws-s3-6.png 1300w,
/static/8815065789df870264505531a319bd98/c2bec/aws-s3-6.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;업로드 시 유의해야 할 사항은 읽기와 쓰기 권한의 설정이다. 필자의 이미지는 S3를 필자의 AWS계정에서만 사용 가능하도록 설정할 것이다. 더불어 여기서는 암호화 또는 태깅과 같이 객체에 원하는 속성을 설정할 수 있는데, 이는 사용자가 알맞게 사용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/afe834832c776264de2bd9968c862d69/c2bec/aws-s3-7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACcUlEQVQoz22SW08aURSF+WV9qK2VaoNotGm1iRpBURQBYYa7OiPKdUSu4giViyilIl4ASZs2aZs+WPVZrW/9H6t7Bppo0oeVtXdmznf25ShmbTz0Ng7DzgiUrjRUnm0obUk8t8TQtRglj0LJxNBD6rK0825r218wcfTYUxhmw5iz85hmOChKZ59QPmnCcnwN9ekf9Fbu8axwC1X5HuoPUnyDvv07yn/Lrizd4Wn+Bt3FW/SVbvEkf4eZgwuZsXfSgiJXrWM9d4TQ4RdEzn4iVPuBQPUbhNp3xBoXiJ9fIdL4hWjzEsnWFeWXchwjT0hx6xqJ2lfsVo4hsRTFWhPh0inc8V14k7vwRESwgQRswSTs4TQcQhouYQtOckd4S5az49I3WzAln8tWGyjWztvAXK2F2aUgxphVEo83C268M7mhYVYwYnRhxhOA1unDW6MHI6aOKB41L2FIb8e024+d6jkKxJKBGUrmVgRMsDwm7WsEc2GYCWA0XMGgeQ0jC04ZptYxGJiRxGKA4kHyVxqzXEzm6BGwCdPaJphOq6w/Dj0XwVxAhG5ZgJEXYOA3oPME5Wr/SU8gDRUwzwlUYRPFh0CLLw5vfAfBdA7+FM0zJoKPpOBLZhHe2ZMlZB5r8/0+fFs5OhuDeNgBFo4aED/WobV70TthgHraiv4pi+xqXVtSe/+TSruIl+MGaB1ebFfqkFiKA3qH+WNail+Eit2guXRm9EDS7PofwugfFV0qbXkqUIBmdRt5eoPl+mco1hNZajUrt6xx+DFm9mB8cakt2uIE+WuDG0Pz0ta5tlgOk9YVLCyHaJYhGLgNcNEMVqMi/gJN3juep+pe0gAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/afe834832c776264de2bd9968c862d69/b33e9/aws-s3-7.png&quot;
        srcset=&quot;/static/afe834832c776264de2bd9968c862d69/f1223/aws-s3-7.png 163w,
/static/afe834832c776264de2bd9968c862d69/593bc/aws-s3-7.png 325w,
/static/afe834832c776264de2bd9968c862d69/b33e9/aws-s3-7.png 650w,
/static/afe834832c776264de2bd9968c862d69/a1e87/aws-s3-7.png 975w,
/static/afe834832c776264de2bd9968c862d69/89a59/aws-s3-7.png 1300w,
/static/afe834832c776264de2bd9968c862d69/c2bec/aws-s3-7.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음으로 넘어가면 다시 여러 속성을 만날 수 있는데, 나는 기본 세팅 그대로 설정해주고 넘어가도록 할 것이다(지금 당장 필요가 없는 설정이기도 하고 귀찮기 때문).&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3ec0d347303704bf9a94f2ed8e825901/c2bec/aws-s3-8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABuklEQVQoz61RTUscQRCd3xovboK7RvxOgrjGGNcRPyIk8Rd4UW+CMUGTQPCSmwdRQRFk2XV3pudrZ6ane16qeseRCAs5pOB1ve4u3quutuyNT3i3zviM+vImltY+om5vYXbBxvR8AzOc6yt/8bmlNbylmvdUa3/YRoM07M1tLK5uwUIZuVlPTn9j58sP7H/9id3DY+wd/8Lutz7f/36KncMTXN81MSisNJW4vfdw0xa4ajpodly4joOOIxD1YvR6vT7iRx4nCZIkJSSIouKM7mWWwVI6x9Glg4PzLvbOOrhoB5AyRTdKkWYKSmsopZCpPte5NpzBAl0yb7VaxjDPc3oyLTolh9ADtITKJOKUxEiUO2EeUXGr3YbreQijCK4Q5s7zfSPIYgnVGUFeYmrfER4CKjbu5Cwz9diJlAjCsERET+RzFmIDBndbCjIevkUX+6d4Gua8yNyALvaWprnkA0T+FaWBmeF/DisMAwgasuN04fs09CBAEPgGPn2C54kSQriD4fazNb/YwOSrOYxPv8HY1GsMV8fxvDaBCuWhSg3PhqsYYlSqqNTobnTCgPmLl0UencTI2JThfwDGVxs9oLuAmAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-s3&quot;
        title=&quot;&quot;
        src=&quot;/static/3ec0d347303704bf9a94f2ed8e825901/b33e9/aws-s3-8.png&quot;
        srcset=&quot;/static/3ec0d347303704bf9a94f2ed8e825901/f1223/aws-s3-8.png 163w,
/static/3ec0d347303704bf9a94f2ed8e825901/593bc/aws-s3-8.png 325w,
/static/3ec0d347303704bf9a94f2ed8e825901/b33e9/aws-s3-8.png 650w,
/static/3ec0d347303704bf9a94f2ed8e825901/a1e87/aws-s3-8.png 975w,
/static/3ec0d347303704bf9a94f2ed8e825901/89a59/aws-s3-8.png 1300w,
/static/3ec0d347303704bf9a94f2ed8e825901/c2bec/aws-s3-8.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이로써 필자는 S3에 파일을 업로드할 수 있었다. 이처럼 업로드가 완료된 파일은 URL을 통해 접근할 수 있는데 필자의 경우 다음과 같은 URL로 파일에 접근할 수 있을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;s3://aws-webapp-mj/40321838.png&lt;/p&gt;
&lt;p&gt;혹은&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ap-northeast-2.amazonaws.com/aws-webapp-mj/40321838.png&quot;&gt;https://s3.ap-northeast-2.amazonaws.com/aws-webapp-mj/40321838.png&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음으로는 CloudFront 배포를 만들 것이다. CloudFront 배포를 만들려면 문서의 과정을 거쳐야 하는데, 그 중 가장 먼저 할 것은 CloudFront의 콘솔을 열어 &lt;strong&gt;[Create Distribution]&lt;/strong&gt;을 선택한 후, [&lt;strong&gt;Select a delivery method for your content&lt;/strong&gt;]의 [&lt;strong&gt;Web&lt;/strong&gt;] 섹션에서 [&lt;strong&gt;Get Started&lt;/strong&gt;]를 선택하는 것이다. 이 과정은 내가 따로 적을 필요없이 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html&quot;&gt;문서&lt;/a&gt;에 매우 잘 나와있기 때문에 문서를 참고하도록 하자.&lt;/p&gt;
&lt;p&gt;나는 S3를 설정한 것 외에는 전부 기본값을 사용해서 다음과 같은 CloudeFront Distributions(배포판)을 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e3170a7ac6872a024aec5b7487eceffb/c2bec/aws-cloudfront.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.486111111111114%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABYklEQVQoz62Q60sCURDF7//dhyg0RC0tzSLo38goUCsfSWIQJIbu0i5sWj5287Xr89e9ViB+SujAMIeZueeeGbHtC+IPRogmzgkdHBGLn7IXOmRrN8hOIIo/HMcXiuH/CcV9we8ciJywHzsjfHRG5PicwEECwQpunt9Jli2MZpee02Exn/EnLBa47kgRRL/fp93uMBq5VOom2YcnKi816ppOra6haRq6rtNsNrGsN0zT5NUwMAxzyTVdo1qtUi4/yr6FaLVaNBoNZrMZ04knnXXxXBfro0ur+4njOPLDNoPBQLpwsW2bXq+35I4te3Yb27FROsPhEKEGPM/7ds7mUEY812M8HsvN5cqKTKdT5vP5srBprGPpUNmdTCY/991MbL0mlJC6h7K+OrQJVt+J31WV4H+E4J8hsoUH8sUSxdIjmbt7Lq7SXF5nSK6FqqVucqRv86TvCqRkzqzk21xR9vN8AShnNRcFdpW0AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-cloudfront&quot;
        title=&quot;&quot;
        src=&quot;/static/e3170a7ac6872a024aec5b7487eceffb/b33e9/aws-cloudfront.png&quot;
        srcset=&quot;/static/e3170a7ac6872a024aec5b7487eceffb/f1223/aws-cloudfront.png 163w,
/static/e3170a7ac6872a024aec5b7487eceffb/593bc/aws-cloudfront.png 325w,
/static/e3170a7ac6872a024aec5b7487eceffb/b33e9/aws-cloudfront.png 650w,
/static/e3170a7ac6872a024aec5b7487eceffb/a1e87/aws-cloudfront.png 975w,
/static/e3170a7ac6872a024aec5b7487eceffb/89a59/aws-cloudfront.png 1300w,
/static/e3170a7ac6872a024aec5b7487eceffb/c2bec/aws-cloudfront.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 과정은 링크 테스트인데, 이는 다른 곳에서 클라우드 프론트를 통해 나의 S3안에 있는 파일에 접근할 수 있는지를 확인하는 것이다. 이를 html로 다음과 같이 나타내보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    My CloudFront Test
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;My text content goes here.&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;img&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;http://domain name/object name&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;alt&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;my test image&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My text content goes here.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://d2wo4ppcmoy2ow.cloudfront.net/440321838.png&quot; alt=&quot;my test image&quot;&gt;&lt;/p&gt;
&lt;p&gt;html의 문법을 마크다운에서도 사용할 수 있으니 직접 삽입해봤는데, 잘 나오지 않는다. 그 이유는 경로가 제대로 설정되지 않았거나, 마크다운에서는 부를 수 없다거나, 처리가 이루어지기 위한 생성 후 20분 ~ 40분의 시간이 지나지 않았기 때문일 것이기 때문에 우선은 가장 후자의 경우를 산정하여 마냥 기다려보기로 하자. 만약 이 글을 읽고 있는 와중에 위의 이미지가 잘 나온다면 제대로 경로를 설정한 것이고, 마크다운에서도 사용 가능하다는 것을 의미한다고 이해하도록 하면 좋을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;일정 시간이 흘러도 나타나지 않아 오류 메시지를 확인해보니 &quot;AccessDenied&quot;라는 오류가 발생하고 있었다. 이는 접근할 수 있는 권한이 없다는 의미인데, 이는 설정에서 JSON-based access policy의 설정을 변경해줘야 한다. 하지만 이는 돌이킬 수 없을 수 있으니 그냥 나중에 EC2에서 각자의 AWS 계정에서 파일을 불러오도록 하는 것으로 방향을 바꿔야겠다.&lt;/p&gt;
&lt;p&gt;만약 S3의 파일을 공개하고 싶다면 S3 버킷을 설정할 때 봤던 권장사항들의 일부를 변경해주어야 한다. 이 점 참고하길 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기까지 클라우드 프론트를 설정했다. 하지만 우리는 우리의 서비스가 하나의 아키텍처로 동작하는 것을 바라고 있다. 이제부터는 이를 위해 EC2와 RDS를 설정하는 작업을 진행할 것이다.&lt;/p&gt;
&lt;p&gt;EC2의 경우에는 웹 서버와 애플리케이션 서버로 나누어줘야 하지만, 서비스가 없는 상황에서는 무리한 것 같아 간단하게 1개의 EC2를 index.html에 위의 문장을 삽입해 띄울 것이기 때문에 크게 어려움을 느끼지 않아도 될 것이다. 더불어 RDS에서는 MySQL을 사용해 데이터베이스에 파일의 id와 S3 주소를 저장하는 것으로 사용을 마무리할 것이기 때문에 역시 어렵지않게 이해할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;우선 Auto Scaling과 ELB를 설정하도록 하자. 이를 위해서는 EC2 인스턴스를 만들어야 하는데, 그 과정은 &lt;a href=&quot;https://aws.amazon.com/ko/ec2/getting-started/&quot;&gt;Amazon EC2 시작하기&lt;/a&gt;의 2번 과정인 &quot;2단계: Amazon EC2 인스턴스 시작&quot;부터 진행하면 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그 과정에서는 Auto Scailng Group을 만들 수 있는데, 이는 아래의 이미지를 통해 찾아보고 이를 설정하도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/4ee2830543a9829f432ba125659b15fe/a21cd/aws-ec2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 9.28923293455313%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAXElEQVQI13WLSwrAIAwFvf8xBVEolLSYpH7g1eeqmy6GhMkkpJRAcs6IMaKUAjNDrRXuBjeiyylUdXvOL3T84R567xCRzRgDc0601jaXPjhvxyErNsdcd/bs/ngBgM+ajtj3XlwAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-ec2&quot;
        title=&quot;&quot;
        src=&quot;/static/4ee2830543a9829f432ba125659b15fe/b33e9/aws-ec2.png&quot;
        srcset=&quot;/static/4ee2830543a9829f432ba125659b15fe/f1223/aws-ec2.png 163w,
/static/4ee2830543a9829f432ba125659b15fe/593bc/aws-ec2.png 325w,
/static/4ee2830543a9829f432ba125659b15fe/b33e9/aws-ec2.png 650w,
/static/4ee2830543a9829f432ba125659b15fe/a1e87/aws-ec2.png 975w,
/static/4ee2830543a9829f432ba125659b15fe/89a59/aws-ec2.png 1300w,
/static/4ee2830543a9829f432ba125659b15fe/a21cd/aws-ec2.png 1421w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;저기서 파란색 버튼을 누르게 되면, 인스턴스 생성 이후에 자동으로 Auto Scaling Group 생성으로 넘어갈 수 있다. 여기에서는 그룹 이름과 서브넷을 설정해야 하는데, 서브넷은 되도록 인스턴스와 같은 곳으로 설정하는 것이 좋을 것 같다. 그리고 나서는 Key의 Name을 추가한 뒤 나머지는 기본 설정으로 하고 넘어가도록 하자(Auto Scaling 설정에서 인스턴스 수의 Min과 Max를 조절할 수 있다. 만약 필요하다면 자신에게 맞도록 설정하도록 하자).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ap-northeast-2a에 EC2 인스턴스가 있다면, ap-northeast-2a로 서브넷을 설정하는 것이 혹시 모를 위험 요소를 배제할 수 있고, 직관적으로 구현할 수 있을 거라고 생각하기 때문이다. AWS의 일부 서비스는 가용 영역이 달라지면 서로 연동되지 않는 것들이 있다는 점을 유의하도록 하자.&lt;/p&gt;
&lt;p&gt;더불어 만약 인스턴스를 먼저 만들고, Auto Scaling 그룹을 따로 만들고자 한다면 Security Group에서 Auto Scaling 설정에 대한 그룹을 생성해주면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/94d1d6c91600ad921e2c3356d16be476/c2bec/aws-auto-scaling.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.347222222222214%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABUklEQVQoz62QaUsCURSG7w8PohDUNHPLTCP60KcWKcXMLXMBg/5HIDSL4+gs3uvbXZpSshLqMA/3zOGc9ywkmjhEJJZEZD+LWCqPdOEc4WQRoXgOW+E0dvey2I5msMPfUJznJnKSRLaIzPEZUkeniKULiGdOED3IgwAMvmNLLEOD67r4ixHfn2M+p3BcD6PRCJqmwbZtjMdjKU4plTDGOMIX+QFUviLGqPLJsrrv+zAMA47jwDRN6LqOyWQi47MZj9kuHJ8BiwX/1kNEZ9VFTTKdTj8ExZSigWVZ0AwTL68m7Jk6iSheu7LnebJACAUmktWKCrUyxULCvp1OTrisHgR/sx8Fl382KVjN+5pLgttRyvDpb448y7uY8An+2UinN8Tj4AmD4TOanT5uqw2Uay2U75qr8Nh9q4v6Qw8NTr3dRa3dx3WlgYtSGZelCq5uqngDuH08B3M8ZdgAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;aws-auto-scaling&quot;
        title=&quot;&quot;
        src=&quot;/static/94d1d6c91600ad921e2c3356d16be476/b33e9/aws-auto-scaling.png&quot;
        srcset=&quot;/static/94d1d6c91600ad921e2c3356d16be476/f1223/aws-auto-scaling.png 163w,
/static/94d1d6c91600ad921e2c3356d16be476/593bc/aws-auto-scaling.png 325w,
/static/94d1d6c91600ad921e2c3356d16be476/b33e9/aws-auto-scaling.png 650w,
/static/94d1d6c91600ad921e2c3356d16be476/a1e87/aws-auto-scaling.png 975w,
/static/94d1d6c91600ad921e2c3356d16be476/89a59/aws-auto-scaling.png 1300w,
/static/94d1d6c91600ad921e2c3356d16be476/c2bec/aws-auto-scaling.png 1440w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인스턴스를 만들었고, ssh를 이용해 콘솔을 통해 인스턴스에 접근했다면, 홈 디렉터리(ssh로 접속한 바로 그 지점(~))에서 index.html이라는 문서를 만들어 앞선 html을 입력하도록 하고 각자가 원하는 웹 서버(필자는 nodejs로 만들 것이다)를 실행하도로 하자.&lt;/p&gt;
&lt;p&gt;이제 대망의 ELB 설정이 남아있다. ELB를 설정하기 위해서는 EC2 내에서 Elastic IPs로 고정 IP를 발급받아 만들어진 인스턴스에 적용하고, Load Balancers로 로드 밸런싱을 통해 유입에 따른 인스턴스 설정을 해주어야 한다. 이 작업은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/classic/elb-getting-started.html&quot;&gt;자습서: 클래식 로드 밸런서 생성&lt;/a&gt;를 통해 진행하도록 하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 아키텍처 - Web Application Hosting_02]]></title><description><![CDATA[<h2>AWS - Architecture study: WEB APPLICATION HOSTING</h2>
<ul>
<li><a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">https://media.amazonwebservices.com/architecturecenter/AWS<em>ac</em>ra<em>web</em>01.pdf</a></li>
</ul>
<p>"AWS Architecture 중에서 가장 기초적으로 구현할 수 있는 모델은 어떤 게 있을까?"라는 고민이 있었는데, 이번 스터디를 진행하면서 그 부분을 해결할 수 있었다.</p>
<p>물론, '구현'을 목적으로 한다면, 더 작은 아키텍처를 선정했을테지만, AWS를 제대로 사용하고, 이를 활용하는 수준을 목적으로 한다면 간단하면서도 각 기능이 원활하게 돌아가는 아키텍처를 선정해야 한다는 생각이 있었다. 그래서 이번 스터디를 기회로 AWS 아키텍처 센터에서 기본적으로 제공하는 아키텍처 중 가장 처음 만나볼 수 있는 Web Application Hosting 아키텍처를 구현해보고자 했다.</p>
<p>일단 위 PDF에 나와있는 서비스 중 전에 사용해본 서비스는 Route 53, S3, ELB, EC2, RDS가 있었다. 하지만 이는 아키텍처를 고려하고 설계를 먼저 한 것이 아니라 필요에 의해서 하나하나 만들었을 뿐이었기 때문에 깊이가 부족하다고 느끼고 있어서 이번 기회에 제대로 알아보려 한다. 아자아자!</p>
<p>설계는 아키텍처 센터에서 이미 제공하고 있으니 바로 구현을 해야 할텐데, 구현에 앞서 우선적으로 각 서비스가 어떤 것인지를 알아보는 시간이 필요할 것 같아서 각 서비스에 대해 스터디한 내용을 살짝 공유해보려 한다.</p>
<h3>Amazon Route53</h3>
<p>우선 <a href="https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/Welcome.html">Amazon Route 53란 무엇입니까?</a>를 참고하도록 하자. 해당 참조에 의하면 도메인 등록, DNS 라우팅, 상태 확인의 3가지 주요 기능을 조합하여 실행할 수 있는 서비스라고 한다. 각 요소를 하나하나 살펴보도록 하자.</p>
<p><a
    class="gatsby-resp-image-link"
    href="/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 582px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 76.46048109965635%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACtUlEQVQoz01S2U7bQBTNz/Uj+AKkSqjvfaiqPlV9opuKKhaJh6JKhS5SBQIhWoizQFnq2I4dL2OPl8RrPN7t2HHtGChHM1eW55655849rXKB+QMUReF7cZ5kk6gwUIgcx7Jsd4rSJCvywlWVwDQaVqt8gIpZxShIzvZxmdWh6VMMpAYjAmdGNICSYU3co+dPu2vvmuSKPNfTktQsRQQcx6uaNrXRt+3u9fEfHjsZYhiJtekOxp73Br9OLFX5/uLZ742PNbkoWk25MI49D3meH0bh1EF7m2csDpuMKizKVB9l4KMBSXI8P8tmtWwnK9NinsRRUV1Sqy7jMN3dOJUoVYpKBhoiB0YML4mKh6LqLc6BSij6bc+yNZW1saoqURQ1v6Iw2ds8pXFZt5HAK0CQBV4WBFkEquuEyzsHLw87VVpVrHXR75EEAQAIwuCe/GOr3emzl1C+GPE9hu8zVeS6DCeOJ1uHJ1/b5/N8IZthRjzHaYqexGlDbmQLlFp1mRXzu0HU0Q98CAAUuDipk1sTS1TGojV21WkcZ+m8zBeyzwClAb8kOGM0FElCYEeyYUQhCsWb9RHVbS5syfrQdLQ8LYbSlKYB4KDr+F/WMarXV6TOBOIq25Potg4uTXjtW7Dz6VHnYLUR05rYgu3oeV6PZJbmRV46tnO83xUoinM0O7A8S9AgGSAlT4yxCvCLI+LyCHn1A7XMKbSm4zRK5Sh3gjBLE8syDWNi2nZ+13AjstoIeazAA0lK0kXP2SwRxwPfcwTLE6AMqjMg8rwAIXSRFwZRcIvQr+H97Lxt//1cj6p2WOWbyFUNmjXBm7XX2x9eVS5gxRtRpTSThePh/VJ02nCU9ztPdg9X/3u7Nui80PJy+fHKytISQeIYdoYTuGkZszxtVprFhjkZ0tTV1dVgMKh0IYT+AafFKBmlLOFpAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="dns-routing"
        title=""
        src="/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png"
        srcset="/static/e2f6fe34c52e613cd80585054ae48a2f/39de5/dns-routing.png 163w,
/static/e2f6fe34c52e613cd80585054ae48a2f/ec46a/dns-routing.png 325w,
/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png 582w"
        sizes="(max-width: 582px) 100vw, 582px"
      />
  </span>
  </a></p>
<ul>
<li>
<p>도메인 등록은 우리가 흔히 알고 있는 것처럼 .com이나 .kr 등의 도메인을 자신만의 이름로 사용할 수 있게 해주는 서비스이다. Ex. <a href="https://www.naver.com">https://www.naver.com</a></p>
</li>
<li>
<p>다음으로 DNS 라우팅은 인터넷 트래픽을 도메인의 리소스로 라우팅하는 것을 말한다. 다시 말해 사용자의 요청이나 입력 등을 등록된 도메인에 전달하는 작업을 말하는 것이다.</p>
<ul>
<li>더불어 도메인의 형태가 항상 우리가 알고있는 www~로 시작하는 것만 존재하는 것이 아니라는 것에 유의하자. 우리가 흔히 알고있는 www는 World Wide Web의 약지로, 하나의 규격이다. 가령 <a href="https://mail.google.com%EC%99%80">https://mail.google.com와</a> 같은 도메인의 사용도 가능하다는 것이다.</li>
<li>그렇다면 위와 같이 모든 도메인을 따로 등록해야 할까? 그건 아니다. 가령 구글을 예로 들자면 구글의 모든 서비스를 Route 53을 통해 하나로 라우팅하고 싶다면 도메인 입력 란에 google.com만 입력하는 것도 방법이다. 이때 이를 최상위 도메인이라고 부를 수 있으며 앞선 메일 혹은 홈 페이지를 하위 도메인으로 설정할 수도 있다.</li>
<li>DNS에 대한 자세한 내용은 <a href="https://aws.amazon.com/ko/route53/what-is-dns/">DNS란 무엇입니까?</a>을 활용하도록 하자.</li>
</ul>
</li>
<li>
<p>마지막으로 상태 확인은 통신되고 있는 리소스의 상태를 확인한다는 의미이다. 문서에 따르면 Route 53은 인터넷을 통해 웹 서버 같은 리소스로 자동화된 요청을 보내어 접근 및 사용이 가능하고, 정상 작동 중인지 확인하는 기능을 한다고 한다. 더불어 리소스를 사용할 수 없게 될 때 알림을 수신한다거나 (비정상 리소스가 아닌) 다른 곳으로 인터넷 트래픽을 라우팅할 수도 있다고 한다.</p>
</li>
</ul>
<h3>Amazon CloudFront(CF)</h3>
<p>CloudFront는 사용해보지 않았기 때문에 무척 궁금했다. 그래서 <a href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html">Amazon CloudFront란?</a>을 참고하기로 했다. 문서에 따르면 "Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다."라는 설명을 볼 수 있다.</p>
<p>잉? 이런 건 EC2를 통해서 하는 게 아니었나? 가만, 다시 살펴보니 <strong>정적 및 동적 웹 콘텐츠</strong>라는 단어가 신경쓰인다. 그렇구나. 이건 내 웹 사이트의 contents에 해당하는 이야기구나! 그렇다면 소스 코드는 왜 있는 걸까? 조금 더 문서를 읽어보자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">CloudFront는 엣지 위치라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 라우팅되므로 콘텐츠 전송 성능이 뛰어납니다.

- 콘텐츠가 이미 지연 시간이 가장 낮은 엣지에 있는 경우 CloudFront가 콘텐츠를 즉시 제공합니다.
- 콘텐츠가 엣지 로케이션에 없는 경우 CloudFront는 콘텐츠의 최종 버전에 대한 소스로 지정된 오리진(예: Amazon S3 버킷, MediaPackage 채널, HTTP 서버(예: 웹 서버) 등)에서 콘텐츠를 검색합니다.</code></pre></div>
<p>이 글을 통해 "엣지 로케이션이 contents에 대한 Cache 역할을 하는구나!"라고 이해할 수 있었지만, 그럼에도 왜 EC2에서 할 수 있는 작업을 굳이 CloudFront에서 하는지 몰랐다. 하지만 이런 의문은 다음 문장을 통해 바로 해결할 수 있었다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">예를 들어, CloudFront가 아닌 일반적인 웹 서버에서 이미지를 제공한다고 가정합니다. 예를 들어 http://example.com/sunsetphoto.png URL을 사용하여 sunsetphoto.png라는 이미지를 서비스할 수 있습니다.

사용자는 이 URL로 쉽게 이동해 해당 이미지를 볼 수 있습니다. 하지만 이미지가 발견될 때까지 인터넷으로 이루어진 상호 연결된 네트워크의 복잡한 모음을 통해 네트워크에서 다른 네트워크로 요청이 라우팅되었다는 사실은 아마도 모르고 있을 것입니다.</code></pre></div>
<p>이는 리다이렉션을 통해 사용자가 콘텐츠에 접근하게 될 경우 발생하는 비용을 줄이고자 하는 목적으로 사용될 수 있음을 암시하고 있다. 앞서 이해한 Cache의 개념을 조금 확장해 사용자의 입장에서 낮은 지연 시간으로 contents를 얻고, 비용을 절약하게 된다는 것을 이해했다.</p>
<p>이는 언뜻 보기에는 별 것 아닐 수도 있지만, 나에게 있어서는 놀라운 기술일 수밖에 없다. 앞서 언급한 '비용'에는 사용자 경험, 물리 장비, 인력 등 다양한 의미가 포함되어 있고, 이를 단번에 최적화한 기술이기 때문이다. 놀라움도 잠시 다음 문장을 통해서 이해를 다질 수 있었다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">CloudFront는 AWS 백본 네트워크를 통해 콘텐츠를 가장 효과적으로 서비스할 수 있는 엣지로 각 사용자 요청을 라우팅하여 콘텐츠 배포 속도를 높입니다. 일반적으로 CloudFront 엣지가 최종 사용자에게 가장 빨리 제공합니다. AWS 네트워크를 사용하면 사용자의 요청이 반드시 통과해야 하는 네트워크의 수가 줄어들어 성능이 향상됩니다. 파일의 첫 바이트를 로드하는 데 걸리는 지연 시간이 줄어들고 데이터 전송 속도가 빨라집니다.

또한 파일(객체라고도 함)의 사본이 전 세계 여러 엣지 로케이션에 유지(또는 캐시)되므로 안정성과 가용성이 향상됩니다.</code></pre></div>
<p>정말 너무 환상적인 서비스군! 저렴한 비용으로 각 도시에 나의 콘를 Caching할 수 있다니.. 그럼 놀라움은 잠시 뒤로 하고 다음 서비스를 알아보자.</p>
<h3>Amazon S3</h3>
<p>흔히 우리가 Storage 기능을 한다고 알고있는 S3다. 자세한 설명을 하지 않아도 이미 이해하고 있었지만, 내가 하고 있는 이해는 경험에 의한 것이기 때문에 오늘을 기회로 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html">Amazon S3란 무엇입니까?</a>를 읽어보도록 하자.</p>
<p>아무래도 Storage 기능만을 제공하기 때문에 매우 짧다. 그래서 다음의 한 박스로 이를 이해할 수 있겠다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Simple Storage Service는 인터넷용 스토리지 서비스입니다. 이 서비스는 개발자가 더 쉽게 웹 규모 컴퓨팅 작업을 수행할 수 있도록 설계되었습니다.

Amazon S3에서 제공하는 단순한 웹 서비스 인터페이스를 사용하여 웹에서 언제 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있습니다. 또한 개발자는 Amazon이 자체 웹 사이트의 글로벌 네트워크 운영에 사용하는 것과 같은 높은 확장성과 신뢰성을 갖춘 빠르고 경제적인 데이터 스토리지 인프라에 액세스할 수 있습니다. 이 서비스의 목적은 규모의 이점을 극대화하고 개발자들에게 이러한 이점을 제공하는 것입니다.

이 가이드는 버킷 및 객체와 같은 Amazon S3의 핵심 개념과, Amazon S3 애플리케이션 프로그래밍 인터페이스(API)를 사용하여 이러한 리소스에 대한 작업 방법을 설명합니다.</code></pre></div>
<p>S3는 Storage의 기능을 하며 버킷이라고 부르는 단위를 통해 정적 파일을 관리한다는 것을 이해했다. 더불어 콘솔을 통해 제공되는 인터페이스를 활용하거나 API를 통해 코드에서의 활용도 가능할 것이라는 것을 이해할 수 있었다. 구글 드라이브인데 개발에 활용할 수 있겠다!</p>
<h3>Elastic Load Balancing(ELB)</h3>
<p>ELB는 로드 밸런싱이라고 부르는 작업을 해주는 서비스로 이해하고 있다. 이것도 지극히 경험적인 이해이므로 <a href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/userguide/what-is-load-balancing.html">Elastic Load Balancing란 무엇입니까?</a>를 통해서 정확하게 이해해보자.</p>
<p>일반적으로 로드 밸런싱이라 하면 트래픽을 분산하기 위해 사용한다고 이해하고 있다. 이에 대한 자세한 내용은 <a href="https://ko.wikipedia.org/wiki/%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0">부하분산</a>을 통해 알아보도록 하고 이 글에서는 ELB를 알아보도록 하자. 문서에 따른 설명은 다음과 같다. 부가적으로 트래픽을 분산한다는 의미보다는 정해진 수의 CPU나 메모리같은 컴퓨팅 자원에게 작업을 나눠 제공한다고 이해하는 것이 바람직하겠다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Elastic Load Balancing는 Amazon EC2 인스턴스, 컨테이너 및 IP 주소와 같은 여러 대상에 대해 수신 애플리케이션 또는 네트워크 트래픽을 여러 가용 영역에 배포합니다. 애플리케이션에 대한 트래픽이 시간이 지남에 따라 변경되므로 Elastic Load Balancing가 로드 밸런서를 확장하고 대다수의 워크로드에 맞게 자동으로 조정할 수 있습니다.</code></pre></div>
<p>이를 보고 동적인 부하 분산이 가능하겠다고 생각했다. 가령 어떤 날에는 1의 트래픽이, 어떤 날에는 10의 트래픽이 들어오는 서비스에서 트래픽을 처리하려면 10의 가용량을 항상 가지고 있어야 하기 때문에 1의 트래픽이 들어오는 날에는 9의 자원 낭비가 생길 수 있을 것이다. 그런데 이를 동적으로 관리한다면, 들어오는 트래픽에 따라 가용 공간을 늘려 사용할 수 있을 것이기 때문에, 심지어 위 내용에서 '자동'으로 저장할 수 있기 때문에 자원의 낭비를 최소화할 것이라 생각할 수 있었다.</p>
<p>이런 생각은 문서에서도 나타나고 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">로드 밸런서 이점

로드 밸런서는 워크로드를 가상 서버와 같은 다수의 컴퓨팅 리소스로 분산합니다. 로드 밸런서를 사용하면 애플리케이션의 가용성과 내결함성이 높아집니다.

애플리케이션에 대한 요청의 전체적인 흐름을 방해하지 않고 필요에 따라 로드 밸런서에서 컴퓨팅 리소스를 추가 및 제거할 수 있습니다.

로드 밸런서가 정상적인 대상에만 요청을 보낼 수 있도록 컴퓨팅 리소스의 상태를 모니터링하는 데 사용되는 상태 확인을 구성할 수 있습니다. 또한 컴퓨팅 리소스가 주요 작업에 집중할 수 있도록 암호화 및 복호화 작업을 로드 밸런서로 오프로드할 수 있습니다.</code></pre></div>
<h3>Amazon EC2</h3>
<p>흔히 알고 있는 EC2의 경우에도 <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2란 무엇입니까?</a>를 통해 살펴보자.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Elastic Compute Cloud(Amazon EC2)는 Amazon Web Services(AWS) 클라우드에서 확장식 컴퓨팅을 제공합니다. Amazon EC2를 사용하면 하드웨어에 선투자할 필요가 없어 더 빠르게 애플리케이션을 개발하고 배포할 수 있습니다. Amazon EC2를 통해 원하는 만큼 가상 서버를 구축하고 보안 및 네트워크 구성과 스토리지 관리가 가능합니다. 또한 Amazon EC2는 요구 사항이나 갑작스러운 인기 증대 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소할 수 있어 서버 트래픽 예측 필요성이 줄어듭니다.</code></pre></div>
<p>이번 정리를 통해 얻은 큰 수확 중 하나는 기존에 당연하게 사용하던 기술의 기능을 한 번에 정리하게 됐다는 점이다. EC2만 하더라도 가상 컴퓨팅 파워를 제공하는 것 외에도 다음과 같은 디테일한 기능을 가지고 있다는 것을 처음으로 알게되었기 때문이다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon EC2의 기능
Amazon EC2는 다음의 기능을 제공합니다.

- 인스턴스: 가상 컴퓨팅 환경
- Amazon 머신 이미지(AMI): 서버에 필요한 운영체제와 여러 소프트웨어들이 적절히 구성된 상태로 제공되는 템플릿으로 인스턴스를 쉽게 만들 수 있습니다.
- 인스턴스 유형: 인스턴스를 위한 CPU, 메모리, 스토리지, 네트워킹 용량의 여러 가지 구성 제공
- 키 페어를 사용하여 인스턴스 로그인 정보 보호(AWS는 퍼블릭 키를 저장하고 사용자는 개인 키를 안전한 장소에 보관하는 방식)
- 인스턴스 스토어 볼륨: 임시 데이터를 저장하는 스토리지 볼륨으로 인스턴스 종료 시 삭제됨
- Amazon Elastic Block Store(Amazon EBS), 즉 Amazon EBS 볼륨을 사용해 영구 스토리지 볼륨에 데이터 저장
- 인스턴스와 Amazon EBS 볼륨 등의 리소스를 다른 물리적 장소에서 액세스할 수 있는 지역 및 가용 영역
- 보안 그룹을 사용해 인스턴스에 연결할 수 있는 프로토콜, 포트, 소스 IP 범위를 지정하는 방화벽 기능
- 탄력적 IP 주소(EIP): 동적 클라우드 컴퓨팅을 위한 고정 IPv4 주소
- 태그: 사용자가 생성하여 Amazon EC2 리소스에 할당할 수 있는 메타데이터
- AWS 클라우드에서는 논리적으로 격리되어 있지만, 원할 때 마다 고객의 네트워크와 간편히 연결할 수 있는 가상 네트워크, Virtual Private Clouds(VPC)</code></pre></div>
<p>물론 이런 기능들의 디테일을 설정하기 위해서는 보다 많은 스킬업이 필요하겠지만, '가능하다' 정도만 이해하고 넘어가는 것도 나중에 트러블 슈팅, 비용 최적화 등을 위해 큰 도움이 될 것만 같다. 정말 좋다!</p>
<p>추가적으로 따로 단락을 만들어 언급하려 했던 <a href="https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html">Amazon EC2 Auto Scaling</a>을 간단히 소개해보자면, 다음과 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon EC2 Auto Scaling를 통해 애플리케이션의 로드를 처리할 수 있는 정확한 수의 Amazon EC2 인스턴스를 보유하도록 보장할 수 있습니다. Auto Scaling 그룹이라는 EC2 인스턴스 모음을 생성합니다. 각 Auto Scaling 그룹의 최소 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto Scaling에서는 그룹의 크기가 이 값 아래로 내려가지 않습니다. 각 Auto Scaling 그룹의 최대 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto Scaling에서는 그룹의 크기가 이 값을 넘지 않습니다. 원하는 용량을 지정한 경우 그룹을 생성한 다음에는 언제든지 Amazon EC2 Auto Scaling에서 해당 그룹에서 이만큼의 인스턴스를 보유할 수 있습니다. 조정 정책을 지정했다면 Amazon EC2 Auto Scaling에서는 애플리케이션의 늘어나거나 줄어드는 수요에 따라 인스턴스를 시작하거나 종료할 수 있습니다.</code></pre></div>
<p>Auto Scaling은 규모가 있는 서비스에서 필수적으로 필요할 것이라 생각된다. 왜냐하면 EC2의 인스턴스가 자동으로 스케일을 조정하는 경우는 트래픽이 많지 않으면 필요없을 것이라고 생각하기 때문이다. 하지만 이는 다소 편향된 생각이다. Auto-Scailing을 설정하지 않으면 만약 우리 서비스의 트래픽이 급격하게 증가하는 경우에는 서버가 버티지 못할 것이기 때문이다. 스타트업의 경우라면 만에 하나 있을 '대박'의 기회를 한순간에 놓칠 수도 있을 거라고 생각한다.</p>
<p>최소한의 인스턴스 수를 유지하면서 트래픽이 급격하게 증가할 경우에는 자동적으로 스케일 업을 진행하게 구현한다면 트래픽의 갑작스러운 변화에도 신속히 대응할 수 있을 것이라고 느꼈다. 문서에서는 다음과 같은 예시를 들어 이해를 돕는다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">예를 들어, 다음 Auto Scaling 그룹의 경우 최소 인스턴스 수 1개, 희망 인스턴스 용량 2개, 최대 인스턴스 수 4개가 됩니다. 사용자가 정의한 조정 정책에 따라 인스턴스 수가 최소 및 최대 인스턴스 수 내에서 지정하는 조건에 따라 조절됩니다.</code></pre></div>
<p><a
    class="gatsby-resp-image-link"
    href="/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 310px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 72.25806451612904%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACeUlEQVQoz31Ry27aUBC9f5NVpapdV/2HfkIfiy6qfkA/oJW6atJtd1VVJQISaAATcB48QgQ2YMBP7GtsHoEQWyQkUgLX07FJF120R8fjudI5c2fuEPiDIAgwmhZtSS1NVWS522y2Wi2J2n1F1bqy2ndc+BtkNnb82cT3fM/zr3xPrBYPOK56Wq2UKzyXLmRTqfg2Rp7bLx/l5rOxfzF64HRIpo0ktL+t8q9Z/hWrfYZRFVqfoPQWKu+B7sHwBIw4mLtgJ8E9YtouU3aY/JOpcWbmyaXMw9GbYJMAMvE8cErB9w08BlskqHwIzExgpgP7MNBigcWBHgeaA7sQVrR5ctnlgX+5+kLYJmGxZ+CU4McGfCUhQzPHkPYJ0/fCRIszq8DoIdMTQAtk1toH6WOw+xQST+D0HbhFyL6A7Uew8xgaW+AcAI1D/xdYO+DyYfM0EUYLzQdkrNfUGq/WjzXhWKrkLkxxPlA9V0HOh6otlTqllHya7lbSep2Xq9luZR+pnuU8WyLXixup0xUbzabUVnVjfn2DG2MAq2hzg9G43VU1o2eYtCaIimboPSqrhmaYS8aIYejFYlEUhEajYZq9er12fn6ONsawAtiUFosnnU47WnvD6OmCIJTLJUGoo4Dc399PJpPb29urCJ7nLRYLPM7nc9/30b9cLlcRMEHDOl+XJvh1Op1kMsnzfDab5TiuUCjkcrl8Pr82B//Ag/nu7k5RFMuyer0ediGKoq7rlNK14j8I29Y0zXGcfgT0YBwMBlgFc9u2MXddFwVY2oyA16AFBwxvxh8qRqPRMALacIRYLJZKpTKZDD4nDnJ2djadTlEzjoCPimP/Bqt9zXDfGFTyAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    ></span>
    <img
        class="gatsby-resp-image-image"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;"
        alt="auto-scailing"
        title=""
        src="/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png"
        srcset="/static/7b4c8ac32129aab596d7f10b471ac0c2/60353/auto-scailing.png 163w,
/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png 310w"
        sizes="(max-width: 310px) 100vw, 310px"
      />
  </span>
  </a></p>
<h3>Amazon RDS</h3>
<p>대망의 마지막 서비스이다! 이 설명이 끝나면 이제 구현이 가능하다! <a href="https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/Welcome.html">Amazon Relational Database Service(Amazon RDS)란 무엇입니까?</a>를 살펴보면, RDS를 다음과 같이 설명하고 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon Relational Database Service(Amazon RDS)는 클라우드에서 관계형 데이터베이스를 더 쉽게 설치, 운영 및 확장할 수 있는 웹 서비스입니다. 이 서비스는 산업 표준 관계형 데이터베이스를 위한 경제적이고 크기 조절이 가능한 용량을 제공하고 공통 데이터베이스 관리 작업을 관리합니다.</code></pre></div>
<p>일반적인 RDB(Relatinal Database)를 구현하기 위해선 따로 DB 서버를 두거나 하나의 서버에 해당 SQL의 DBMS를 설치해 콘솔 혹은 별도의 GUI 프로그램을 사용해야 했다. 하지만 RDS는 모든 DBMS의 UI를 하나로 통합해 제공하기 때문에 DBMS의 변경, 이주(Migation), 통합(Integration) 등에서 발생하는 정신적 스트레스, 별도의 학습 코스트를 최소화할 수 있을 것이다. 더불어 RDS는 별도의 Database 관리가 없이도 모니터링, 테이블 변경 등의 처리를 할 수 있어 이를 통해 다양한 비용을 절약할 수 있을 것이다.</p>
<p>이러한 필자의 생각은 문서 하단의 설명에서도 나온다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Amazon RDS의 개요

관리되는 관계형 데이터베이스 서비스가 필요한 이유는 무엇일까요? Amazon RDS가 어렵거나 지루한 관계형 데이터베이스 관리 작업을 대다수 대신하기 때문입니다.

- 서버를 구입하면 CPU, 메모리, 스토리지 및 IOPS가 모두 한데 묶여 제공됩니다. Amazon RDS를 사용하면 이 모두가 따로 분할되므로 독립적으로 확장할 수 있습니다. CPU가 더 많이 필요하거나 IOPS가 더 적게 필요하거나 스토리지가 더 많이 필요할 경우 쉽게 할당할 수 있습니다.
- Amazon RDS는 백업, 소프트웨어 패치, 자동 장애 감지 및 복구를 관리합니다.
- 관리형 서비스 환경을 제공하기 위해 Amazon RDS는 DB 인스턴스에 대해 shell 액세스를 제공하지 않으며, 고급 권한을 필요로 하는 특정 시스템 절차와 테이블에 대한 액세스를 제한합니다.
- 필요할 때 자동화된 백업을 수행하거나 고유한 백업 스냅샷을 수동으로 만들 수 있습니다. 이러한 백업을 사용하여 데이터베이스를 복원할 수 있습니다. Amazon RDS 복원 프로세스는 안정적이고 효율적입니다.
- 기본 인스턴스 및 문제 발생 시 장애 조치를 수행할 수 있는 동기식 보조 인스턴스에서 가용성을 높일 수 있습니다. MySQL, MariaDB 또는 PostgreSQL 읽기 전용 복제본을 사용해 읽기 조정을 높일 수도 있습니다.
- 이미 친숙한 MySQL, MariaDB, PostgreSQL, Oracle 및 Microsoft SQL Server 같은 데이터베이스 제품을 사용할 수 있습니다.
- 데이터베이스 패키지의 보안 외에도 AWS Identity and Access Management(IAM)을 사용해 사용자 및 권한을 정의하는 방법으로 RDS 데이터베이스에 액세스할 수 있는 사용자를 제어할 수 있습니다. 데이터베이스를 가상 사설 클라우드에 넣어 데이터베이스를 보호할 수도 있습니다.</code></pre></div>
<p>RDS에는 DB 인스턴스라는 단위가 존재한다. DB 인스턴스는 RDS의 기본 빌딩 블록(최소 단위)라고 할 수 있다. 더불어 DB 인스턴스는 클라우드에 존재하기 때문에 서비스와는 완전히 격리된 데이터베이스 환경이다. 그렇기 때문에 서비스 운영의 호환성을 고려하지 않아도 된다는 장점을 가지고 있다.</p>
<p>지금은 이정도만 이해하고 넘어가도 서비스를 사용함에 문제가 없다. 하지만, 더욱 자세한 설명을 원한다면 위에 제공된 링크를 통해 더욱 깊이 학습하도록 하자.</p>
<p>이제서야 이번 아키텍처에서 사용하는 모든 서비스를 정리할 수 있었다. 하지만, 아직 아키텍처의 전반적인 설명을 하지 않았기 때문에 이를 설명할 필요도 있다고 생각하기 때문에 지금까지의 내용을 정리할 겸 사용자의 흐름에 따라 다음과 같이 요약할 수 있다.</p>
<ol>
<li>유저는 DNS 응답(requests)를 하나의 고가용성 DNS 서비스인 Amazon Route53에 보낸다. 이때 네트워크 트래픽은 AWS에서 실행되는 인프라(Infrastructure)로 라우팅된다.</li>
<li>정적, 동적, 실시간 콘텐츠는 하나의 글로벌 엣지 로케이션(일종의 Conetns Cache) 네트워크인 CloudFront에 의해 전달된다. 이때 응답(requests)은 자동적으로 가장 가까운 엣지 로케이션으로 라우팅되고, 그래서 콘텐츠는 최적의 가용성을 가지고 전달된다.</li>
<li>자원(Resources)과 정적 콘텐츠는 미션 크리티컬 및 기본 데이터 스토리지를 위해 고안된 내구성이 뛰어난 스토리지 인프라인 S3 위에 적재된(stored) 웹 어플리케이션에 의해 사용된다.</li>
<li>HTTP 응답은 우선적으로 가용 영역(AZs)에서 다수의 Amazon Elastic Compute Cloud(EC2) 인스턴스로 들어오는 애플리케이션 트래픽을 자동으로 배분하는 ELB에 의해 처리(handled)되어진다.</li>
<li>웹 서버와 애플리케이션 서버는 EC2 위에서 배포되어진다. 여기서 대부분의 조직은 AMI(Amazon Machine Image)를 선택한 다음 필요에 맞게 사용자 정의합니다. 이 사용자 정의된(custom) AMI는 앞으로의 웹 개발의 출발점이 될 것이다.</li>
<li>웹 서버와 애플리케이션 서버는 Auto Scailing 그룹 안에서 배포되어진다. 이때 Auto Scaling은 정의한 조건에 따라 자동으로 용량을 늘리거나 줄이면서 조절합니다. Auto Scailing 기능을 사용하면 성능을 유지하기 위해 요구 사항이 급증 할 때 사용중인 EC2의 인스턴스의 수가 무사히 증가하고, 요구 사항이 발생하면 자동적으로 감소하여 비용을 최소화 할 수 있습니다.</li>
<li>고가용성을 제공하기 위해 어플리케이션 데이터가 포함된 관계형 데이터베이스는 RDS의 다중 가용구역(Multi-AZ, Master-Slave) 배포 위에서 중복적으로(redundantly) 호스팅된다.</li>
</ol>
<p>드디어 실습을 위한 사전 학습이 마무리됐다. 이 글 이후에는 실습을 위한 자료를 제공해 보다 나은 학습을 진행하고자 한다.</p>
<p><a href="https://rayleighko.github.io/blog/2019-02-27-aws_ac_web_2">다음 글(실습)</a></p>]]></description><link>https://rayleighko.github.io/blog/2019-02-25-aws_ac_web_02</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-25-aws_ac_web_02</guid><pubDate>Mon, 25 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;AWS - Architecture study: WEB APPLICATION HOSTING&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;https://media.amazonwebservices.com/architecturecenter/AWS&lt;em&gt;ac&lt;/em&gt;ra&lt;em&gt;web&lt;/em&gt;01.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&quot;AWS Architecture 중에서 가장 기초적으로 구현할 수 있는 모델은 어떤 게 있을까?&quot;라는 고민이 있었는데, 이번 스터디를 진행하면서 그 부분을 해결할 수 있었다.&lt;/p&gt;
&lt;p&gt;물론, &apos;구현&apos;을 목적으로 한다면, 더 작은 아키텍처를 선정했을테지만, AWS를 제대로 사용하고, 이를 활용하는 수준을 목적으로 한다면 간단하면서도 각 기능이 원활하게 돌아가는 아키텍처를 선정해야 한다는 생각이 있었다. 그래서 이번 스터디를 기회로 AWS 아키텍처 센터에서 기본적으로 제공하는 아키텍처 중 가장 처음 만나볼 수 있는 Web Application Hosting 아키텍처를 구현해보고자 했다.&lt;/p&gt;
&lt;p&gt;일단 위 PDF에 나와있는 서비스 중 전에 사용해본 서비스는 Route 53, S3, ELB, EC2, RDS가 있었다. 하지만 이는 아키텍처를 고려하고 설계를 먼저 한 것이 아니라 필요에 의해서 하나하나 만들었을 뿐이었기 때문에 깊이가 부족하다고 느끼고 있어서 이번 기회에 제대로 알아보려 한다. 아자아자!&lt;/p&gt;
&lt;p&gt;설계는 아키텍처 센터에서 이미 제공하고 있으니 바로 구현을 해야 할텐데, 구현에 앞서 우선적으로 각 서비스가 어떤 것인지를 알아보는 시간이 필요할 것 같아서 각 서비스에 대해 스터디한 내용을 살짝 공유해보려 한다.&lt;/p&gt;
&lt;h3&gt;Amazon Route53&lt;/h3&gt;
&lt;p&gt;우선 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/Welcome.html&quot;&gt;Amazon Route 53란 무엇입니까?&lt;/a&gt;를 참고하도록 하자. 해당 참조에 의하면 도메인 등록, DNS 라우팅, 상태 확인의 3가지 주요 기능을 조합하여 실행할 수 있는 서비스라고 한다. 각 요소를 하나하나 살펴보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 582px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 76.46048109965635%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACtUlEQVQoz01S2U7bQBTNz/Uj+AKkSqjvfaiqPlV9opuKKhaJh6JKhS5SBQIhWoizQFnq2I4dL2OPl8RrPN7t2HHtGChHM1eW55655849rXKB+QMUReF7cZ5kk6gwUIgcx7Jsd4rSJCvywlWVwDQaVqt8gIpZxShIzvZxmdWh6VMMpAYjAmdGNICSYU3co+dPu2vvmuSKPNfTktQsRQQcx6uaNrXRt+3u9fEfHjsZYhiJtekOxp73Br9OLFX5/uLZ742PNbkoWk25MI49D3meH0bh1EF7m2csDpuMKizKVB9l4KMBSXI8P8tmtWwnK9NinsRRUV1Sqy7jMN3dOJUoVYpKBhoiB0YML4mKh6LqLc6BSij6bc+yNZW1saoqURQ1v6Iw2ds8pXFZt5HAK0CQBV4WBFkEquuEyzsHLw87VVpVrHXR75EEAQAIwuCe/GOr3emzl1C+GPE9hu8zVeS6DCeOJ1uHJ1/b5/N8IZthRjzHaYqexGlDbmQLlFp1mRXzu0HU0Q98CAAUuDipk1sTS1TGojV21WkcZ+m8zBeyzwClAb8kOGM0FElCYEeyYUQhCsWb9RHVbS5syfrQdLQ8LYbSlKYB4KDr+F/WMarXV6TOBOIq25Potg4uTXjtW7Dz6VHnYLUR05rYgu3oeV6PZJbmRV46tnO83xUoinM0O7A8S9AgGSAlT4yxCvCLI+LyCHn1A7XMKbSm4zRK5Sh3gjBLE8syDWNi2nZ+13AjstoIeazAA0lK0kXP2SwRxwPfcwTLE6AMqjMg8rwAIXSRFwZRcIvQr+H97Lxt//1cj6p2WOWbyFUNmjXBm7XX2x9eVS5gxRtRpTSThePh/VJ02nCU9ztPdg9X/3u7Nui80PJy+fHKytISQeIYdoYTuGkZszxtVprFhjkZ0tTV1dVgMKh0IYT+AafFKBmlLOFpAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;dns-routing&quot;
        title=&quot;&quot;
        src=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png&quot;
        srcset=&quot;/static/e2f6fe34c52e613cd80585054ae48a2f/39de5/dns-routing.png 163w,
/static/e2f6fe34c52e613cd80585054ae48a2f/ec46a/dns-routing.png 325w,
/static/e2f6fe34c52e613cd80585054ae48a2f/33e5c/dns-routing.png 582w&quot;
        sizes=&quot;(max-width: 582px) 100vw, 582px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;도메인 등록은 우리가 흔히 알고 있는 것처럼 .com이나 .kr 등의 도메인을 자신만의 이름로 사용할 수 있게 해주는 서비스이다. Ex. &lt;a href=&quot;https://www.naver.com&quot;&gt;https://www.naver.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음으로 DNS 라우팅은 인터넷 트래픽을 도메인의 리소스로 라우팅하는 것을 말한다. 다시 말해 사용자의 요청이나 입력 등을 등록된 도메인에 전달하는 작업을 말하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;더불어 도메인의 형태가 항상 우리가 알고있는 www~로 시작하는 것만 존재하는 것이 아니라는 것에 유의하자. 우리가 흔히 알고있는 www는 World Wide Web의 약지로, 하나의 규격이다. 가령 &lt;a href=&quot;https://mail.google.com%EC%99%80&quot;&gt;https://mail.google.com와&lt;/a&gt; 같은 도메인의 사용도 가능하다는 것이다.&lt;/li&gt;
&lt;li&gt;그렇다면 위와 같이 모든 도메인을 따로 등록해야 할까? 그건 아니다. 가령 구글을 예로 들자면 구글의 모든 서비스를 Route 53을 통해 하나로 라우팅하고 싶다면 도메인 입력 란에 google.com만 입력하는 것도 방법이다. 이때 이를 최상위 도메인이라고 부를 수 있으며 앞선 메일 혹은 홈 페이지를 하위 도메인으로 설정할 수도 있다.&lt;/li&gt;
&lt;li&gt;DNS에 대한 자세한 내용은 &lt;a href=&quot;https://aws.amazon.com/ko/route53/what-is-dns/&quot;&gt;DNS란 무엇입니까?&lt;/a&gt;을 활용하도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 상태 확인은 통신되고 있는 리소스의 상태를 확인한다는 의미이다. 문서에 따르면 Route 53은 인터넷을 통해 웹 서버 같은 리소스로 자동화된 요청을 보내어 접근 및 사용이 가능하고, 정상 작동 중인지 확인하는 기능을 한다고 한다. 더불어 리소스를 사용할 수 없게 될 때 알림을 수신한다거나 (비정상 리소스가 아닌) 다른 곳으로 인터넷 트래픽을 라우팅할 수도 있다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Amazon CloudFront(CF)&lt;/h3&gt;
&lt;p&gt;CloudFront는 사용해보지 않았기 때문에 무척 궁금했다. 그래서 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html&quot;&gt;Amazon CloudFront란?&lt;/a&gt;을 참고하기로 했다. 문서에 따르면 &quot;Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다.&quot;라는 설명을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;잉? 이런 건 EC2를 통해서 하는 게 아니었나? 가만, 다시 살펴보니 &lt;strong&gt;정적 및 동적 웹 콘텐츠&lt;/strong&gt;라는 단어가 신경쓰인다. 그렇구나. 이건 내 웹 사이트의 contents에 해당하는 이야기구나! 그렇다면 소스 코드는 왜 있는 걸까? 조금 더 문서를 읽어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;CloudFront는 엣지 위치라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 라우팅되므로 콘텐츠 전송 성능이 뛰어납니다.

- 콘텐츠가 이미 지연 시간이 가장 낮은 엣지에 있는 경우 CloudFront가 콘텐츠를 즉시 제공합니다.
- 콘텐츠가 엣지 로케이션에 없는 경우 CloudFront는 콘텐츠의 최종 버전에 대한 소스로 지정된 오리진(예: Amazon S3 버킷, MediaPackage 채널, HTTP 서버(예: 웹 서버) 등)에서 콘텐츠를 검색합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 글을 통해 &quot;엣지 로케이션이 contents에 대한 Cache 역할을 하는구나!&quot;라고 이해할 수 있었지만, 그럼에도 왜 EC2에서 할 수 있는 작업을 굳이 CloudFront에서 하는지 몰랐다. 하지만 이런 의문은 다음 문장을 통해 바로 해결할 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;예를 들어, CloudFront가 아닌 일반적인 웹 서버에서 이미지를 제공한다고 가정합니다. 예를 들어 http://example.com/sunsetphoto.png URL을 사용하여 sunsetphoto.png라는 이미지를 서비스할 수 있습니다.

사용자는 이 URL로 쉽게 이동해 해당 이미지를 볼 수 있습니다. 하지만 이미지가 발견될 때까지 인터넷으로 이루어진 상호 연결된 네트워크의 복잡한 모음을 통해 네트워크에서 다른 네트워크로 요청이 라우팅되었다는 사실은 아마도 모르고 있을 것입니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 리다이렉션을 통해 사용자가 콘텐츠에 접근하게 될 경우 발생하는 비용을 줄이고자 하는 목적으로 사용될 수 있음을 암시하고 있다. 앞서 이해한 Cache의 개념을 조금 확장해 사용자의 입장에서 낮은 지연 시간으로 contents를 얻고, 비용을 절약하게 된다는 것을 이해했다.&lt;/p&gt;
&lt;p&gt;이는 언뜻 보기에는 별 것 아닐 수도 있지만, 나에게 있어서는 놀라운 기술일 수밖에 없다. 앞서 언급한 &apos;비용&apos;에는 사용자 경험, 물리 장비, 인력 등 다양한 의미가 포함되어 있고, 이를 단번에 최적화한 기술이기 때문이다. 놀라움도 잠시 다음 문장을 통해서 이해를 다질 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;CloudFront는 AWS 백본 네트워크를 통해 콘텐츠를 가장 효과적으로 서비스할 수 있는 엣지로 각 사용자 요청을 라우팅하여 콘텐츠 배포 속도를 높입니다. 일반적으로 CloudFront 엣지가 최종 사용자에게 가장 빨리 제공합니다. AWS 네트워크를 사용하면 사용자의 요청이 반드시 통과해야 하는 네트워크의 수가 줄어들어 성능이 향상됩니다. 파일의 첫 바이트를 로드하는 데 걸리는 지연 시간이 줄어들고 데이터 전송 속도가 빨라집니다.

또한 파일(객체라고도 함)의 사본이 전 세계 여러 엣지 로케이션에 유지(또는 캐시)되므로 안정성과 가용성이 향상됩니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정말 너무 환상적인 서비스군! 저렴한 비용으로 각 도시에 나의 콘를 Caching할 수 있다니.. 그럼 놀라움은 잠시 뒤로 하고 다음 서비스를 알아보자.&lt;/p&gt;
&lt;h3&gt;Amazon S3&lt;/h3&gt;
&lt;p&gt;흔히 우리가 Storage 기능을 한다고 알고있는 S3다. 자세한 설명을 하지 않아도 이미 이해하고 있었지만, 내가 하고 있는 이해는 경험에 의한 것이기 때문에 오늘을 기회로 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html&quot;&gt;Amazon S3란 무엇입니까?&lt;/a&gt;를 읽어보도록 하자.&lt;/p&gt;
&lt;p&gt;아무래도 Storage 기능만을 제공하기 때문에 매우 짧다. 그래서 다음의 한 박스로 이를 이해할 수 있겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Simple Storage Service는 인터넷용 스토리지 서비스입니다. 이 서비스는 개발자가 더 쉽게 웹 규모 컴퓨팅 작업을 수행할 수 있도록 설계되었습니다.

Amazon S3에서 제공하는 단순한 웹 서비스 인터페이스를 사용하여 웹에서 언제 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있습니다. 또한 개발자는 Amazon이 자체 웹 사이트의 글로벌 네트워크 운영에 사용하는 것과 같은 높은 확장성과 신뢰성을 갖춘 빠르고 경제적인 데이터 스토리지 인프라에 액세스할 수 있습니다. 이 서비스의 목적은 규모의 이점을 극대화하고 개발자들에게 이러한 이점을 제공하는 것입니다.

이 가이드는 버킷 및 객체와 같은 Amazon S3의 핵심 개념과, Amazon S3 애플리케이션 프로그래밍 인터페이스(API)를 사용하여 이러한 리소스에 대한 작업 방법을 설명합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;S3는 Storage의 기능을 하며 버킷이라고 부르는 단위를 통해 정적 파일을 관리한다는 것을 이해했다. 더불어 콘솔을 통해 제공되는 인터페이스를 활용하거나 API를 통해 코드에서의 활용도 가능할 것이라는 것을 이해할 수 있었다. 구글 드라이브인데 개발에 활용할 수 있겠다!&lt;/p&gt;
&lt;h3&gt;Elastic Load Balancing(ELB)&lt;/h3&gt;
&lt;p&gt;ELB는 로드 밸런싱이라고 부르는 작업을 해주는 서비스로 이해하고 있다. 이것도 지극히 경험적인 이해이므로 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/userguide/what-is-load-balancing.html&quot;&gt;Elastic Load Balancing란 무엇입니까?&lt;/a&gt;를 통해서 정확하게 이해해보자.&lt;/p&gt;
&lt;p&gt;일반적으로 로드 밸런싱이라 하면 트래픽을 분산하기 위해 사용한다고 이해하고 있다. 이에 대한 자세한 내용은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0&quot;&gt;부하분산&lt;/a&gt;을 통해 알아보도록 하고 이 글에서는 ELB를 알아보도록 하자. 문서에 따른 설명은 다음과 같다. 부가적으로 트래픽을 분산한다는 의미보다는 정해진 수의 CPU나 메모리같은 컴퓨팅 자원에게 작업을 나눠 제공한다고 이해하는 것이 바람직하겠다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Elastic Load Balancing는 Amazon EC2 인스턴스, 컨테이너 및 IP 주소와 같은 여러 대상에 대해 수신 애플리케이션 또는 네트워크 트래픽을 여러 가용 영역에 배포합니다. 애플리케이션에 대한 트래픽이 시간이 지남에 따라 변경되므로 Elastic Load Balancing가 로드 밸런서를 확장하고 대다수의 워크로드에 맞게 자동으로 조정할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이를 보고 동적인 부하 분산이 가능하겠다고 생각했다. 가령 어떤 날에는 1의 트래픽이, 어떤 날에는 10의 트래픽이 들어오는 서비스에서 트래픽을 처리하려면 10의 가용량을 항상 가지고 있어야 하기 때문에 1의 트래픽이 들어오는 날에는 9의 자원 낭비가 생길 수 있을 것이다. 그런데 이를 동적으로 관리한다면, 들어오는 트래픽에 따라 가용 공간을 늘려 사용할 수 있을 것이기 때문에, 심지어 위 내용에서 &apos;자동&apos;으로 저장할 수 있기 때문에 자원의 낭비를 최소화할 것이라 생각할 수 있었다.&lt;/p&gt;
&lt;p&gt;이런 생각은 문서에서도 나타나고 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;로드 밸런서 이점

로드 밸런서는 워크로드를 가상 서버와 같은 다수의 컴퓨팅 리소스로 분산합니다. 로드 밸런서를 사용하면 애플리케이션의 가용성과 내결함성이 높아집니다.

애플리케이션에 대한 요청의 전체적인 흐름을 방해하지 않고 필요에 따라 로드 밸런서에서 컴퓨팅 리소스를 추가 및 제거할 수 있습니다.

로드 밸런서가 정상적인 대상에만 요청을 보낼 수 있도록 컴퓨팅 리소스의 상태를 모니터링하는 데 사용되는 상태 확인을 구성할 수 있습니다. 또한 컴퓨팅 리소스가 주요 작업에 집중할 수 있도록 암호화 및 복호화 작업을 로드 밸런서로 오프로드할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Amazon EC2&lt;/h3&gt;
&lt;p&gt;흔히 알고 있는 EC2의 경우에도 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html&quot;&gt;Amazon EC2란 무엇입니까?&lt;/a&gt;를 통해 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Elastic Compute Cloud(Amazon EC2)는 Amazon Web Services(AWS) 클라우드에서 확장식 컴퓨팅을 제공합니다. Amazon EC2를 사용하면 하드웨어에 선투자할 필요가 없어 더 빠르게 애플리케이션을 개발하고 배포할 수 있습니다. Amazon EC2를 통해 원하는 만큼 가상 서버를 구축하고 보안 및 네트워크 구성과 스토리지 관리가 가능합니다. 또한 Amazon EC2는 요구 사항이나 갑작스러운 인기 증대 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소할 수 있어 서버 트래픽 예측 필요성이 줄어듭니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이번 정리를 통해 얻은 큰 수확 중 하나는 기존에 당연하게 사용하던 기술의 기능을 한 번에 정리하게 됐다는 점이다. EC2만 하더라도 가상 컴퓨팅 파워를 제공하는 것 외에도 다음과 같은 디테일한 기능을 가지고 있다는 것을 처음으로 알게되었기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon EC2의 기능
Amazon EC2는 다음의 기능을 제공합니다.

- 인스턴스: 가상 컴퓨팅 환경
- Amazon 머신 이미지(AMI): 서버에 필요한 운영체제와 여러 소프트웨어들이 적절히 구성된 상태로 제공되는 템플릿으로 인스턴스를 쉽게 만들 수 있습니다.
- 인스턴스 유형: 인스턴스를 위한 CPU, 메모리, 스토리지, 네트워킹 용량의 여러 가지 구성 제공
- 키 페어를 사용하여 인스턴스 로그인 정보 보호(AWS는 퍼블릭 키를 저장하고 사용자는 개인 키를 안전한 장소에 보관하는 방식)
- 인스턴스 스토어 볼륨: 임시 데이터를 저장하는 스토리지 볼륨으로 인스턴스 종료 시 삭제됨
- Amazon Elastic Block Store(Amazon EBS), 즉 Amazon EBS 볼륨을 사용해 영구 스토리지 볼륨에 데이터 저장
- 인스턴스와 Amazon EBS 볼륨 등의 리소스를 다른 물리적 장소에서 액세스할 수 있는 지역 및 가용 영역
- 보안 그룹을 사용해 인스턴스에 연결할 수 있는 프로토콜, 포트, 소스 IP 범위를 지정하는 방화벽 기능
- 탄력적 IP 주소(EIP): 동적 클라우드 컴퓨팅을 위한 고정 IPv4 주소
- 태그: 사용자가 생성하여 Amazon EC2 리소스에 할당할 수 있는 메타데이터
- AWS 클라우드에서는 논리적으로 격리되어 있지만, 원할 때 마다 고객의 네트워크와 간편히 연결할 수 있는 가상 네트워크, Virtual Private Clouds(VPC)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론 이런 기능들의 디테일을 설정하기 위해서는 보다 많은 스킬업이 필요하겠지만, &apos;가능하다&apos; 정도만 이해하고 넘어가는 것도 나중에 트러블 슈팅, 비용 최적화 등을 위해 큰 도움이 될 것만 같다. 정말 좋다!&lt;/p&gt;
&lt;p&gt;추가적으로 따로 단락을 만들어 언급하려 했던 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html&quot;&gt;Amazon EC2 Auto Scaling&lt;/a&gt;을 간단히 소개해보자면, 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon EC2 Auto Scaling를 통해 애플리케이션의 로드를 처리할 수 있는 정확한 수의 Amazon EC2 인스턴스를 보유하도록 보장할 수 있습니다. Auto Scaling 그룹이라는 EC2 인스턴스 모음을 생성합니다. 각 Auto Scaling 그룹의 최소 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto Scaling에서는 그룹의 크기가 이 값 아래로 내려가지 않습니다. 각 Auto Scaling 그룹의 최대 인스턴스 수를 지정할 수 있으며, Amazon EC2 Auto Scaling에서는 그룹의 크기가 이 값을 넘지 않습니다. 원하는 용량을 지정한 경우 그룹을 생성한 다음에는 언제든지 Amazon EC2 Auto Scaling에서 해당 그룹에서 이만큼의 인스턴스를 보유할 수 있습니다. 조정 정책을 지정했다면 Amazon EC2 Auto Scaling에서는 애플리케이션의 늘어나거나 줄어드는 수요에 따라 인스턴스를 시작하거나 종료할 수 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Auto Scaling은 규모가 있는 서비스에서 필수적으로 필요할 것이라 생각된다. 왜냐하면 EC2의 인스턴스가 자동으로 스케일을 조정하는 경우는 트래픽이 많지 않으면 필요없을 것이라고 생각하기 때문이다. 하지만 이는 다소 편향된 생각이다. Auto-Scailing을 설정하지 않으면 만약 우리 서비스의 트래픽이 급격하게 증가하는 경우에는 서버가 버티지 못할 것이기 때문이다. 스타트업의 경우라면 만에 하나 있을 &apos;대박&apos;의 기회를 한순간에 놓칠 수도 있을 거라고 생각한다.&lt;/p&gt;
&lt;p&gt;최소한의 인스턴스 수를 유지하면서 트래픽이 급격하게 증가할 경우에는 자동적으로 스케일 업을 진행하게 구현한다면 트래픽의 갑작스러운 변화에도 신속히 대응할 수 있을 것이라고 느꼈다. 문서에서는 다음과 같은 예시를 들어 이해를 돕는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;예를 들어, 다음 Auto Scaling 그룹의 경우 최소 인스턴스 수 1개, 희망 인스턴스 용량 2개, 최대 인스턴스 수 4개가 됩니다. 사용자가 정의한 조정 정책에 따라 인스턴스 수가 최소 및 최대 인스턴스 수 내에서 지정하는 조건에 따라 조절됩니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 310px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 72.25806451612904%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACeUlEQVQoz31Ry27aUBC9f5NVpapdV/2HfkIfiy6qfkA/oJW6atJtd1VVJQISaAATcB48QgQ2YMBP7GtsHoEQWyQkUgLX07FJF120R8fjudI5c2fuEPiDIAgwmhZtSS1NVWS522y2Wi2J2n1F1bqy2ndc+BtkNnb82cT3fM/zr3xPrBYPOK56Wq2UKzyXLmRTqfg2Rp7bLx/l5rOxfzF64HRIpo0ktL+t8q9Z/hWrfYZRFVqfoPQWKu+B7sHwBIw4mLtgJ8E9YtouU3aY/JOpcWbmyaXMw9GbYJMAMvE8cErB9w08BlskqHwIzExgpgP7MNBigcWBHgeaA7sQVrR5ctnlgX+5+kLYJmGxZ+CU4McGfCUhQzPHkPYJ0/fCRIszq8DoIdMTQAtk1toH6WOw+xQST+D0HbhFyL6A7Uew8xgaW+AcAI1D/xdYO+DyYfM0EUYLzQdkrNfUGq/WjzXhWKrkLkxxPlA9V0HOh6otlTqllHya7lbSep2Xq9luZR+pnuU8WyLXixup0xUbzabUVnVjfn2DG2MAq2hzg9G43VU1o2eYtCaIimboPSqrhmaYS8aIYejFYlEUhEajYZq9er12fn6ONsawAtiUFosnnU47WnvD6OmCIJTLJUGoo4Dc399PJpPb29urCJ7nLRYLPM7nc9/30b9cLlcRMEHDOl+XJvh1Op1kMsnzfDab5TiuUCjkcrl8Pr82B//Ag/nu7k5RFMuyer0ediGKoq7rlNK14j8I29Y0zXGcfgT0YBwMBlgFc9u2MXddFwVY2oyA16AFBwxvxh8qRqPRMALacIRYLJZKpTKZDD4nDnJ2djadTlEzjoCPimP/Bqt9zXDfGFTyAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;&lt;/span&gt;
    &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;&quot;
        alt=&quot;auto-scailing&quot;
        title=&quot;&quot;
        src=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png&quot;
        srcset=&quot;/static/7b4c8ac32129aab596d7f10b471ac0c2/60353/auto-scailing.png 163w,
/static/7b4c8ac32129aab596d7f10b471ac0c2/68af2/auto-scailing.png 310w&quot;
        sizes=&quot;(max-width: 310px) 100vw, 310px&quot;
      /&gt;
  &lt;/span&gt;
  &lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Amazon RDS&lt;/h3&gt;
&lt;p&gt;대망의 마지막 서비스이다! 이 설명이 끝나면 이제 구현이 가능하다! &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/Welcome.html&quot;&gt;Amazon Relational Database Service(Amazon RDS)란 무엇입니까?&lt;/a&gt;를 살펴보면, RDS를 다음과 같이 설명하고 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon Relational Database Service(Amazon RDS)는 클라우드에서 관계형 데이터베이스를 더 쉽게 설치, 운영 및 확장할 수 있는 웹 서비스입니다. 이 서비스는 산업 표준 관계형 데이터베이스를 위한 경제적이고 크기 조절이 가능한 용량을 제공하고 공통 데이터베이스 관리 작업을 관리합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반적인 RDB(Relatinal Database)를 구현하기 위해선 따로 DB 서버를 두거나 하나의 서버에 해당 SQL의 DBMS를 설치해 콘솔 혹은 별도의 GUI 프로그램을 사용해야 했다. 하지만 RDS는 모든 DBMS의 UI를 하나로 통합해 제공하기 때문에 DBMS의 변경, 이주(Migation), 통합(Integration) 등에서 발생하는 정신적 스트레스, 별도의 학습 코스트를 최소화할 수 있을 것이다. 더불어 RDS는 별도의 Database 관리가 없이도 모니터링, 테이블 변경 등의 처리를 할 수 있어 이를 통해 다양한 비용을 절약할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이러한 필자의 생각은 문서 하단의 설명에서도 나온다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Amazon RDS의 개요

관리되는 관계형 데이터베이스 서비스가 필요한 이유는 무엇일까요? Amazon RDS가 어렵거나 지루한 관계형 데이터베이스 관리 작업을 대다수 대신하기 때문입니다.

- 서버를 구입하면 CPU, 메모리, 스토리지 및 IOPS가 모두 한데 묶여 제공됩니다. Amazon RDS를 사용하면 이 모두가 따로 분할되므로 독립적으로 확장할 수 있습니다. CPU가 더 많이 필요하거나 IOPS가 더 적게 필요하거나 스토리지가 더 많이 필요할 경우 쉽게 할당할 수 있습니다.
- Amazon RDS는 백업, 소프트웨어 패치, 자동 장애 감지 및 복구를 관리합니다.
- 관리형 서비스 환경을 제공하기 위해 Amazon RDS는 DB 인스턴스에 대해 shell 액세스를 제공하지 않으며, 고급 권한을 필요로 하는 특정 시스템 절차와 테이블에 대한 액세스를 제한합니다.
- 필요할 때 자동화된 백업을 수행하거나 고유한 백업 스냅샷을 수동으로 만들 수 있습니다. 이러한 백업을 사용하여 데이터베이스를 복원할 수 있습니다. Amazon RDS 복원 프로세스는 안정적이고 효율적입니다.
- 기본 인스턴스 및 문제 발생 시 장애 조치를 수행할 수 있는 동기식 보조 인스턴스에서 가용성을 높일 수 있습니다. MySQL, MariaDB 또는 PostgreSQL 읽기 전용 복제본을 사용해 읽기 조정을 높일 수도 있습니다.
- 이미 친숙한 MySQL, MariaDB, PostgreSQL, Oracle 및 Microsoft SQL Server 같은 데이터베이스 제품을 사용할 수 있습니다.
- 데이터베이스 패키지의 보안 외에도 AWS Identity and Access Management(IAM)을 사용해 사용자 및 권한을 정의하는 방법으로 RDS 데이터베이스에 액세스할 수 있는 사용자를 제어할 수 있습니다. 데이터베이스를 가상 사설 클라우드에 넣어 데이터베이스를 보호할 수도 있습니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RDS에는 DB 인스턴스라는 단위가 존재한다. DB 인스턴스는 RDS의 기본 빌딩 블록(최소 단위)라고 할 수 있다. 더불어 DB 인스턴스는 클라우드에 존재하기 때문에 서비스와는 완전히 격리된 데이터베이스 환경이다. 그렇기 때문에 서비스 운영의 호환성을 고려하지 않아도 된다는 장점을 가지고 있다.&lt;/p&gt;
&lt;p&gt;지금은 이정도만 이해하고 넘어가도 서비스를 사용함에 문제가 없다. 하지만, 더욱 자세한 설명을 원한다면 위에 제공된 링크를 통해 더욱 깊이 학습하도록 하자.&lt;/p&gt;
&lt;p&gt;이제서야 이번 아키텍처에서 사용하는 모든 서비스를 정리할 수 있었다. 하지만, 아직 아키텍처의 전반적인 설명을 하지 않았기 때문에 이를 설명할 필요도 있다고 생각하기 때문에 지금까지의 내용을 정리할 겸 사용자의 흐름에 따라 다음과 같이 요약할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유저는 DNS 응답(requests)를 하나의 고가용성 DNS 서비스인 Amazon Route53에 보낸다. 이때 네트워크 트래픽은 AWS에서 실행되는 인프라(Infrastructure)로 라우팅된다.&lt;/li&gt;
&lt;li&gt;정적, 동적, 실시간 콘텐츠는 하나의 글로벌 엣지 로케이션(일종의 Conetns Cache) 네트워크인 CloudFront에 의해 전달된다. 이때 응답(requests)은 자동적으로 가장 가까운 엣지 로케이션으로 라우팅되고, 그래서 콘텐츠는 최적의 가용성을 가지고 전달된다.&lt;/li&gt;
&lt;li&gt;자원(Resources)과 정적 콘텐츠는 미션 크리티컬 및 기본 데이터 스토리지를 위해 고안된 내구성이 뛰어난 스토리지 인프라인 S3 위에 적재된(stored) 웹 어플리케이션에 의해 사용된다.&lt;/li&gt;
&lt;li&gt;HTTP 응답은 우선적으로 가용 영역(AZs)에서 다수의 Amazon Elastic Compute Cloud(EC2) 인스턴스로 들어오는 애플리케이션 트래픽을 자동으로 배분하는 ELB에 의해 처리(handled)되어진다.&lt;/li&gt;
&lt;li&gt;웹 서버와 애플리케이션 서버는 EC2 위에서 배포되어진다. 여기서 대부분의 조직은 AMI(Amazon Machine Image)를 선택한 다음 필요에 맞게 사용자 정의합니다. 이 사용자 정의된(custom) AMI는 앞으로의 웹 개발의 출발점이 될 것이다.&lt;/li&gt;
&lt;li&gt;웹 서버와 애플리케이션 서버는 Auto Scailing 그룹 안에서 배포되어진다. 이때 Auto Scaling은 정의한 조건에 따라 자동으로 용량을 늘리거나 줄이면서 조절합니다. Auto Scailing 기능을 사용하면 성능을 유지하기 위해 요구 사항이 급증 할 때 사용중인 EC2의 인스턴스의 수가 무사히 증가하고, 요구 사항이 발생하면 자동적으로 감소하여 비용을 최소화 할 수 있습니다.&lt;/li&gt;
&lt;li&gt;고가용성을 제공하기 위해 어플리케이션 데이터가 포함된 관계형 데이터베이스는 RDS의 다중 가용구역(Multi-AZ, Master-Slave) 배포 위에서 중복적으로(redundantly) 호스팅된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;드디어 실습을 위한 사전 학습이 마무리됐다. 이 글 이후에는 실습을 위한 자료를 제공해 보다 나은 학습을 진행하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rayleighko.github.io/blog/2019-02-27-aws_ac_web_2&quot;&gt;다음 글(실습)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 아키텍처 - Web Application Hosting_01]]></title><description><![CDATA[<h1>AWS 아키텍처 - Web Application Hosting</h1>
<p>What is <code class="language-text">Web-Application Hosting</code> in <a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">AWS Reference Architecture</a>?</p>
<div class="gatsby-highlight" data-language="english"><pre class="language-english"><code class="language-english">Highly available and scalable web hosting can be complex and expensive.
Dense peak periods and wild swings in traffic patterns result in low utilization of expensive hardware.

Amazon Web Services provides the reliable, scalable, secure, and high- performance infrastructure required for web applications while enabling an elastic, scale-out and scale-down infrastructure to match IT costs in real time as customer traffic fluctuates.</code></pre></div>
<p><a href="https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf">AWS Reference Architecture</a>에서 제공하는 <code class="language-text">Web-Application Hosting</code>은 무엇일까?</p>
<div class="gatsby-highlight" data-language="korean"><pre class="language-korean"><code class="language-korean">고가용성 및 확장성 웹 호스팅은 복잡하고 비용이 많이 듭니다.
이는 트래픽 패턴이 짙어지면서 피크 시간이 길어지고 값 비싼 하드웨어의 사용률이 낮아집니다.

Amazon Web Services에서는 웹 애플리케이션에 필요한 안정적이고 확장 가능하며 안전한 고성능 인프라를 제공하는 동시에 고객 트래픽이 변동함에 따라 IT 비용을 실시간으로 일치시킬 수있는 유연한 스케일 아웃 및 축소형 인프라를 제공합니다.</code></pre></div>]]></description><link>https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_01</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-02-12-aws_ac_web_01</guid><pubDate>Tue, 12 Feb 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;AWS 아키텍처 - Web Application Hosting&lt;/h1&gt;
&lt;p&gt;What is &lt;code class=&quot;language-text&quot;&gt;Web-Application Hosting&lt;/code&gt; in &lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;AWS Reference Architecture&lt;/a&gt;?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;english&quot;&gt;&lt;pre class=&quot;language-english&quot;&gt;&lt;code class=&quot;language-english&quot;&gt;Highly available and scalable web hosting can be complex and expensive.
Dense peak periods and wild swings in traffic patterns result in low utilization of expensive hardware.

Amazon Web Services provides the reliable, scalable, secure, and high- performance infrastructure required for web applications while enabling an elastic, scale-out and scale-down infrastructure to match IT costs in real time as customer traffic fluctuates.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://media.amazonwebservices.com/architecturecenter/AWS_ac_ra_web_01.pdf&quot;&gt;AWS Reference Architecture&lt;/a&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;Web-Application Hosting&lt;/code&gt;은 무엇일까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;korean&quot;&gt;&lt;pre class=&quot;language-korean&quot;&gt;&lt;code class=&quot;language-korean&quot;&gt;고가용성 및 확장성 웹 호스팅은 복잡하고 비용이 많이 듭니다.
이는 트래픽 패턴이 짙어지면서 피크 시간이 길어지고 값 비싼 하드웨어의 사용률이 낮아집니다.

Amazon Web Services에서는 웹 애플리케이션에 필요한 안정적이고 확장 가능하며 안전한 고성능 인프라를 제공하는 동시에 고객 트래픽이 변동함에 따라 IT 비용을 실시간으로 일치시킬 수있는 유연한 스케일 아웃 및 축소형 인프라를 제공합니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?]]></title><description><![CDATA[<h2>시작하기 전에</h2>
<blockquote>
<p>본 글은 지극히 주관적인 관점, 즉 유명 오픈 소스의 메인테이너(관리자)가 아닌 순수히 취미 혹은 자기 계발을 위해 '오픈 소스'라는 도구를 활용해 그 문화에 입문하려는 이의 관점에서 쓰여진 글입니다.</p>
</blockquote>
<p><strong>오픈 소스</strong>란 무엇일까? 필자는 지금까지 <strong>오픈 소스</strong>라는 단어를 심심치 않게 들을 수 있었다. 하지만, 이 단어가 가진 의미를 정확하게 알기란 쉽지 않았다.</p>
<p>그래서 필자는 오픈 소스를 처음 접했을 때 주변의 누군가로부터 오픈 소스는 <code class="language-text">무료로 사용할 수 있는 코드</code>라고, 또 다른 누군가로부터 <code class="language-text">돈이 안 되는 자선사업 혹은 그러한 서비스</code>라는 이야기를 들었다. 한편으로는 취업을 준비하는 주변 친구들은 <code class="language-text">오픈 소스는 취업에 도움이 된다</code>는 식의 뜬구름 잡는 이야기를 하기도 했다.</p>
<p>그래서 필자는 이 글을 통해 스스로 오픈 소스와 오픈 소스 생태계란 무엇인지를 고민해보고자 했다.</p>
<p><img src="https://images.velog.io/post-images/rjs1197/92ddfeb0-23d1-11e9-b431-39bfc876f2e4/places-with-the-most-contributors.jpg" alt="places-with-the-most-contributors.jpg"></p>
<p>이 그림은 DashBouquet<a href="https://dashbouquet.com/blog/web-development/github-octoverse-2018-overview-top-trends">[1]</a>에서 가져온 전 세계 컨트리뷰터 현황에 대한 자료이다. 이 자료만 보더라도 아시아 지역에서는 중국과 일본이 단연 앞서고 있다.</p>
<blockquote>
<p>물론 이 자료는 2017년 10월 1 일부터 2018년 9월 30일까지의 GitHub 트랜드 통계를 바탕으로 작성되었고, 국내 개발자의 수가 타국에 비해 현저히 적다는 점, 국내에서는 잘못된 인식으로 오픈 소스에 대한 편견이 지배적이기 때문에 완전히 객관적이라고는 할 수 없다. 하지만, 단편적으로나마 국내의 오픈 소스 프로젝트 생태계의 현 위치를 짐작할 수 있을 것이다.</p>
</blockquote>
<p>필자는 이처럼 상대적으로 관심이 적은 국내의 오픈 소스 생태계를 개선하기 위해선 기본적으로 본질을 이해해야 접근할 수 있을 거라고 생각했다. 우선, 그 생태계를 이해하기에 앞서 왜 나는 오픈 소스라는 키워드를 가지고 이를 활용하려 할까? 왜 주변 사람들은 오픈 소스가 중요하다고 이야기하는 걸까?</p>
<h2>오픈 소스란 무엇일까?</h2>
<p>과거의 오픈 소스는 서론에서 말한 것과 같이 다양한 범주와 의견으로 정의할 수 있었다. 하지만, 현시점의 오픈 소스는 한 개인이 쉽게 정의할 것이 아니라고 생각한다. 그 이유는 필자가 나열하는 것보다 본 글을 읽다 보면 자연스럽게 느낄 수 있을 것이기 때문에 여기서 따로 언급하지는 않고, 일부 사례를 통해 이를 느껴보도록 하자.</p>
<p>먼저, 위키피디아에서는 오픈 소스를 다음과 같이 정의하고 있다<a href="https://en.wikipedia.org/wiki/Open_source">[2]</a>.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Open source is a term denoting that a product includes permission to
use its source code, design documents, or content.

...</code></pre></div>
<p>한글로 해석하자면 <code class="language-text">&quot;오픈 소스는 제품에 대한 소스 코드, 디자인 문서 또는 콘텐츠를 사용할 수 있는 권한이 있음을 나타낸다.&quot;</code>라고 할 수 있다. 이를 통해 단편적이지만 '오픈 소스'라는 것은 어떠한 제품에 대한 지적 재산권을 나타낸다는 것을 알 수 있었다.</p>
<p>이를 통해 필자는 "그렇다면 오픈 소스 프로젝트 중에서 영리적인 사업을 하는 프로젝트들도 있나?"라거나 "소스 코드는 공개하지만, 오픈 소스의 수정은 거부하는 프로젝트들도 오픈 소스로서 존재할 수 있는 걸까?"라는 의문이 들었지만 위 정의만으로 그 의문을 해결하기란 어려웠다.</p>
<p>글을 작성하고 시간이 흘러 여러 피드백을 받아 수정하게 되면서 다음과 같은 힌트를 얻을 수 있었다.</p>
<hr>
<p>Debian에서 말한 'Free'와 'Free Software'의 의미<a href="https://www.debian.org/intro/free.en.html?fbclid=IwAR1ou9joShVBLNWdU4NjOm05ztGxbohRo5B95g98q40hqLHFAX2tmuDUMtg">[2-1]</a>를 살펴보면, 여기서의 'Free'는 우리가 일상적으로 사용하는 의미 중 하나인 '무료(at no cost)'가 아닌 '자유(freedom)'를 나타낸다고 말한다.</p>
<p>어쩌면 두 의미를 같다고 볼 수도 있지만, 필자가 느끼기에는 '오픈 소스'라는 단어가 가지는 'Open'의 의미가 '프리웨어(공공제)' 혹은 '셰어웨어'의 그것과는 전혀 다른 것이라고 느꼈다.</p>
<p>이어 읽어나가다 보면 오픈 소스는 '라이선스'라는 것을 가지며, 이를 통해 오픈 소스는 지적 재산권이 있는 원작자의 요구에 맞게 사용되어야 한다는 구문이 서술되어 있다.</p>
<p>이 점을 통해 "오픈 소스를 한다"라는 의미는 마냥 비용이 없는(at no cost) 소프트웨어를 만드는 의미가 아닌 "원작자 즉, 개발자의 의도가 자유로이 반영되어 운영되는 프로젝트를 진행한다"라는 의미가 아닐까 하는 생각도 들었다.</p>
<p>또한, 글에서는 오픈 소스 제작자들이 체택하는 일반적인 라이선스 조합에 대해 소개하고 있다.</p>
<ul>
<li>
<p>Not allowing use of their code in proprietary software. Since they are releasing their code for all to use, they don't want to see others steal it. In this case, use of the code is seen as a trust: you may use it, as long as you play by the same rules.</p>
</li>
<li>
<p>Protecting identity of authorship of the code. People take great pride in their work and do not want someone else to come along and remove their name from it or claim that they wrote it.</p>
</li>
<li>
<p>Distribution of source code. One of the problems with most proprietary software is that you can't fix bugs or customize it since the source code is not available. Also, the company may decide to stop supporting the hardware you use. Many free licenses force the distribution of the source code. This protects the user by allowing them to customize the software for their needs.</p>
</li>
<li>
<p>Forcing any work that includes part of their work (such works are called derived works in copyright discussions) to use the same license.</p>
</li>
</ul>
<p>이를 한글로 해석해보면 다음과 같다.</p>
<ul>
<li>
<p>독점적인 소프트웨어에서의 코드 사용을 거부합니다. 그들은 모두가 사용할 수 있도록 코드를 제공하지 않기 때문에 다른 사람들이 이것을 훔치려는 것을 보고싶지 않습니다. 이 사례는 '코드의 사용'을 '신뢰'라고 봅니다: 이 경우 동일한 라이선스의 규칙을 적용하면 코드를 사용할 수 있습니다.</p>
</li>
<li>
<p>코드 원작자의 신원을 보호합니다. 사람들은 그들의 일에 큰 자부심을 느끼고 있기에 원작자의 이름을 지우거나 자신이 쓴 것이라고 주장하지 말아야 합니다.</p>
</li>
<li>
<p>소스 코드의 배포(를 강제합니다). 독점 소프트웨어의 문제 중 하나는 소스 코드를 사용할 수 없기 때문에 사용자가 직접 버그를 수정하거나 맞춤화(customize)하는 것이 불가능하다는 것입니다. 또한, 회사는 귀하가 사용하는 하드웨어의 지원을 중단할 수도 있습니다. 많은 자유(Free) 라이선스들이 소스 코드의 배포를 강제하고 있습니다. 이는 사용자가 자신의 필요에 맞게 소프트웨어를 맞춤화할 수 있도록하여 사용자를 보호합니다.</p>
</li>
<li>
<p>저작물의 일부를 포함하는 저작물('Copyright Discussions'에서 <em>파생 저작물</em>이라고 정의함)이 동일한 라이선스를 사용하도록 강요합니다.</p>
</li>
</ul>
<p>필자는 이 문장들을 읽고 많은 오픈 소스 프로젝트는 원작자의 라이선스에 명시된 의도를 훼손하지 않는다면, 그의 저작물 사용이 가능하다는 것을 말하고자 하는 것이라 생각했다.</p>
<p>더불어 글의 다음 단락에서는 많은 사람들이 자체 라이선스를 쓰게 되면 모호한 문구 혹은 미묘한 문제가 되는 문장의 사용이 법적 문제에서 원작자의 권한을 침해할 수 있는 것을 우려해 가장 널리 사용되는 라이선스에 대해서도 소개한다.</p>
<ul>
<li>The <a href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License (GPL)</a>. Some good background information on software licenses and a copy of the license can be found at the GNU web site. This is the most common free license in use in the world.</li>
<li><a href="https://opensource.org/licenses/artistic-license.php">Artistic License.</a></li>
<li><a href="https://www.debian.org/misc/bsd.license">BSD style license.</a></li>
</ul>
<p>이 라이선스들은 다음과 같은 공통점을 지닌다.</p>
<ul>
<li>You can install the software on as many machines as you want.</li>
<li>Any number of people may use the software at one time.</li>
<li>You can make as many copies of the software as you want and give them to whomever you want (free or open redistribution).</li>
<li>There are no restrictions on modifying the software (except for keeping certain notices intact).</li>
<li>There is no restriction on distributing, or even selling, the software.</li>
</ul>
<p>마지막으로 OSI(Open Source Initiative)에서는 The Open Source Definition<a href="https://opensource.org/osd">[2-2]</a>에서 다음 10가지의 문장으로 Open Source를 정의한다는 것도 알아두도록 하자.</p>
<ol>
<li>자유 배포(Free Redistribution)</li>
<li>소스코드 공개(Source Code Open)</li>
<li>2차적 저작물(의 허용)(Derived Works)</li>
<li>원작자의 소스코드 수정 제한(Integrity of The Author's Source Code)</li>
<li>개인이나 단체에 대한 차별 금지(No Discrimination Against Persons or Groups)</li>
<li>사용 분야에 대한 제한 금지(No Discrimination Against Fields of Endeavor)</li>
<li>라이선스의 배포 (Distribution of License)</li>
<li>라이선스 적용상의 동일성 유지 (License must not be specific to a product)</li>
<li>다른 라이선스의 포괄적 수용 (License must not contaminate other software)</li>
<li>라이선스의 기술적 중립성 (License must be Technology-Neutral)</li>
</ol>
<blockquote>
<p>이 Open Source Definition은 <a href="(https://www.debian.org/social_contract#guidelines)">Debian Free Software Guidelines</a>(DFSG)에서 유래되었다는 것을 알아두고 이를 참고하도록 하자.</p>
</blockquote>
<p>글을 작성 및 수정하며 얻은 소감은 Debian에서 제공한 가이드라인과 OSI의 가이드라인은 약간 다를 뿐 거의 유사하다는 것이고, 근래에 들어서는 Free와 Open을 나누지않고 FOSS(Free &#x26; Open Source Software)라 칭한다는 것이다.</p>
<p>더불어 오픈 소스의 Open이 가지는 의미는 공짜가 아닌 소스 코드 및 SW의 자유로운 사용이라는 것을 알게 되었다.</p>
<blockquote>
<p>추가적으로 필자는 OSI의 창립자 레이몬드가 칭한 '오픈 소스'라는 단어는 상업화(Commercialization)에 대한 반대급부라고 이해했다. 하지만 그럼에도 왜 Open Source Software라고 부르며 이를 '소프트웨어'라 제품화를 시키는 것일까? 코드는 그저 특정 문제를 해결하기 위한 명세로 이야기되는 것이 아닌가? 왜 이를 위한 제품이 '오픈 소스'로서 이야기될 수 있는 것일까?</p>
<p>이러한 고민을 하게 된 까닭은 오픈 소스 소프트웨어라 칭함으로 인해 오픈 소스는 그 자체로 자유로운 의미로서 상업화의 반대급부로 정의하지만, 이를 활용하는 비즈니스 모델의 존재에 대한 여지를 주기 때문이다. 비즈니스 모델이 있는 오픈 소스 서비스들은 오픈 소스 문화에 동참하지 않는 것일까? 이러한 고민의 답은 다음의 'RedHat'의 사례를 통해 힌트를 얻어보도록 하자.</p>
</blockquote>
<h2>오픈 소스를 활용한 서비스들</h2>
<p><img src="https://images.velog.io/post-images/rjs1197/02e275c0-23d6-11e9-bf21-f7a982ab1aa4/ap550x55016x121transparentt.png" alt="ap,550x550,16x12,1,transparent,t.png"></p>
<p>위 그림<a href="https://www.google.com/url?sa=i&#x26;source=images&#x26;cd=&#x26;ved=2ahUKEwixjszon5PgAhXJ7WEKHRfWAwIQjRx6BAgBEAU&#x26;url=https%3A%2F%2Fwww.redbubble.com%2Fpeople%2Fradixvinni%2Fworks%2F30430581-developer-icons-open-source-project-logos-web-companies%3Fp%3Dart-print&#x26;psig=AOvVaw1ePP6ojSivrUxMGaEoLdwx&#x26;ust=1548860098305404">[3]</a>을 보면 우리가 흔히 접했던 프로젝트부터 난생처음 보는 프로젝트까지 다양하게 있는 것을 볼 수 있다.</p>
<p>위의 로고 중 필자가 아는 서비스에 한해 오픈 소스와 밀접한 관계가 있는 저작물을 소개해보려 한다.</p>
<p>가장 먼저 보이는 <code class="language-text">RedHat</code>은 대표적으로 오픈 소스를 통해 비즈니스를 하는 회사이다. 그들이 제공하는 저작물은 리눅스 운영체제가 대표적이고, 오픈 소스이기 때문에 기본적으로 자유로이 사용하는 것이 가능하다.</p>
<p>그렇다면 그들은 어떤 비즈니스 모델을 가지고 있을까? 어떻게 돈을 벌고, 이를 유지하고 있을까? 이에 대한 답을 고민하던 중 Quora의 <code class="language-text">&quot;What is Red Hat&#39;s business model?&quot;</code>라는 질문을 보게 되었는데, 이를 RedHat의 한 직원이 설명한 글<a href="https://www.quora.com/What-is-Red-Hats-business-model">[4]</a>을 통해 조금이나마 해결할 수 있었다. 그 중 일부는 다음과 같다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Red Hat doesn&#39;t sell software. You can download the software for free.

Red Hat sells service/support subscriptions.

...</code></pre></div>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Red Hat은 소프트웨어를 판매하지 않습니다. 무료로 소프트웨어를 다운로드 할 수 있습니다.

Red Hat은 서비스, 지원 구독(Support Subscription)을 판매합니다.

...</code></pre></div>
<p>글에서는 RedHat은 소프트웨어를 '판매'하지 않고, 소프트웨어를 사용하는 데 필요한 서비스와 Support Subscription을 판매한다고 이야기한다(최근에는 고도화된 소프트웨어를 판매하기도 한다). 그래서 그는 자신들의 제품인 <strong>RHEL, Fedora</strong> 또는 <strong>CentOS</strong>를 다운로드하고, 수정하며 원하는대로 직접 컴파일하는 것을 자유로이 할 수 있다고 설명했다.</p>
<p>또한, 이와는 별개로 RedHat의 서비스가 제대로 작동되지 않을 때 RedHat의 지원을 받기 위해서는 Support Subscription 서비스에 대한 비용을 지불해야 한다는 식으로 이야기한다.</p>
<p>이런 비즈니스 모델을 가지고 있기 때문에 RedHat은 오픈 소스의 범주 안에서 경영을 할 수 있고, 오픈 소스를 활용한 사업의 선사례로 꼽히는 모양이다. 더불어 RedHat은 '오픈 소스 소프트웨어'를 운영하고 있기 때문에 이에 대한 서비스 개선을 계속해서 진행한다.</p>
<blockquote>
<p>Quora의 글을 읽기 전까지 필자는 레드헷의 제품이 단순하게 무료와 유료 버전으로 나뉘어져 있고, 사용자에게는 각각 다른 가치를 얻는다고 생각했다. 하지만 RedHat이 가진 가치는 그것이 아닌 오픈 소스라는 이름에 걸맞는 것이었다고 느끼게 되어 감사하게 읽었다.</p>
<p>이를 통해 필자는 RedHat은 오픈 소스라는 매개 자체로 비즈니스 모델을 구축했다기 보다는 오픈 소스를 활용한 저작물을 통해 비즈니스 모델을 구축한 것이라고 이해할 수 있었다. 그렇다면 오픈 소스 소프트웨어는 오픈 소스를 활용한 소프트웨어라고 이해하는 것이 맞을까? 이렇게 이해한다면 품고 있던 수익성에 대한 의문은 말끔히 정리될테니 말이다.</p>
</blockquote>
<hr>
<p>다시 앞선 그림으로 돌아가 다른 사례를 고민하던 중 프로그래밍 언어 중 하나인 <code class="language-text">C/C++</code>에 대해 궁금해졌다. 프로그래밍 언어도 오픈 소스와 관련이 있을까? 보통 컴파일 언어를 사용하기 위해서는 컴파일러라는 소프트웨어가 필수적으로 필요한데, 이때 사용하는 컴파일러들은 지금껏 의식없이 사용했었으니 말이다.</p>
<p>이와 더불어 프로그래밍 언어에서 사용하는 각종 라이브러리 혹은 패키지같이 언어를 둘러싼 모든 환경에서 오픈 소스가 사용될 수 있을 것이다. 우리가 흔히 사용하는 컴파일러 중에는 오픈 소스인 것들도 다양할 것이고, 세상에는 다양한 언어와 이를 둘러싼 환경이 있을 것이기 때문이다.</p>
<blockquote>
<p>러프하게 알 수 있는 오픈 소스 컴파일러 목록은 이 곳<a href="https://en.wikipedia.org/wiki/List_of_compilers">[5]</a>에서 찾을 수 있다.</p>
<p>추가적으로 프로그래밍 언어 같은 경우는 보편적으로 사용자에게 공공제로 제공되지만, 언어의 표준과 같이 특정 규율을 정하는 것은 별도의 기구(ISO<a href="https://www.iso.org/">[5-1]</a>)에서 관리하기도 한다.</p>
</blockquote>
<p>즉, <code class="language-text">C/C++</code>과 같은 프로그래밍 언어 또한 오픈 소스와 밀접하며, 이를 위한 오픈 소스 컴파일러는 당연히 소스 코드를 공개하고 이를 수정할 수 있다<a href="https://gcc.gnu.org/">[6]</a>.</p>
<hr>
<p>이쯤에서 다음과 같은 의문이 들 수 있다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">그렇다면 오픈 소스가 아닌 건 무엇일까?</code></pre></div>
<p>여기까지 쓰고 난 본인의 견해로는 이에 대한 답을 내리기 위해서는 <strong>오픈 소스가 아닌 것</strong>을 나열하기보다 <strong>오픈 소스인 것</strong>을 고민해야 한다고 느꼈다. 그렇기 때문에 만약 오픈 소스에 대해 보다 깊은 이해를 원하는 독자는 다음의 자료를 참고하길 바란다.</p>
<ul>
<li><a href="https://www.debian.org/intro/free.en.html">https://www.debian.org/intro/free.en.html</a></li>
<li><a href="https://www.gnu.org/philosophy/free-sw.en.html">https://www.gnu.org/philosophy/free-sw.en.html</a></li>
<li><a href="https://opensource.org/osd-annotated">https://opensource.org/osd-annotated</a></li>
</ul>
<blockquote>
<p>글을 수정하며 얻은 다양한 조언을 통해서 이제는 '오픈 소스'라는 단어가 각 개인의 의견으로 정의될 수 없다고 생각이 굳어졌다(그 정의에 대한 서적은 이미 차고 넘치기 때문이다).</p>
<p>물론 그 정의에 대한 각 개인의 이해와 파생된 견해가 다를 수 있겠지만 결과적으로 과거부터 이야기되어 현재에 이르러서는 논쟁의 여지가 수그러든 것이기 때문에 앞선 것과 같이 '오픈 소스는 이미 정의되어 있다'라고 생각을 굳힐 수 있었다.</p>
</blockquote>
<p>여기까지 글을 적으며 필자는 오픈 소스에 대해 어렴풋이 이해할 수 있게 되었다고 생각한다. 그럼에도 아직 오픈 소스를 둘러싸고 있는 그 환경에 대해서는 익숙하지 않다.</p>
<p>주변에서는 국내 오픈 소스 생태계에 불만을 품은 이들도 상당하다. 그들은 왜 그런 불만을 가지고 있을까? 그래서 이번에는 오픈 소스 생태계란 무엇인지를 살펴보도록 하자.</p>
<h2>오픈 소스 생태계란 무엇일까?</h2>
<p><img src="https://images.velog.io/post-images/rjs1197/9f6299c0-23db-11e9-bf21-f7a982ab1aa4/2016-2017-trends-open-source-ecosystem.jpg" alt="2016-2017-trends-open-source-ecosystem.jpg"></p>
<p>이 그림<a href="https://www.google.com/url?sa=i&#x26;source=images&#x26;cd=&#x26;ved=2ahUKEwjrho_4qJPgAhWWad4KHd4VAy8QjRx6BAgBEAU&#x26;url=https%3A%2F%2Fwww.altoros.com%2Fblog%2F2016-2017-trends-the-open-source-ecosystem-is-universal%2F&#x26;psig=AOvVaw1t-rgseFFa4Lscy9er3gEc&#x26;ust=1548862555751385">[7]</a>은 단일 오픈 소스 생태계를 가시적으로 보여준다고 느껴서 가져왔다.</p>
<p>이 그림은 <strong>단일 오픈 소스를 활용한 솔루션</strong>을 제공하는 <code class="language-text">VENDORS</code>, <strong>단일 오픈 소스를 지원</strong>하는 <code class="language-text">EXPERTS</code>와 <strong>단일 오픈 소스에 대한 조언, 기여 등</strong>을 제공하는 <code class="language-text">COMMUNITY</code>, 마지막으로 <strong>단일 오픈 소스와 이로 만들어진 솔루션들에 대한 피드백</strong>을 제공하는 <code class="language-text">USERS</code>로서 4사분면을 그리며 선순환을 이루고 있다.</p>
<p>이러한 선순환의 결과는 오픈 소스 생태계의 확장으로 이어질 것이고, "결과적으로 다양한 프로젝트들의 유지력도 향상될 수 있지 않을까?"라는 생각도 해봤다.</p>
<p>또한, 그렇게 된다면 사용자의 관점에서도, 기업의 관점에서도 오픈 소스라는 주제가 매력적으로 다가올 수 있지 않을까라는 결론도 조심스럽게 내려보았다.</p>
<blockquote>
<p>여기서의 매력은 각기 다르게 이야기될 수 있을 것이다. '비용적인' 측면을 차치하고 말이다.</p>
</blockquote>
<p>하지만, 이처럼 건강한 생태계를 유지하기는 쉽지 않을 것만 같다. 프로젝트가 커짐에 따라 한 개인이 관리하기에는 부담스러울뿐더러 기업의 입장에서도 하나의 생태계를 책임진다는 것은 큰 위험 부담을 감수하는 것이기 때문이다. 그렇다고 국가(정부기관)가 떠안기에는 상대적으로 이해관계가 성립되기 힘들다는 생각도 해봤다.</p>
<blockquote>
<p>물론 이러한 위험 부담에도 생태계를 책임지고 있는 <code class="language-text">Google</code>과 <code class="language-text">Facebook</code>, <code class="language-text">Alibaba</code> 등이 있는 것도 사실이고 미국이나 독일 등 다양한 국가에서 정부 차원의 지원이 있는 것은 사실이기에 이 부분은 국내의 정서로 받아들이기에는 다소 민감할 수 있겠다.</p>
</blockquote>
<hr>
<p>이제 필자는 오픈 소스 생태계의 실루엣을 어느 정도나마 엿볼 수 있게 되었다. 그렇다면 왜 필자는 최근에서야 오픈 소스라는 주제에 관심을 가지게 되었을까? 그것은 필자의 경험 부족과 더불어 오픈 소스의 중요성이 수면 위로 뜨게 된 것이 얼마되지 않았기 때문라고 생각한다.</p>
<p>이는 그 누구의 잘못도 아닐뿐더러 이미 각 사분면의 구성원들이 노력하고 있었기 때문에 지금에서라도 수면 위로 드러난 것이기에 본격적인 이야기에 앞서 그들의 노고가 어떠했을지 마냥 고개를 조아리게 된다.</p>
<p>그래서 필자는 생태계 각 구성원들의 활약이 궁금해졌다. 주변인들이 국내 오픈 소스 생태계가 제대로 구성되어 있지 않다고 느낀 이유는 위에서 언급한 기업들 같은 <code class="language-text">VENDORS(DRIVERS)</code>의 부재 때문일까?</p>
<p>여기에 대한 답을 내리려면 보다 다양한 토론과 본질적인 문제에 대한 접근이 필요할 것이다.</p>
<blockquote>
<p>그럼에도 한 가지 확실한 것은 개인의 입장에서 오픈 소스에 기여하는 것 또한 중요하다는 것이다.</p>
</blockquote>
<p>가령 국내에서 오픈 소스 생태계에 관여하고 있는 기업이 다수 존재한다. 대표적으로 삼성과 네이버 또한 GitHub<a href="https://github.com/samsung">[7]</a><a href="https://github.com/naver">[8]</a>을 통해 국내 오픈 소스 생태계에 기여하고 있는 것을 쉽게 찾을 수 있다.</p>
<blockquote>
<p>물론 참여하고 있는 기업은 더 다양하다!</p>
</blockquote>
<p>그렇다면 필자가 찾고자 했던 근본적인 문제는 <code class="language-text">COMMUNITY</code>의 부재일까? 그렇지만도 않다. 그도 그럴 것이 자바스크립트 개발자 포럼<a href="https://jsdev.kr/">[9]</a>과 TensorflowKR<a href="https://www.facebook.com/groups/TensorFlowKR/">[10]</a>를 비롯한 여러 커뮤니티<a href="https://hamonikr.org/">[11]</a>, <a href="http://rankedin.kr/">[11-1]</a>, <a href="https://kldp.org/">[11-2]</a>가 이미 충분할 정도로 활성화되어있기 때문이다(오픈 소스만을 위한 커뮤니티로 활성화되어 있는지는 별개지만 말이다).</p>
<p>그렇다면 이제 남은 구성원인 <code class="language-text">USERS</code>와 <code class="language-text">EXPERTS</code>도 살펴보자.</p>
<p>잠시 전하자면 필자가 전하고자 하는 이 글의 목적은 단연코 <strong><code class="language-text">USERS</code>의 부재</strong>를 말하는 것이다. 여기서의 사용자는 프로젝트를 운영하는 메인테이너를 말하는 것이 아닌 컨트리뷰터를 의미한다. 이는 국내에 아무리 유명한 프로젝트가 많고, 훌륭한 메인테이너분들이 존재한다고 할지라도 이를 팔로우해줄 컨트리뷰터들이 없다면 이는 읽히지 않을 고전의 가치를 이야기하는 것과 같다고 생각하기 때문이다.</p>
<p>유저의 부재를 해결하기 위한 방법을 제시하기에는 이미 수많은 이들의 노고가 있었기 때문에 여기서 그것들을 다시 언급할 수는 없겠지만, 아직 견문이 짧은 필자가 느끼기에는 그들만의 리그가 구성되어 있는 것이 아닐까라고 생각했다. 한 마디로 진입장벽이 너무 높았다!</p>
<blockquote>
<p>이는 필자가 경험한 모든 오픈 소스 프로젝트들과 그 구성원들 모두가 체감하고 있으며 이를 위해 세세한 가이드를 제공하고 있다. 하지만 그럼에도 입문자에게 대부분의 오픈 소스는 기술에 대한 이해, 영어에 대한 언어적인 문제를 차치하고서라도 프로젝트에 기여하기 위해서는 커뮤니케이션 피드백이 늦다거나, 그 서비스가 무엇인지를 알아야 하고, 코어를 이해하지 못하면 쉽게 진입하기도 어렵기 때문에 느낀점이다.</p>
</blockquote>
<p>더불어 필자의 입장에서는 활성화되어 있다고 하는 여러 오픈 소스 프로젝트들과의 접점이 없어 기여하는 목정성을 느끼지 못하는 프로젝트가 대부분이었고, 이를 위한 각종 커뮤니티는 이미 오픈 소스의 장이 아닌 잡담의 장소 혹은 친목의 광장이었다.</p>
<blockquote>
<p>이를 부정적으로 생각하지는 않지만 마냥 '오픈 소스 커뮤니티'라는 느낌보다는 그저 개발에 대한 다양한 주제를 공유하는 커뮤니티라는 인식이 강했다.</p>
<p>참고로 필자에겐 리눅스 기반의 프로젝트 대부분은 과거 7080 전산실에서부터 내려오던 Nerd 성향이 강했다. '그냥 재미로'라는 리누스 토발즈의 자서전의 제목과는 상반되게 필자에게는 전혀 재미있지 않은 프로젝트였던 것이다.</p>
<p>추가적으로 이러한 주관적인 의견은 그러한 프로젝트나 커뮤니티를 폄하하려 한다기보다는 본인을 포함한 오픈 소스 입문자들의 기술 편식에 대해 이야기하고, 어떻게 하면 이를 극복할 수 있을까에 대한 고민을 해결하기 위해 공유한 것이니 커뮤니티에서 활동하시는 분들께 불편하게 느낄 수 있는 여지를 준 것에 대해 죄송하다는 말씀을 전하고 싶다.</p>
</blockquote>
<p>과거보다 오픈 소스 프로젝트의 사용자 수와 커뮤니티가 늘어난 것은 사실이지만 수가 늘어난 것과 생태계가 정상적으로 유지된다는 것은 별개의 이야기인 것 같다고 느꼈다.</p>
<p>이 글을 읽고 있는(이 글을 읽길 바라는) 독자들 중 일부는 GitHub과 같이 상대적으로 가시적인 소스 코드 호스팅 사이트에서조차 오픈 소스 프로젝트에 기여하기 위한 커밋 혹은 이슈보다는 자신의 프로젝트를 저장하기 위한 도구로 사용되고 있기 때문이다.</p>
<blockquote>
<p>물론 예외는 존재한다. 더이상의 논란은 독자 중 일부가 민감하게 받아드릴 수 있는 주제이기 때문에 넘어가도록 하자.</p>
</blockquote>
<p>결과적으로 필자는 보다 근본적으로 현 생태계의 문제를 따져보았을 때, "컨트리뷰터의 부재에 대한 책임은 결국 <code class="language-text">EXPERTS</code>에 있고, 그들이 주도적으로 <code class="language-text">Users</code>를 이끌어야만 건강한 생태계가 유지되는 것이 아닐까?"라는 생각을 했다.</p>
<p>국내에서는 기관 혹은 정부부처와 오픈 소스 저작권자(Maintainer)의 이해가 동일하지 않을 뿐더러 이해가 일치하더라도 이를 제대로 관리하려는 중앙 관리 기관의 역할도 제대로 수행되지 않는다고 느꼈기 때문이다.</p>
<blockquote>
<p>더이상의 발언은 문제의 여지로 발전할 것만 같아 말을 아끼지만 생태계에 대해서는 다양한 이해관계가 얽혀있어 도덕책처럼 이야기되는 위 그림의 생태계를 유지하기 어려운 것은 사실이라는 것을 깨닫게 되었다.</p>
</blockquote>
<p>이와 같은 시점에서 내가 할 수 있는 선택은 무엇이 있을까? 나는 오픈 소스라는 문화에 인생을 올인하여 장래를 이어나갈 생각도 없고, 그러한 사명을 느끼지도 못한다. 더불어 오픈 소스 프로젝트를 진행하는 것은 소소한 재미 혹은 알량한 명예를 위한 도구였을 뿐이고, 적절한 형상 관리를 위한 협업의 도구가 필요했기 때문이었다.</p>
<p>해외의 대부분 풀타임 오픈 소스 개발자들도 각자의 가치(명예, 재미, 금전적인 이익 등)를 추구하며 이에 대한 보상을 위해 그 길을 걷는 것인데, 이에 대한 보상은 커녕 푸대접뿐인 사회의 분위기 속에서 젊은이들은 그 속으로의 진입에 대해 리스키함을 넘어 실패에 대한 확증을 가지게 될까 걱정되기도 한다.</p>
<blockquote>
<p>필자에게 오픈 소스 프로젝트를 진행한다는 것은 자선사업을 하기 위한 것이 아니기 때문이다! 사회적인 명예 혹은 만족감, 뿌듯함과 같은 개인의 이익을 위해서이다!</p>
</blockquote>
<p>이러한 국내 오픈 소스 생태계를 보며 자란 필자와 같은 환경의 젊은 개발자 중에서 필자와 다른 의견을 가질 수 있는 이가 얼마나 있을지도 얼마나 있을까 싶어 필자의 "과연 나는 오픈 소스를 통해 원하고자 하는 가치를 얻을 수 있을까?"에 대한 고민이 깊어졌다.</p>
<p>가치를 추구하는 것은 개인의 자유지만 그에 대한 피드백은 확신할 수 없기 때문이다.</p>
<blockquote>
<p>여기까지 글을 쓴 필자에겐 우려가 되는 한 가지가 있다. 공개된 이 글을 읽는 독자의 신분은 다양할 것이고, 글을 소비하는 모든 이들의 입맛에 맞는 글을 써내려 간다는 것은 어려운 일이기 때문이다.</p>
<p>그렇기에 한 가지 당부의 말씀을 드리고 싶다. 필자의 글은 국내 오픈 소스와 관계된 어떠한 이해 관계도 고려하지않고 그저 필자가 느낀 심정을 써내려 온 것이라는 것이다. 따라서 이 글을 읽는 독자가 필자의 편향된 견해를 시장의 보편적인 정의로 이해하는 실수를 범하지 않길 바란다.</p>
<p>다시 한 번 강조하지만 필자는 오픈 소스로 학사 이상의 학위를 가지고 있지도, 어떠한 자격이나 권한도 없는 일개 개발자에 불과하다. 그래서 이 글을 읽으며 느낀 불편함은 그저 '잘 모르는 이야기' 혹은 '풋내나는 견해'라고 생각해주길 바라며 이에 양해를 구한다.</p>
</blockquote>
<p>앞으로 필자는 앞선 경험과 관점을 통해 스스로가 얻게 된 '내가 생각하는 오픈 소스를 활용하는 방법'에 대해 이야기하고자 한다. '오픈 소스'라는 단어는 이제 소프트웨어에 국한된 것만이 아닌 하드웨어에서의 기여도 활발하기 때문에 추후에 '오픈 소스 하드웨어'라는 주제를 이야기 할 수 있었으면 하는 개인적인 소망도 있다.</p>
<blockquote>
<p>물론 이는 앞서 우리가 탐구해본 주제와 사뭇 다를 수 있고, 단어의 선택에 대해 여러 진영에서의 불편함이 있을 수 있음을 유의해야 할 것이다.</p>
</blockquote>
<p>이렇게 줄글로만 필자의 생각을 전달한다고 해서 "그래! 오픈 소스, 나도 한 번 해보자!"하며 행동으로 실천할 수 있는 사람이 몇이나 있을까? 그래서 필자는 본 글을 시작으로 오픈 소스 기여를 다짐한 이들을 위해서나마 오픈 소스에 입문하기 위해 필요한 몇 가지 정보를 다음의 시리즈를 통해 하고자 한다.</p>
<p><a href="#">1. 오픈 소스 활용기(0) - 지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?</a><br>
<a href="#">2. 오픈 소스 활용기(1) - 개인 프로젝트 관리하기(준비중)</a><br>
<a href="#">3. 오픈 소스 활용기(2) - 팀 프로젝트 관리하기(준비중)</a><br>
<a href="#">4. 오픈 소스 활용기(3) - 유명 프로젝트 컨트리뷰터 되기(준비중)</a><br>
<a href="#">5. 오픈 소스 활용기(4) - 오픈소스 메인테이너 되기(준비중)</a><br>
<a href="#">6. 오픈 소스 활용기(5) - 한 편으로 끝나는 오픈소스 가이드(준비중)</a></p>
<blockquote>
<p>시리즈의 내용 또한 필자가 기록하고 싶은 것을 기록하기 위한 것이지 백과사전이 아님을 전하며, 주관적인 이야기가 아닌 펙트를 원한다면 전문가 분들의 이야기를 찾아 읽기를 바란다.</p>
</blockquote>
<p>마지막으로 필자가 위와 같은 시리즈를 연재하기로 한 이유를 공유하고자 한다. 필자가 경험한 '오픈 소스'라는 문화가 흥미로웠고 내가 알고 있는 기술로 다른 프로젝트에 기여하는 것에 재미를 느꼈기 때문에 스스로의 힘으로 오픈 소스에 빠져들고자 했던 과거의 필자가 필요로 했던 주제를 전하고 싶었다. 그것은 이 글과 같은 짧다면 짧은 한 편의 글이었기 때문이다.</p>
<p>다만, 앞으로의 글을 읽는 독자에게 한 가지 바라는 점이 있다면 글을 통해 얻은 정보와 지혜를 그대도 다른 이들에게 전하길 바란다는 것이다. 당장이라도 함께 공부하는 친구들에게, 주변의 동료에게 함께 오픈 소스를 시작하고자 다짐한다면 이 이상 건강한 문화를 만들기 위해 필요한 것도 없기 때문이다.</p>
<p>그럼 그대도 이 기회에 오픈 소스의 매력에 빠져보길 바란다!</p>
<blockquote>
<p>물론 오픈 소스로 생계를 유지할 생각을 하거나, 제 2의 리눅스를 꿈꾼다면 이 글이 아닌 전문가의 글을 참고하라. 제발.</p>
</blockquote>]]></description><link>https://rayleighko.github.io/blog/2019-01-30-what_is_opensource</link><guid isPermaLink="false">https://rayleighko.github.io/blog/2019-01-30-what_is_opensource</guid><pubDate>Wed, 30 Jan 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;시작하기 전에&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 지극히 주관적인 관점, 즉 유명 오픈 소스의 메인테이너(관리자)가 아닌 순수히 취미 혹은 자기 계발을 위해 &apos;오픈 소스&apos;라는 도구를 활용해 그 문화에 입문하려는 이의 관점에서 쓰여진 글입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;오픈 소스&lt;/strong&gt;란 무엇일까? 필자는 지금까지 &lt;strong&gt;오픈 소스&lt;/strong&gt;라는 단어를 심심치 않게 들을 수 있었다. 하지만, 이 단어가 가진 의미를 정확하게 알기란 쉽지 않았다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 오픈 소스를 처음 접했을 때 주변의 누군가로부터 오픈 소스는 &lt;code class=&quot;language-text&quot;&gt;무료로 사용할 수 있는 코드&lt;/code&gt;라고, 또 다른 누군가로부터 &lt;code class=&quot;language-text&quot;&gt;돈이 안 되는 자선사업 혹은 그러한 서비스&lt;/code&gt;라는 이야기를 들었다. 한편으로는 취업을 준비하는 주변 친구들은 &lt;code class=&quot;language-text&quot;&gt;오픈 소스는 취업에 도움이 된다&lt;/code&gt;는 식의 뜬구름 잡는 이야기를 하기도 했다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 이 글을 통해 스스로 오픈 소스와 오픈 소스 생태계란 무엇인지를 고민해보고자 했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/92ddfeb0-23d1-11e9-b431-39bfc876f2e4/places-with-the-most-contributors.jpg&quot; alt=&quot;places-with-the-most-contributors.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 그림은 DashBouquet&lt;a href=&quot;https://dashbouquet.com/blog/web-development/github-octoverse-2018-overview-top-trends&quot;&gt;[1]&lt;/a&gt;에서 가져온 전 세계 컨트리뷰터 현황에 대한 자료이다. 이 자료만 보더라도 아시아 지역에서는 중국과 일본이 단연 앞서고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이 자료는 2017년 10월 1 일부터 2018년 9월 30일까지의 GitHub 트랜드 통계를 바탕으로 작성되었고, 국내 개발자의 수가 타국에 비해 현저히 적다는 점, 국내에서는 잘못된 인식으로 오픈 소스에 대한 편견이 지배적이기 때문에 완전히 객관적이라고는 할 수 없다. 하지만, 단편적으로나마 국내의 오픈 소스 프로젝트 생태계의 현 위치를 짐작할 수 있을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;필자는 이처럼 상대적으로 관심이 적은 국내의 오픈 소스 생태계를 개선하기 위해선 기본적으로 본질을 이해해야 접근할 수 있을 거라고 생각했다. 우선, 그 생태계를 이해하기에 앞서 왜 나는 오픈 소스라는 키워드를 가지고 이를 활용하려 할까? 왜 주변 사람들은 오픈 소스가 중요하다고 이야기하는 걸까?&lt;/p&gt;
&lt;h2&gt;오픈 소스란 무엇일까?&lt;/h2&gt;
&lt;p&gt;과거의 오픈 소스는 서론에서 말한 것과 같이 다양한 범주와 의견으로 정의할 수 있었다. 하지만, 현시점의 오픈 소스는 한 개인이 쉽게 정의할 것이 아니라고 생각한다. 그 이유는 필자가 나열하는 것보다 본 글을 읽다 보면 자연스럽게 느낄 수 있을 것이기 때문에 여기서 따로 언급하지는 않고, 일부 사례를 통해 이를 느껴보도록 하자.&lt;/p&gt;
&lt;p&gt;먼저, 위키피디아에서는 오픈 소스를 다음과 같이 정의하고 있다&lt;a href=&quot;https://en.wikipedia.org/wiki/Open_source&quot;&gt;[2]&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Open source is a term denoting that a product includes permission to
use its source code, design documents, or content.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;한글로 해석하자면 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;오픈 소스는 제품에 대한 소스 코드, 디자인 문서 또는 콘텐츠를 사용할 수 있는 권한이 있음을 나타낸다.&amp;quot;&lt;/code&gt;라고 할 수 있다. 이를 통해 단편적이지만 &apos;오픈 소스&apos;라는 것은 어떠한 제품에 대한 지적 재산권을 나타낸다는 것을 알 수 있었다.&lt;/p&gt;
&lt;p&gt;이를 통해 필자는 &quot;그렇다면 오픈 소스 프로젝트 중에서 영리적인 사업을 하는 프로젝트들도 있나?&quot;라거나 &quot;소스 코드는 공개하지만, 오픈 소스의 수정은 거부하는 프로젝트들도 오픈 소스로서 존재할 수 있는 걸까?&quot;라는 의문이 들었지만 위 정의만으로 그 의문을 해결하기란 어려웠다.&lt;/p&gt;
&lt;p&gt;글을 작성하고 시간이 흘러 여러 피드백을 받아 수정하게 되면서 다음과 같은 힌트를 얻을 수 있었다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Debian에서 말한 &apos;Free&apos;와 &apos;Free Software&apos;의 의미&lt;a href=&quot;https://www.debian.org/intro/free.en.html?fbclid=IwAR1ou9joShVBLNWdU4NjOm05ztGxbohRo5B95g98q40hqLHFAX2tmuDUMtg&quot;&gt;[2-1]&lt;/a&gt;를 살펴보면, 여기서의 &apos;Free&apos;는 우리가 일상적으로 사용하는 의미 중 하나인 &apos;무료(at no cost)&apos;가 아닌 &apos;자유(freedom)&apos;를 나타낸다고 말한다.&lt;/p&gt;
&lt;p&gt;어쩌면 두 의미를 같다고 볼 수도 있지만, 필자가 느끼기에는 &apos;오픈 소스&apos;라는 단어가 가지는 &apos;Open&apos;의 의미가 &apos;프리웨어(공공제)&apos; 혹은 &apos;셰어웨어&apos;의 그것과는 전혀 다른 것이라고 느꼈다.&lt;/p&gt;
&lt;p&gt;이어 읽어나가다 보면 오픈 소스는 &apos;라이선스&apos;라는 것을 가지며, 이를 통해 오픈 소스는 지적 재산권이 있는 원작자의 요구에 맞게 사용되어야 한다는 구문이 서술되어 있다.&lt;/p&gt;
&lt;p&gt;이 점을 통해 &quot;오픈 소스를 한다&quot;라는 의미는 마냥 비용이 없는(at no cost) 소프트웨어를 만드는 의미가 아닌 &quot;원작자 즉, 개발자의 의도가 자유로이 반영되어 운영되는 프로젝트를 진행한다&quot;라는 의미가 아닐까 하는 생각도 들었다.&lt;/p&gt;
&lt;p&gt;또한, 글에서는 오픈 소스 제작자들이 체택하는 일반적인 라이선스 조합에 대해 소개하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Not allowing use of their code in proprietary software. Since they are releasing their code for all to use, they don&apos;t want to see others steal it. In this case, use of the code is seen as a trust: you may use it, as long as you play by the same rules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Protecting identity of authorship of the code. People take great pride in their work and do not want someone else to come along and remove their name from it or claim that they wrote it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Distribution of source code. One of the problems with most proprietary software is that you can&apos;t fix bugs or customize it since the source code is not available. Also, the company may decide to stop supporting the hardware you use. Many free licenses force the distribution of the source code. This protects the user by allowing them to customize the software for their needs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Forcing any work that includes part of their work (such works are called derived works in copyright discussions) to use the same license.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 한글로 해석해보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;독점적인 소프트웨어에서의 코드 사용을 거부합니다. 그들은 모두가 사용할 수 있도록 코드를 제공하지 않기 때문에 다른 사람들이 이것을 훔치려는 것을 보고싶지 않습니다. 이 사례는 &apos;코드의 사용&apos;을 &apos;신뢰&apos;라고 봅니다: 이 경우 동일한 라이선스의 규칙을 적용하면 코드를 사용할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 원작자의 신원을 보호합니다. 사람들은 그들의 일에 큰 자부심을 느끼고 있기에 원작자의 이름을 지우거나 자신이 쓴 것이라고 주장하지 말아야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소스 코드의 배포(를 강제합니다). 독점 소프트웨어의 문제 중 하나는 소스 코드를 사용할 수 없기 때문에 사용자가 직접 버그를 수정하거나 맞춤화(customize)하는 것이 불가능하다는 것입니다. 또한, 회사는 귀하가 사용하는 하드웨어의 지원을 중단할 수도 있습니다. 많은 자유(Free) 라이선스들이 소스 코드의 배포를 강제하고 있습니다. 이는 사용자가 자신의 필요에 맞게 소프트웨어를 맞춤화할 수 있도록하여 사용자를 보호합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;저작물의 일부를 포함하는 저작물(&apos;Copyright Discussions&apos;에서 &lt;em&gt;파생 저작물&lt;/em&gt;이라고 정의함)이 동일한 라이선스를 사용하도록 강요합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필자는 이 문장들을 읽고 많은 오픈 소스 프로젝트는 원작자의 라이선스에 명시된 의도를 훼손하지 않는다면, 그의 저작물 사용이 가능하다는 것을 말하고자 하는 것이라 생각했다.&lt;/p&gt;
&lt;p&gt;더불어 글의 다음 단락에서는 많은 사람들이 자체 라이선스를 쓰게 되면 모호한 문구 혹은 미묘한 문제가 되는 문장의 사용이 법적 문제에서 원작자의 권한을 침해할 수 있는 것을 우려해 가장 널리 사용되는 라이선스에 대해서도 소개한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;http://www.gnu.org/copyleft/gpl.html&quot;&gt;GNU General Public License (GPL)&lt;/a&gt;. Some good background information on software licenses and a copy of the license can be found at the GNU web site. This is the most common free license in use in the world.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.org/licenses/artistic-license.php&quot;&gt;Artistic License.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.debian.org/misc/bsd.license&quot;&gt;BSD style license.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 라이선스들은 다음과 같은 공통점을 지닌다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can install the software on as many machines as you want.&lt;/li&gt;
&lt;li&gt;Any number of people may use the software at one time.&lt;/li&gt;
&lt;li&gt;You can make as many copies of the software as you want and give them to whomever you want (free or open redistribution).&lt;/li&gt;
&lt;li&gt;There are no restrictions on modifying the software (except for keeping certain notices intact).&lt;/li&gt;
&lt;li&gt;There is no restriction on distributing, or even selling, the software.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;마지막으로 OSI(Open Source Initiative)에서는 The Open Source Definition&lt;a href=&quot;https://opensource.org/osd&quot;&gt;[2-2]&lt;/a&gt;에서 다음 10가지의 문장으로 Open Source를 정의한다는 것도 알아두도록 하자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;자유 배포(Free Redistribution)&lt;/li&gt;
&lt;li&gt;소스코드 공개(Source Code Open)&lt;/li&gt;
&lt;li&gt;2차적 저작물(의 허용)(Derived Works)&lt;/li&gt;
&lt;li&gt;원작자의 소스코드 수정 제한(Integrity of The Author&apos;s Source Code)&lt;/li&gt;
&lt;li&gt;개인이나 단체에 대한 차별 금지(No Discrimination Against Persons or Groups)&lt;/li&gt;
&lt;li&gt;사용 분야에 대한 제한 금지(No Discrimination Against Fields of Endeavor)&lt;/li&gt;
&lt;li&gt;라이선스의 배포 (Distribution of License)&lt;/li&gt;
&lt;li&gt;라이선스 적용상의 동일성 유지 (License must not be specific to a product)&lt;/li&gt;
&lt;li&gt;다른 라이선스의 포괄적 수용 (License must not contaminate other software)&lt;/li&gt;
&lt;li&gt;라이선스의 기술적 중립성 (License must be Technology-Neutral)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;이 Open Source Definition은 &lt;a href=&quot;(https://www.debian.org/social_contract#guidelines)&quot;&gt;Debian Free Software Guidelines&lt;/a&gt;(DFSG)에서 유래되었다는 것을 알아두고 이를 참고하도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;글을 작성 및 수정하며 얻은 소감은 Debian에서 제공한 가이드라인과 OSI의 가이드라인은 약간 다를 뿐 거의 유사하다는 것이고, 근래에 들어서는 Free와 Open을 나누지않고 FOSS(Free &amp;#x26; Open Source Software)라 칭한다는 것이다.&lt;/p&gt;
&lt;p&gt;더불어 오픈 소스의 Open이 가지는 의미는 공짜가 아닌 소스 코드 및 SW의 자유로운 사용이라는 것을 알게 되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추가적으로 필자는 OSI의 창립자 레이몬드가 칭한 &apos;오픈 소스&apos;라는 단어는 상업화(Commercialization)에 대한 반대급부라고 이해했다. 하지만 그럼에도 왜 Open Source Software라고 부르며 이를 &apos;소프트웨어&apos;라 제품화를 시키는 것일까? 코드는 그저 특정 문제를 해결하기 위한 명세로 이야기되는 것이 아닌가? 왜 이를 위한 제품이 &apos;오픈 소스&apos;로서 이야기될 수 있는 것일까?&lt;/p&gt;
&lt;p&gt;이러한 고민을 하게 된 까닭은 오픈 소스 소프트웨어라 칭함으로 인해 오픈 소스는 그 자체로 자유로운 의미로서 상업화의 반대급부로 정의하지만, 이를 활용하는 비즈니스 모델의 존재에 대한 여지를 주기 때문이다. 비즈니스 모델이 있는 오픈 소스 서비스들은 오픈 소스 문화에 동참하지 않는 것일까? 이러한 고민의 답은 다음의 &apos;RedHat&apos;의 사례를 통해 힌트를 얻어보도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;오픈 소스를 활용한 서비스들&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/02e275c0-23d6-11e9-bf21-f7a982ab1aa4/ap550x55016x121transparentt.png&quot; alt=&quot;ap,550x550,16x12,1,transparent,t.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 그림&lt;a href=&quot;https://www.google.com/url?sa=i&amp;#x26;source=images&amp;#x26;cd=&amp;#x26;ved=2ahUKEwixjszon5PgAhXJ7WEKHRfWAwIQjRx6BAgBEAU&amp;#x26;url=https%3A%2F%2Fwww.redbubble.com%2Fpeople%2Fradixvinni%2Fworks%2F30430581-developer-icons-open-source-project-logos-web-companies%3Fp%3Dart-print&amp;#x26;psig=AOvVaw1ePP6ojSivrUxMGaEoLdwx&amp;#x26;ust=1548860098305404&quot;&gt;[3]&lt;/a&gt;을 보면 우리가 흔히 접했던 프로젝트부터 난생처음 보는 프로젝트까지 다양하게 있는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;위의 로고 중 필자가 아는 서비스에 한해 오픈 소스와 밀접한 관계가 있는 저작물을 소개해보려 한다.&lt;/p&gt;
&lt;p&gt;가장 먼저 보이는 &lt;code class=&quot;language-text&quot;&gt;RedHat&lt;/code&gt;은 대표적으로 오픈 소스를 통해 비즈니스를 하는 회사이다. 그들이 제공하는 저작물은 리눅스 운영체제가 대표적이고, 오픈 소스이기 때문에 기본적으로 자유로이 사용하는 것이 가능하다.&lt;/p&gt;
&lt;p&gt;그렇다면 그들은 어떤 비즈니스 모델을 가지고 있을까? 어떻게 돈을 벌고, 이를 유지하고 있을까? 이에 대한 답을 고민하던 중 Quora의 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;What is Red Hat&amp;#39;s business model?&amp;quot;&lt;/code&gt;라는 질문을 보게 되었는데, 이를 RedHat의 한 직원이 설명한 글&lt;a href=&quot;https://www.quora.com/What-is-Red-Hats-business-model&quot;&gt;[4]&lt;/a&gt;을 통해 조금이나마 해결할 수 있었다. 그 중 일부는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Red Hat doesn&amp;#39;t sell software. You can download the software for free.

Red Hat sells service/support subscriptions.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Red Hat은 소프트웨어를 판매하지 않습니다. 무료로 소프트웨어를 다운로드 할 수 있습니다.

Red Hat은 서비스, 지원 구독(Support Subscription)을 판매합니다.

...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;글에서는 RedHat은 소프트웨어를 &apos;판매&apos;하지 않고, 소프트웨어를 사용하는 데 필요한 서비스와 Support Subscription을 판매한다고 이야기한다(최근에는 고도화된 소프트웨어를 판매하기도 한다). 그래서 그는 자신들의 제품인 &lt;strong&gt;RHEL, Fedora&lt;/strong&gt; 또는 &lt;strong&gt;CentOS&lt;/strong&gt;를 다운로드하고, 수정하며 원하는대로 직접 컴파일하는 것을 자유로이 할 수 있다고 설명했다.&lt;/p&gt;
&lt;p&gt;또한, 이와는 별개로 RedHat의 서비스가 제대로 작동되지 않을 때 RedHat의 지원을 받기 위해서는 Support Subscription 서비스에 대한 비용을 지불해야 한다는 식으로 이야기한다.&lt;/p&gt;
&lt;p&gt;이런 비즈니스 모델을 가지고 있기 때문에 RedHat은 오픈 소스의 범주 안에서 경영을 할 수 있고, 오픈 소스를 활용한 사업의 선사례로 꼽히는 모양이다. 더불어 RedHat은 &apos;오픈 소스 소프트웨어&apos;를 운영하고 있기 때문에 이에 대한 서비스 개선을 계속해서 진행한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Quora의 글을 읽기 전까지 필자는 레드헷의 제품이 단순하게 무료와 유료 버전으로 나뉘어져 있고, 사용자에게는 각각 다른 가치를 얻는다고 생각했다. 하지만 RedHat이 가진 가치는 그것이 아닌 오픈 소스라는 이름에 걸맞는 것이었다고 느끼게 되어 감사하게 읽었다.&lt;/p&gt;
&lt;p&gt;이를 통해 필자는 RedHat은 오픈 소스라는 매개 자체로 비즈니스 모델을 구축했다기 보다는 오픈 소스를 활용한 저작물을 통해 비즈니스 모델을 구축한 것이라고 이해할 수 있었다. 그렇다면 오픈 소스 소프트웨어는 오픈 소스를 활용한 소프트웨어라고 이해하는 것이 맞을까? 이렇게 이해한다면 품고 있던 수익성에 대한 의문은 말끔히 정리될테니 말이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;다시 앞선 그림으로 돌아가 다른 사례를 고민하던 중 프로그래밍 언어 중 하나인 &lt;code class=&quot;language-text&quot;&gt;C/C++&lt;/code&gt;에 대해 궁금해졌다. 프로그래밍 언어도 오픈 소스와 관련이 있을까? 보통 컴파일 언어를 사용하기 위해서는 컴파일러라는 소프트웨어가 필수적으로 필요한데, 이때 사용하는 컴파일러들은 지금껏 의식없이 사용했었으니 말이다.&lt;/p&gt;
&lt;p&gt;이와 더불어 프로그래밍 언어에서 사용하는 각종 라이브러리 혹은 패키지같이 언어를 둘러싼 모든 환경에서 오픈 소스가 사용될 수 있을 것이다. 우리가 흔히 사용하는 컴파일러 중에는 오픈 소스인 것들도 다양할 것이고, 세상에는 다양한 언어와 이를 둘러싼 환경이 있을 것이기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;러프하게 알 수 있는 오픈 소스 컴파일러 목록은 이 곳&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_compilers&quot;&gt;[5]&lt;/a&gt;에서 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;추가적으로 프로그래밍 언어 같은 경우는 보편적으로 사용자에게 공공제로 제공되지만, 언어의 표준과 같이 특정 규율을 정하는 것은 별도의 기구(ISO&lt;a href=&quot;https://www.iso.org/&quot;&gt;[5-1]&lt;/a&gt;)에서 관리하기도 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;code class=&quot;language-text&quot;&gt;C/C++&lt;/code&gt;과 같은 프로그래밍 언어 또한 오픈 소스와 밀접하며, 이를 위한 오픈 소스 컴파일러는 당연히 소스 코드를 공개하고 이를 수정할 수 있다&lt;a href=&quot;https://gcc.gnu.org/&quot;&gt;[6]&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이쯤에서 다음과 같은 의문이 들 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;그렇다면 오픈 소스가 아닌 건 무엇일까?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지 쓰고 난 본인의 견해로는 이에 대한 답을 내리기 위해서는 &lt;strong&gt;오픈 소스가 아닌 것&lt;/strong&gt;을 나열하기보다 &lt;strong&gt;오픈 소스인 것&lt;/strong&gt;을 고민해야 한다고 느꼈다. 그렇기 때문에 만약 오픈 소스에 대해 보다 깊은 이해를 원하는 독자는 다음의 자료를 참고하길 바란다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.debian.org/intro/free.en.html&quot;&gt;https://www.debian.org/intro/free.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gnu.org/philosophy/free-sw.en.html&quot;&gt;https://www.gnu.org/philosophy/free-sw.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.org/osd-annotated&quot;&gt;https://opensource.org/osd-annotated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;글을 수정하며 얻은 다양한 조언을 통해서 이제는 &apos;오픈 소스&apos;라는 단어가 각 개인의 의견으로 정의될 수 없다고 생각이 굳어졌다(그 정의에 대한 서적은 이미 차고 넘치기 때문이다).&lt;/p&gt;
&lt;p&gt;물론 그 정의에 대한 각 개인의 이해와 파생된 견해가 다를 수 있겠지만 결과적으로 과거부터 이야기되어 현재에 이르러서는 논쟁의 여지가 수그러든 것이기 때문에 앞선 것과 같이 &apos;오픈 소스는 이미 정의되어 있다&apos;라고 생각을 굳힐 수 있었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기까지 글을 적으며 필자는 오픈 소스에 대해 어렴풋이 이해할 수 있게 되었다고 생각한다. 그럼에도 아직 오픈 소스를 둘러싸고 있는 그 환경에 대해서는 익숙하지 않다.&lt;/p&gt;
&lt;p&gt;주변에서는 국내 오픈 소스 생태계에 불만을 품은 이들도 상당하다. 그들은 왜 그런 불만을 가지고 있을까? 그래서 이번에는 오픈 소스 생태계란 무엇인지를 살펴보도록 하자.&lt;/p&gt;
&lt;h2&gt;오픈 소스 생태계란 무엇일까?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/post-images/rjs1197/9f6299c0-23db-11e9-bf21-f7a982ab1aa4/2016-2017-trends-open-source-ecosystem.jpg&quot; alt=&quot;2016-2017-trends-open-source-ecosystem.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 그림&lt;a href=&quot;https://www.google.com/url?sa=i&amp;#x26;source=images&amp;#x26;cd=&amp;#x26;ved=2ahUKEwjrho_4qJPgAhWWad4KHd4VAy8QjRx6BAgBEAU&amp;#x26;url=https%3A%2F%2Fwww.altoros.com%2Fblog%2F2016-2017-trends-the-open-source-ecosystem-is-universal%2F&amp;#x26;psig=AOvVaw1t-rgseFFa4Lscy9er3gEc&amp;#x26;ust=1548862555751385&quot;&gt;[7]&lt;/a&gt;은 단일 오픈 소스 생태계를 가시적으로 보여준다고 느껴서 가져왔다.&lt;/p&gt;
&lt;p&gt;이 그림은 &lt;strong&gt;단일 오픈 소스를 활용한 솔루션&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;VENDORS&lt;/code&gt;, &lt;strong&gt;단일 오픈 소스를 지원&lt;/strong&gt;하는 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;와 &lt;strong&gt;단일 오픈 소스에 대한 조언, 기여 등&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;COMMUNITY&lt;/code&gt;, 마지막으로 &lt;strong&gt;단일 오픈 소스와 이로 만들어진 솔루션들에 대한 피드백&lt;/strong&gt;을 제공하는 &lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;로서 4사분면을 그리며 선순환을 이루고 있다.&lt;/p&gt;
&lt;p&gt;이러한 선순환의 결과는 오픈 소스 생태계의 확장으로 이어질 것이고, &quot;결과적으로 다양한 프로젝트들의 유지력도 향상될 수 있지 않을까?&quot;라는 생각도 해봤다.&lt;/p&gt;
&lt;p&gt;또한, 그렇게 된다면 사용자의 관점에서도, 기업의 관점에서도 오픈 소스라는 주제가 매력적으로 다가올 수 있지 않을까라는 결론도 조심스럽게 내려보았다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서의 매력은 각기 다르게 이야기될 수 있을 것이다. &apos;비용적인&apos; 측면을 차치하고 말이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만, 이처럼 건강한 생태계를 유지하기는 쉽지 않을 것만 같다. 프로젝트가 커짐에 따라 한 개인이 관리하기에는 부담스러울뿐더러 기업의 입장에서도 하나의 생태계를 책임진다는 것은 큰 위험 부담을 감수하는 것이기 때문이다. 그렇다고 국가(정부기관)가 떠안기에는 상대적으로 이해관계가 성립되기 힘들다는 생각도 해봤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이러한 위험 부담에도 생태계를 책임지고 있는 &lt;code class=&quot;language-text&quot;&gt;Google&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;Facebook&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Alibaba&lt;/code&gt; 등이 있는 것도 사실이고 미국이나 독일 등 다양한 국가에서 정부 차원의 지원이 있는 것은 사실이기에 이 부분은 국내의 정서로 받아들이기에는 다소 민감할 수 있겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;이제 필자는 오픈 소스 생태계의 실루엣을 어느 정도나마 엿볼 수 있게 되었다. 그렇다면 왜 필자는 최근에서야 오픈 소스라는 주제에 관심을 가지게 되었을까? 그것은 필자의 경험 부족과 더불어 오픈 소스의 중요성이 수면 위로 뜨게 된 것이 얼마되지 않았기 때문라고 생각한다.&lt;/p&gt;
&lt;p&gt;이는 그 누구의 잘못도 아닐뿐더러 이미 각 사분면의 구성원들이 노력하고 있었기 때문에 지금에서라도 수면 위로 드러난 것이기에 본격적인 이야기에 앞서 그들의 노고가 어떠했을지 마냥 고개를 조아리게 된다.&lt;/p&gt;
&lt;p&gt;그래서 필자는 생태계 각 구성원들의 활약이 궁금해졌다. 주변인들이 국내 오픈 소스 생태계가 제대로 구성되어 있지 않다고 느낀 이유는 위에서 언급한 기업들 같은 &lt;code class=&quot;language-text&quot;&gt;VENDORS(DRIVERS)&lt;/code&gt;의 부재 때문일까?&lt;/p&gt;
&lt;p&gt;여기에 대한 답을 내리려면 보다 다양한 토론과 본질적인 문제에 대한 접근이 필요할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그럼에도 한 가지 확실한 것은 개인의 입장에서 오픈 소스에 기여하는 것 또한 중요하다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;가령 국내에서 오픈 소스 생태계에 관여하고 있는 기업이 다수 존재한다. 대표적으로 삼성과 네이버 또한 GitHub&lt;a href=&quot;https://github.com/samsung&quot;&gt;[7]&lt;/a&gt;&lt;a href=&quot;https://github.com/naver&quot;&gt;[8]&lt;/a&gt;을 통해 국내 오픈 소스 생태계에 기여하고 있는 것을 쉽게 찾을 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 참여하고 있는 기업은 더 다양하다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그렇다면 필자가 찾고자 했던 근본적인 문제는 &lt;code class=&quot;language-text&quot;&gt;COMMUNITY&lt;/code&gt;의 부재일까? 그렇지만도 않다. 그도 그럴 것이 자바스크립트 개발자 포럼&lt;a href=&quot;https://jsdev.kr/&quot;&gt;[9]&lt;/a&gt;과 TensorflowKR&lt;a href=&quot;https://www.facebook.com/groups/TensorFlowKR/&quot;&gt;[10]&lt;/a&gt;를 비롯한 여러 커뮤니티&lt;a href=&quot;https://hamonikr.org/&quot;&gt;[11]&lt;/a&gt;, &lt;a href=&quot;http://rankedin.kr/&quot;&gt;[11-1]&lt;/a&gt;, &lt;a href=&quot;https://kldp.org/&quot;&gt;[11-2]&lt;/a&gt;가 이미 충분할 정도로 활성화되어있기 때문이다(오픈 소스만을 위한 커뮤니티로 활성화되어 있는지는 별개지만 말이다).&lt;/p&gt;
&lt;p&gt;그렇다면 이제 남은 구성원인 &lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;도 살펴보자.&lt;/p&gt;
&lt;p&gt;잠시 전하자면 필자가 전하고자 하는 이 글의 목적은 단연코 &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;USERS&lt;/code&gt;의 부재&lt;/strong&gt;를 말하는 것이다. 여기서의 사용자는 프로젝트를 운영하는 메인테이너를 말하는 것이 아닌 컨트리뷰터를 의미한다. 이는 국내에 아무리 유명한 프로젝트가 많고, 훌륭한 메인테이너분들이 존재한다고 할지라도 이를 팔로우해줄 컨트리뷰터들이 없다면 이는 읽히지 않을 고전의 가치를 이야기하는 것과 같다고 생각하기 때문이다.&lt;/p&gt;
&lt;p&gt;유저의 부재를 해결하기 위한 방법을 제시하기에는 이미 수많은 이들의 노고가 있었기 때문에 여기서 그것들을 다시 언급할 수는 없겠지만, 아직 견문이 짧은 필자가 느끼기에는 그들만의 리그가 구성되어 있는 것이 아닐까라고 생각했다. 한 마디로 진입장벽이 너무 높았다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 필자가 경험한 모든 오픈 소스 프로젝트들과 그 구성원들 모두가 체감하고 있으며 이를 위해 세세한 가이드를 제공하고 있다. 하지만 그럼에도 입문자에게 대부분의 오픈 소스는 기술에 대한 이해, 영어에 대한 언어적인 문제를 차치하고서라도 프로젝트에 기여하기 위해서는 커뮤니케이션 피드백이 늦다거나, 그 서비스가 무엇인지를 알아야 하고, 코어를 이해하지 못하면 쉽게 진입하기도 어렵기 때문에 느낀점이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;더불어 필자의 입장에서는 활성화되어 있다고 하는 여러 오픈 소스 프로젝트들과의 접점이 없어 기여하는 목정성을 느끼지 못하는 프로젝트가 대부분이었고, 이를 위한 각종 커뮤니티는 이미 오픈 소스의 장이 아닌 잡담의 장소 혹은 친목의 광장이었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이를 부정적으로 생각하지는 않지만 마냥 &apos;오픈 소스 커뮤니티&apos;라는 느낌보다는 그저 개발에 대한 다양한 주제를 공유하는 커뮤니티라는 인식이 강했다.&lt;/p&gt;
&lt;p&gt;참고로 필자에겐 리눅스 기반의 프로젝트 대부분은 과거 7080 전산실에서부터 내려오던 Nerd 성향이 강했다. &apos;그냥 재미로&apos;라는 리누스 토발즈의 자서전의 제목과는 상반되게 필자에게는 전혀 재미있지 않은 프로젝트였던 것이다.&lt;/p&gt;
&lt;p&gt;추가적으로 이러한 주관적인 의견은 그러한 프로젝트나 커뮤니티를 폄하하려 한다기보다는 본인을 포함한 오픈 소스 입문자들의 기술 편식에 대해 이야기하고, 어떻게 하면 이를 극복할 수 있을까에 대한 고민을 해결하기 위해 공유한 것이니 커뮤니티에서 활동하시는 분들께 불편하게 느낄 수 있는 여지를 준 것에 대해 죄송하다는 말씀을 전하고 싶다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과거보다 오픈 소스 프로젝트의 사용자 수와 커뮤니티가 늘어난 것은 사실이지만 수가 늘어난 것과 생태계가 정상적으로 유지된다는 것은 별개의 이야기인 것 같다고 느꼈다.&lt;/p&gt;
&lt;p&gt;이 글을 읽고 있는(이 글을 읽길 바라는) 독자들 중 일부는 GitHub과 같이 상대적으로 가시적인 소스 코드 호스팅 사이트에서조차 오픈 소스 프로젝트에 기여하기 위한 커밋 혹은 이슈보다는 자신의 프로젝트를 저장하기 위한 도구로 사용되고 있기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 예외는 존재한다. 더이상의 논란은 독자 중 일부가 민감하게 받아드릴 수 있는 주제이기 때문에 넘어가도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결과적으로 필자는 보다 근본적으로 현 생태계의 문제를 따져보았을 때, &quot;컨트리뷰터의 부재에 대한 책임은 결국 &lt;code class=&quot;language-text&quot;&gt;EXPERTS&lt;/code&gt;에 있고, 그들이 주도적으로 &lt;code class=&quot;language-text&quot;&gt;Users&lt;/code&gt;를 이끌어야만 건강한 생태계가 유지되는 것이 아닐까?&quot;라는 생각을 했다.&lt;/p&gt;
&lt;p&gt;국내에서는 기관 혹은 정부부처와 오픈 소스 저작권자(Maintainer)의 이해가 동일하지 않을 뿐더러 이해가 일치하더라도 이를 제대로 관리하려는 중앙 관리 기관의 역할도 제대로 수행되지 않는다고 느꼈기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;더이상의 발언은 문제의 여지로 발전할 것만 같아 말을 아끼지만 생태계에 대해서는 다양한 이해관계가 얽혀있어 도덕책처럼 이야기되는 위 그림의 생태계를 유지하기 어려운 것은 사실이라는 것을 깨닫게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이와 같은 시점에서 내가 할 수 있는 선택은 무엇이 있을까? 나는 오픈 소스라는 문화에 인생을 올인하여 장래를 이어나갈 생각도 없고, 그러한 사명을 느끼지도 못한다. 더불어 오픈 소스 프로젝트를 진행하는 것은 소소한 재미 혹은 알량한 명예를 위한 도구였을 뿐이고, 적절한 형상 관리를 위한 협업의 도구가 필요했기 때문이었다.&lt;/p&gt;
&lt;p&gt;해외의 대부분 풀타임 오픈 소스 개발자들도 각자의 가치(명예, 재미, 금전적인 이익 등)를 추구하며 이에 대한 보상을 위해 그 길을 걷는 것인데, 이에 대한 보상은 커녕 푸대접뿐인 사회의 분위기 속에서 젊은이들은 그 속으로의 진입에 대해 리스키함을 넘어 실패에 대한 확증을 가지게 될까 걱정되기도 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필자에게 오픈 소스 프로젝트를 진행한다는 것은 자선사업을 하기 위한 것이 아니기 때문이다! 사회적인 명예 혹은 만족감, 뿌듯함과 같은 개인의 이익을 위해서이다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 국내 오픈 소스 생태계를 보며 자란 필자와 같은 환경의 젊은 개발자 중에서 필자와 다른 의견을 가질 수 있는 이가 얼마나 있을지도 얼마나 있을까 싶어 필자의 &quot;과연 나는 오픈 소스를 통해 원하고자 하는 가치를 얻을 수 있을까?&quot;에 대한 고민이 깊어졌다.&lt;/p&gt;
&lt;p&gt;가치를 추구하는 것은 개인의 자유지만 그에 대한 피드백은 확신할 수 없기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기까지 글을 쓴 필자에겐 우려가 되는 한 가지가 있다. 공개된 이 글을 읽는 독자의 신분은 다양할 것이고, 글을 소비하는 모든 이들의 입맛에 맞는 글을 써내려 간다는 것은 어려운 일이기 때문이다.&lt;/p&gt;
&lt;p&gt;그렇기에 한 가지 당부의 말씀을 드리고 싶다. 필자의 글은 국내 오픈 소스와 관계된 어떠한 이해 관계도 고려하지않고 그저 필자가 느낀 심정을 써내려 온 것이라는 것이다. 따라서 이 글을 읽는 독자가 필자의 편향된 견해를 시장의 보편적인 정의로 이해하는 실수를 범하지 않길 바란다.&lt;/p&gt;
&lt;p&gt;다시 한 번 강조하지만 필자는 오픈 소스로 학사 이상의 학위를 가지고 있지도, 어떠한 자격이나 권한도 없는 일개 개발자에 불과하다. 그래서 이 글을 읽으며 느낀 불편함은 그저 &apos;잘 모르는 이야기&apos; 혹은 &apos;풋내나는 견해&apos;라고 생각해주길 바라며 이에 양해를 구한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;앞으로 필자는 앞선 경험과 관점을 통해 스스로가 얻게 된 &apos;내가 생각하는 오픈 소스를 활용하는 방법&apos;에 대해 이야기하고자 한다. &apos;오픈 소스&apos;라는 단어는 이제 소프트웨어에 국한된 것만이 아닌 하드웨어에서의 기여도 활발하기 때문에 추후에 &apos;오픈 소스 하드웨어&apos;라는 주제를 이야기 할 수 있었으면 하는 개인적인 소망도 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 이는 앞서 우리가 탐구해본 주제와 사뭇 다를 수 있고, 단어의 선택에 대해 여러 진영에서의 불편함이 있을 수 있음을 유의해야 할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이렇게 줄글로만 필자의 생각을 전달한다고 해서 &quot;그래! 오픈 소스, 나도 한 번 해보자!&quot;하며 행동으로 실천할 수 있는 사람이 몇이나 있을까? 그래서 필자는 본 글을 시작으로 오픈 소스 기여를 다짐한 이들을 위해서나마 오픈 소스에 입문하기 위해 필요한 몇 가지 정보를 다음의 시리즈를 통해 하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#&quot;&gt;1. 오픈 소스 활용기(0) - 지극히 주관적인 고민, 나에게 오픈 소스란 무엇일까?&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;2. 오픈 소스 활용기(1) - 개인 프로젝트 관리하기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;3. 오픈 소스 활용기(2) - 팀 프로젝트 관리하기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;4. 오픈 소스 활용기(3) - 유명 프로젝트 컨트리뷰터 되기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;5. 오픈 소스 활용기(4) - 오픈소스 메인테이너 되기(준비중)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;#&quot;&gt;6. 오픈 소스 활용기(5) - 한 편으로 끝나는 오픈소스 가이드(준비중)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시리즈의 내용 또한 필자가 기록하고 싶은 것을 기록하기 위한 것이지 백과사전이 아님을 전하며, 주관적인 이야기가 아닌 펙트를 원한다면 전문가 분들의 이야기를 찾아 읽기를 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마지막으로 필자가 위와 같은 시리즈를 연재하기로 한 이유를 공유하고자 한다. 필자가 경험한 &apos;오픈 소스&apos;라는 문화가 흥미로웠고 내가 알고 있는 기술로 다른 프로젝트에 기여하는 것에 재미를 느꼈기 때문에 스스로의 힘으로 오픈 소스에 빠져들고자 했던 과거의 필자가 필요로 했던 주제를 전하고 싶었다. 그것은 이 글과 같은 짧다면 짧은 한 편의 글이었기 때문이다.&lt;/p&gt;
&lt;p&gt;다만, 앞으로의 글을 읽는 독자에게 한 가지 바라는 점이 있다면 글을 통해 얻은 정보와 지혜를 그대도 다른 이들에게 전하길 바란다는 것이다. 당장이라도 함께 공부하는 친구들에게, 주변의 동료에게 함께 오픈 소스를 시작하고자 다짐한다면 이 이상 건강한 문화를 만들기 위해 필요한 것도 없기 때문이다.&lt;/p&gt;
&lt;p&gt;그럼 그대도 이 기회에 오픈 소스의 매력에 빠져보길 바란다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;물론 오픈 소스로 생계를 유지할 생각을 하거나, 제 2의 리눅스를 꿈꾼다면 이 글이 아닌 전문가의 글을 참고하라. 제발.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>